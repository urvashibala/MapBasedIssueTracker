## aca-control.ps1
<code>
# aca-control.ps1
# Start or stop the Azure Container Apps to save costs
# Usage: ./aca-control.ps1 start
#        ./aca-control.ps1 stop

param(
    [Parameter(Mandatory=$true)]
    [ValidateSet("start", "stop")]
    [string]$Action
)

$RESOURCE_GROUP = "Segfault"
$APPS = @("segfault-backend", "segfault-frontend")

Write-Host "=== ACA Control: $($Action.ToUpper()) ===" -ForegroundColor Cyan

foreach ($app in $APPS) {
    if ($Action -eq "stop") {
        Write-Host "Stopping $app..." -ForegroundColor Yellow
        az containerapp update --name $app --resource-group $RESOURCE_GROUP --min-replicas 0 --max-replicas 0
    } else {
        Write-Host "Starting $app..." -ForegroundColor Yellow
        az containerapp update --name $app --resource-group $RESOURCE_GROUP --min-replicas 1 --max-replicas 3
    }
}

Write-Host "`n=== Done ===" -ForegroundColor Green

if ($Action -eq "start") {
    $backendUrl = az containerapp show --name "segfault-backend" --resource-group $RESOURCE_GROUP --query "properties.configuration.ingress.fqdn" -o tsv
    $frontendUrl = az containerapp show --name "segfault-frontend" --resource-group $RESOURCE_GROUP --query "properties.configuration.ingress.fqdn" -o tsv
    Write-Host "Backend:  https://$backendUrl" -ForegroundColor Cyan
    Write-Host "Frontend: https://$frontendUrl" -ForegroundColor Cyan
}

</code>

## code_context.txt
<code>

</code>

## deploy-backend.ps1
<code>
# deploy-backend.ps1
# Deploys the backend to Azure Container Apps (Cloud Shell compatible)

$ErrorActionPreference = "Stop"

# Configuration
$ACR_NAME = "segfaultdockerimages"
$ACR_ENDPOINT = "segfaultdockerimages.azurecr.io"
$IMAGE_NAME = "segfault-backend"
$IMAGE_TAG = "latest"
$RESOURCE_GROUP = "Segfault"
$LOCATION = "westeurope"
$ACA_ENV_NAME = "segfault-deployment"
$ACA_APP_NAME = "segfault-backend"

# ACR credentials (hardcoded for toy project)
$ACR_USERNAME = "SegfaultDockerImages"
$ACR_PASSWORD = "6F6FiaZTXiNeBUk72T1MPVbzyzWxEaeD/bEHO9tmyB+ACRARTYoH"

Write-Host "=== Backend Deployment Script ===" -ForegroundColor Cyan

# Navigate to backend directory
Write-Host "`n[1/4] Navigating to segfault-backend..." -ForegroundColor Yellow
Set-Location -Path "$PSScriptRoot/segfault-backend"

# Build image using ACR Tasks (no local Docker needed)
Write-Host "`n[2/4] Building Docker image in ACR (cloud build)..." -ForegroundColor Yellow
az acr build --registry $ACR_NAME --image "${IMAGE_NAME}:${IMAGE_TAG}" .

# Check if ACA environment exists, create if not
Write-Host "`n[3/4] Setting up Azure Container Apps..." -ForegroundColor Yellow

$envExists = az containerapp env show --name $ACA_ENV_NAME --resource-group $RESOURCE_GROUP 2>$null
if (-not $envExists) {
    Write-Host "Creating ACA environment: $ACA_ENV_NAME" -ForegroundColor Magenta
    az containerapp env create `
        --name $ACA_ENV_NAME `
        --resource-group $RESOURCE_GROUP `
        --location $LOCATION
} else {
    Write-Host "ACA environment already exists: $ACA_ENV_NAME" -ForegroundColor Green
}

# Check if app exists
Write-Host "`n[4/4] Deploying Container App..." -ForegroundColor Yellow
$appExists = az containerapp show --name $ACA_APP_NAME --resource-group $RESOURCE_GROUP 2>$null

if (-not $appExists) {
    Write-Host "Creating Container App: $ACA_APP_NAME" -ForegroundColor Magenta
    
    az containerapp create `
        --name $ACA_APP_NAME `
        --resource-group $RESOURCE_GROUP `
        --environment $ACA_ENV_NAME `
        --image "${ACR_ENDPOINT}/${IMAGE_NAME}:${IMAGE_TAG}" `
        --registry-server $ACR_ENDPOINT `
        --registry-username $ACR_USERNAME `
        --registry-password $ACR_PASSWORD `
        --target-port 3000 `
        --ingress external `
        --min-replicas 1 `
        --max-replicas 3
} else {
    Write-Host "Updating Container App: $ACA_APP_NAME" -ForegroundColor Magenta
    az containerapp update `
        --name $ACA_APP_NAME `
        --resource-group $RESOURCE_GROUP `
        --image "${ACR_ENDPOINT}/${IMAGE_NAME}:${IMAGE_TAG}"
}

# Get the app URL
$appUrl = az containerapp show --name $ACA_APP_NAME --resource-group $RESOURCE_GROUP --query "properties.configuration.ingress.fqdn" -o tsv

Write-Host "`n=== Deployment Complete ===" -ForegroundColor Green
Write-Host "Backend URL: https://$appUrl" -ForegroundColor Cyan

# Return to original directory
Set-Location -Path $PSScriptRoot

</code>

## deploy.ps1
<code>
# deploy.ps1
# Deploys both backend and frontend to Azure Container Apps

$ErrorActionPreference = "Stop"

# Configuration
$ACR_NAME = "segfaultdockerimages"
$ACR_ENDPOINT = "segfaultdockerimages.azurecr.io"
$RESOURCE_GROUP = "Segfault"
$LOCATION = "westeurope"
$ACA_ENV_NAME = "segfault-deployment"

# Explicitly set correct frontend URL to override any local .env file baked into the image
$FRONTEND_URL_VAL = "https://segfault-frontend.politeriver-a25e3b65.westeurope.azurecontainerapps.io"

# ACR credentials
$ACR_USERNAME = "SegfaultDockerImages"
$ACR_PASSWORD = "6F6FiaZTXiNeBUk72T1MPVbzyzWxEaeD/bEHO9tmyB+ACRARTYoH"

Write-Host "=== Full Stack Deployment ===" -ForegroundColor Cyan

# ============================================
# STEP 1: Ensure ACA Environment exists
# ============================================
Write-Host "`n[1/6] Setting up ACA environment..." -ForegroundColor Yellow

$envExists = az containerapp env show --name $ACA_ENV_NAME --resource-group $RESOURCE_GROUP 2>$null
if (-not $envExists) {
    Write-Host "Creating ACA environment: $ACA_ENV_NAME" -ForegroundColor Magenta
    az containerapp env create `
        --name $ACA_ENV_NAME `
        --resource-group $RESOURCE_GROUP `
        --location $LOCATION
} else {
    Write-Host "ACA environment already exists: $ACA_ENV_NAME" -ForegroundColor Green
}

# ============================================
# STEP 2: Build & Deploy Backend
# ============================================
Write-Host "`n[2/6] Building backend image..." -ForegroundColor Yellow
Set-Location -Path "$PSScriptRoot/segfault-backend"
az acr build --registry $ACR_NAME --image "segfault-backend:latest" .

Write-Host "`n[3/6] Deploying backend..." -ForegroundColor Yellow
$backendExists = az containerapp show --name "segfault-backend" --resource-group $RESOURCE_GROUP 2>$null

if (-not $backendExists) {
    az containerapp create `
        --name "segfault-backend" `
        --resource-group $RESOURCE_GROUP `
        --environment $ACA_ENV_NAME `
        --image "${ACR_ENDPOINT}/segfault-backend:latest" `
        --registry-server $ACR_ENDPOINT `
        --registry-username $ACR_USERNAME `
        --registry-password $ACR_PASSWORD `
        --target-port 3000 `
        --ingress external `
        --min-replicas 1 `
        --max-replicas 3 `
        --env-vars FRONTEND_URL=$FRONTEND_URL_VAL
} else {
    az containerapp update `
        --name "segfault-backend" `
        --resource-group $RESOURCE_GROUP `
        --image "${ACR_ENDPOINT}/segfault-backend:latest" `
        --set-env-vars FRONTEND_URL=$FRONTEND_URL_VAL
}

# Get backend URL
$BACKEND_URL = az containerapp show --name "segfault-backend" --resource-group $RESOURCE_GROUP --query "properties.configuration.ingress.fqdn" -o tsv
$BACKEND_URL = "https://$BACKEND_URL"
Write-Host "Backend URL: $BACKEND_URL" -ForegroundColor Cyan

# ============================================
# STEP 3: Build & Deploy Frontend
# ============================================
Write-Host "`n[4/6] Building frontend image with API URL..." -ForegroundColor Yellow
Set-Location -Path "$PSScriptRoot/segfault-frontend"
az acr build --registry $ACR_NAME --image "segfault-frontend:latest" --build-arg "VITE_API_URL=$BACKEND_URL" --no-cache .

Write-Host "`n[5/6] Deploying frontend..." -ForegroundColor Yellow
$frontendExists = az containerapp show --name "segfault-frontend" --resource-group $RESOURCE_GROUP 2>$null

if (-not $frontendExists) {
    az containerapp create `
        --name "segfault-frontend" `
        --resource-group $RESOURCE_GROUP `
        --environment $ACA_ENV_NAME `
        --image "${ACR_ENDPOINT}/segfault-frontend:latest" `
        --registry-server $ACR_ENDPOINT `
        --registry-username $ACR_USERNAME `
        --registry-password $ACR_PASSWORD `
        --target-port 80 `
        --ingress external `
        --min-replicas 1 `
        --max-replicas 3
} else {
    az containerapp update `
        --name "segfault-frontend" `
        --resource-group $RESOURCE_GROUP `
        --image "${ACR_ENDPOINT}/segfault-frontend:latest"
}

# Get frontend URL
$FRONTEND_URL = az containerapp show --name "segfault-frontend" --resource-group $RESOURCE_GROUP --query "properties.configuration.ingress.fqdn" -o tsv

Write-Host "`n=== Deployment Complete ===" -ForegroundColor Green
Write-Host "Backend:  $BACKEND_URL" -ForegroundColor Cyan
Write-Host "Frontend: https://$FRONTEND_URL" -ForegroundColor Cyan

# Return to original directory
Set-Location -Path $PSScriptRoot
</code>

## package-lock.json
<code>
{
  "name": "project-2-segfault2",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {}
}

</code>

## README.md
<code>
[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/Ec25vTis)

# Frontend
State- React contexts
Auth- All token logic, protected route etc
Api- Axios interceptor, wrapper to store data in context
Components/Atoms- Smallest components that will be reused (button, slider, radio). Ideally no state
Components/Component name- Proper components that import atoms and will be imported by pages

# Backend
Api/routes- Define routes
api/controllers- Define http requests and responses- basic types
api/middlewares- Define stuff to add to requests and responses
data- interact with databases
services- business logic (authentication, data transformation etc)
appconfig- define connection strings etc. Could use env later

</code>

## tasklist.md
<code>
# Armaan
Dashboard structure- nav bar
Actual dashboard- listing all data in a table
# Urvashi
Login- Authentication, session management + frontend implemention
Home page -> Login page -> dashboard
Map visualization and interaction

# Aryan
Figures out OSM data fetching- caching + postgis (stream issues somehow)
Set up all apis required (login service etc )
Cache map pbfs
</code>

## segfault-backend\Dockerfile
<code>
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
COPY prisma ./prisma/

# Install dependencies (including devDependencies for tsx)
RUN npm ci

# Generate Prisma client
RUN npx prisma generate

# Copy source code
COPY . .

# Production stage (using tsx to run TypeScript directly)
FROM node:20-alpine

WORKDIR /app

# Copy everything from builder
COPY --from=builder /app ./

# Environment variables
ENV NODE_ENV=production
ENV PORT=3000
ENV DATABASE_URL="postgresql://neondb_owner:npg_5GC3NzTORMYr@ep-restless-pine-a1vn25d9-pooler.ap-southeast-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require"
ENV STORAGE_CONNECTION_STRING="DefaultEndpointsProtocol=https;AccountName=segfaultstorage3103;AccountKey=W8uzLvLydsQtC+S343wFzVW/67oeG4ulJ0aUiAjQA4F2pP+YBABgyV8gZMgdU2T1Vssn6syDzmOY+AStzwOwMQ==;EndpointSuffix=core.windows.net"
ENV REDIS_HOSTNAME="segfaultredis.redis.cache.windows.net"
ENV REDIS_ACCESS_KEY="OUW6tF0Qz9E0evWmQIeJ8sKAjKsPYxSkTAzCaDN3iFM="
ENV VITE_API_URL="https://segfault-backend.politeriver-a25e3b65.westeurope.azurecontainerapps.io"

EXPOSE 3000

# Use tsx to run TypeScript directly (same as dev mode)
CMD ["npx", "tsx", "src/index.ts"]
</code>

## segfault-backend\package-lock.json
<code>
{
  "name": "segfault-backend",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "segfault-backend",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "@azure/storage-blob": "^12.29.1",
        "@azure/storage-queue": "^12.28.1",
        "@prisma/client": "^6.19.0",
        "@turf/turf": "^7.3.1",
        "@types/nodemailer": "^7.0.4",
        "axios": "^1.13.2",
        "bcryptjs": "^3.0.3",
        "cookie-parser": "^1.4.7",
        "cors": "^2.8.5",
        "dotenv": "^17.2.3",
        "express": "^5.1.0",
        "json2csv": "^6.0.0-alpha.2",
        "jsonwebtoken": "^9.0.3",
        "multer": "^2.0.2",
        "nodemailer": "^7.0.11",
        "redis": "^5.10.0",
        "tinyqueue": "^3.0.0",
        "uuid": "^13.0.0"
      },
      "devDependencies": {
        "@types/bcryptjs": "^2.4.6",
        "@types/cookie-parser": "^1.4.10",
        "@types/cors": "^2.8.19",
        "@types/express": "^5.0.5",
        "@types/json2csv": "^5.0.7",
        "@types/jsonwebtoken": "^9.0.10",
        "@types/multer": "^2.0.0",
        "@types/node": "^24.10.0",
        "@types/uuid": "^10.0.0",
        "prisma": "^6.19.0",
        "ts-node": "^10.9.2",
        "typescript": "^5.9.3"
      }
    },
    "node_modules/@aws-crypto/sha256-browser": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/sha256-browser/-/sha256-browser-5.2.0.tgz",
      "integrity": "sha512-AXfN/lGotSQwu6HNcEsIASo7kWXZ5HYWvfOmSNKDsEqC4OashTp8alTmaz+F7TC2L083SFv5RdB+qU3Vs1kZqw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha256-js": "^5.2.0",
        "@aws-crypto/supports-web-crypto": "^5.2.0",
        "@aws-crypto/util": "^5.2.0",
        "@aws-sdk/types": "^3.222.0",
        "@aws-sdk/util-locate-window": "^3.0.0",
        "@smithy/util-utf8": "^2.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/is-array-buffer": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/is-array-buffer/-/is-array-buffer-2.2.0.tgz",
      "integrity": "sha512-GGP3O9QFD24uGeAXYUjwSTXARoqpZykHadOmA8G5vfJPK0/DC67qa//0qvqrJzL1xc8WQWX7/yc7fwudjPHPhA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-buffer-from": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-buffer-from/-/util-buffer-from-2.2.0.tgz",
      "integrity": "sha512-IJdWBbTcMQ6DA0gdNhh/BwrLkDR+ADW5Kr1aZmd4k3DIF6ezMV4R2NIAmT08wQJ3yUK82thHWmC/TnK/wpMMIA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-utf8/-/util-utf8-2.3.0.tgz",
      "integrity": "sha512-R8Rdn8Hy72KKcebgLiv8jQcQkXoLMOGGv5uI1/k0l+snqkOzQ1R0ChUBCxWMlBsFMekWjq0wRudIweFs7sKT5A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/sha256-js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/sha256-js/-/sha256-js-5.2.0.tgz",
      "integrity": "sha512-FFQQyu7edu4ufvIZ+OadFpHHOt+eSTBaYaki44c+akjg7qZg9oOQeLlk77F6tSYqjDAFClrHJk9tMf0HdVyOvA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/util": "^5.2.0",
        "@aws-sdk/types": "^3.222.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/@aws-crypto/supports-web-crypto": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/supports-web-crypto/-/supports-web-crypto-5.2.0.tgz",
      "integrity": "sha512-iAvUotm021kM33eCdNfwIN//F77/IADDSs58i+MDaOqFrVjZo9bAal0NK7HurRuWLLpF1iLX7gbWrjHjeo+YFg==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-crypto/util": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/@aws-crypto/util/-/util-5.2.0.tgz",
      "integrity": "sha512-4RkU9EsI6ZpBve5fseQlGNUWKMa1RLPQ1dnjnQoe07ldfIzcsGb5hC5W0Dm7u423KWzawlrpbjXBrXCEv9zazQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "^3.222.0",
        "@smithy/util-utf8": "^2.0.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-crypto/util/node_modules/@smithy/is-array-buffer": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/is-array-buffer/-/is-array-buffer-2.2.0.tgz",
      "integrity": "sha512-GGP3O9QFD24uGeAXYUjwSTXARoqpZykHadOmA8G5vfJPK0/DC67qa//0qvqrJzL1xc8WQWX7/yc7fwudjPHPhA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/util/node_modules/@smithy/util-buffer-from": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-buffer-from/-/util-buffer-from-2.2.0.tgz",
      "integrity": "sha512-IJdWBbTcMQ6DA0gdNhh/BwrLkDR+ADW5Kr1aZmd4k3DIF6ezMV4R2NIAmT08wQJ3yUK82thHWmC/TnK/wpMMIA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-utf8/-/util-utf8-2.3.0.tgz",
      "integrity": "sha512-R8Rdn8Hy72KKcebgLiv8jQcQkXoLMOGGv5uI1/k0l+snqkOzQ1R0ChUBCxWMlBsFMekWjq0wRudIweFs7sKT5A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^2.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/@aws-sdk/client-sesv2": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/client-sesv2/-/client-sesv2-3.947.0.tgz",
      "integrity": "sha512-XttaaNh2rPf0PrGShFIGh56QyNstKfQ9ozAfE+TGsYsMNok3yxbdZnFub8PrI1boYceJolhK2m6VBk3J5nDkAg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/credential-provider-node": "3.947.0",
        "@aws-sdk/middleware-host-header": "3.936.0",
        "@aws-sdk/middleware-logger": "3.936.0",
        "@aws-sdk/middleware-recursion-detection": "3.936.0",
        "@aws-sdk/middleware-user-agent": "3.947.0",
        "@aws-sdk/region-config-resolver": "3.936.0",
        "@aws-sdk/signature-v4-multi-region": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@aws-sdk/util-endpoints": "3.936.0",
        "@aws-sdk/util-user-agent-browser": "3.936.0",
        "@aws-sdk/util-user-agent-node": "3.947.0",
        "@smithy/config-resolver": "^4.4.3",
        "@smithy/core": "^3.18.7",
        "@smithy/fetch-http-handler": "^5.3.6",
        "@smithy/hash-node": "^4.2.5",
        "@smithy/invalid-dependency": "^4.2.5",
        "@smithy/middleware-content-length": "^4.2.5",
        "@smithy/middleware-endpoint": "^4.3.14",
        "@smithy/middleware-retry": "^4.4.14",
        "@smithy/middleware-serde": "^4.2.6",
        "@smithy/middleware-stack": "^4.2.5",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/node-http-handler": "^4.4.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "@smithy/url-parser": "^4.2.5",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-body-length-browser": "^4.2.0",
        "@smithy/util-body-length-node": "^4.2.1",
        "@smithy/util-defaults-mode-browser": "^4.3.13",
        "@smithy/util-defaults-mode-node": "^4.2.16",
        "@smithy/util-endpoints": "^3.2.5",
        "@smithy/util-middleware": "^4.2.5",
        "@smithy/util-retry": "^4.2.5",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/client-sso": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/client-sso/-/client-sso-3.947.0.tgz",
      "integrity": "sha512-sDwcO8SP290WSErY1S8pz8hTafeghKmmWjNVks86jDK30wx62CfazOTeU70IpWgrUBEygyXk/zPogHsUMbW2Rg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/middleware-host-header": "3.936.0",
        "@aws-sdk/middleware-logger": "3.936.0",
        "@aws-sdk/middleware-recursion-detection": "3.936.0",
        "@aws-sdk/middleware-user-agent": "3.947.0",
        "@aws-sdk/region-config-resolver": "3.936.0",
        "@aws-sdk/types": "3.936.0",
        "@aws-sdk/util-endpoints": "3.936.0",
        "@aws-sdk/util-user-agent-browser": "3.936.0",
        "@aws-sdk/util-user-agent-node": "3.947.0",
        "@smithy/config-resolver": "^4.4.3",
        "@smithy/core": "^3.18.7",
        "@smithy/fetch-http-handler": "^5.3.6",
        "@smithy/hash-node": "^4.2.5",
        "@smithy/invalid-dependency": "^4.2.5",
        "@smithy/middleware-content-length": "^4.2.5",
        "@smithy/middleware-endpoint": "^4.3.14",
        "@smithy/middleware-retry": "^4.4.14",
        "@smithy/middleware-serde": "^4.2.6",
        "@smithy/middleware-stack": "^4.2.5",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/node-http-handler": "^4.4.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "@smithy/url-parser": "^4.2.5",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-body-length-browser": "^4.2.0",
        "@smithy/util-body-length-node": "^4.2.1",
        "@smithy/util-defaults-mode-browser": "^4.3.13",
        "@smithy/util-defaults-mode-node": "^4.2.16",
        "@smithy/util-endpoints": "^3.2.5",
        "@smithy/util-middleware": "^4.2.5",
        "@smithy/util-retry": "^4.2.5",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/core": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/core/-/core-3.947.0.tgz",
      "integrity": "sha512-Khq4zHhuAkvCFuFbgcy3GrZTzfSX7ZIjIcW1zRDxXRLZKRtuhnZdonqTUfaWi5K42/4OmxkYNpsO7X7trQOeHw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.936.0",
        "@aws-sdk/xml-builder": "3.930.0",
        "@smithy/core": "^3.18.7",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/signature-v4": "^5.3.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-middleware": "^4.2.5",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-env": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-env/-/credential-provider-env-3.947.0.tgz",
      "integrity": "sha512-VR2V6dRELmzwAsCpK4GqxUi6UW5WNhAXS9F9AzWi5jvijwJo3nH92YNJUP4quMpgFZxJHEWyXLWgPjh9u0zYOA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-http": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-http/-/credential-provider-http-3.947.0.tgz",
      "integrity": "sha512-inF09lh9SlHj63Vmr5d+LmwPXZc2IbK8lAruhOr3KLsZAIHEgHgGPXWDC2ukTEMzg0pkexQ6FOhXXad6klK4RA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/fetch-http-handler": "^5.3.6",
        "@smithy/node-http-handler": "^4.4.5",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "@smithy/util-stream": "^4.5.6",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-ini": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-ini/-/credential-provider-ini-3.947.0.tgz",
      "integrity": "sha512-A2ZUgJUJZERjSzvCi2NR/hBVbVkTXPD0SdKcR/aITb30XwF+n3T963b+pJl90qhOspoy7h0IVYNR7u5Nr9tJdQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/credential-provider-env": "3.947.0",
        "@aws-sdk/credential-provider-http": "3.947.0",
        "@aws-sdk/credential-provider-login": "3.947.0",
        "@aws-sdk/credential-provider-process": "3.947.0",
        "@aws-sdk/credential-provider-sso": "3.947.0",
        "@aws-sdk/credential-provider-web-identity": "3.947.0",
        "@aws-sdk/nested-clients": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/credential-provider-imds": "^4.2.5",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-login": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-login/-/credential-provider-login-3.947.0.tgz",
      "integrity": "sha512-u7M3hazcB7aJiVwosNdJRbIJDzbwQ861NTtl6S0HmvWpixaVb7iyhJZWg8/plyUznboZGBm7JVEdxtxv3u0bTA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/nested-clients": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-node": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-node/-/credential-provider-node-3.947.0.tgz",
      "integrity": "sha512-S0Zqebr71KyrT6J4uYPhwV65g4V5uDPHnd7dt2W34FcyPu+hVC7Hx4MFmsPyVLeT5cMCkkZvmY3kAoEzgUPJJg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/credential-provider-env": "3.947.0",
        "@aws-sdk/credential-provider-http": "3.947.0",
        "@aws-sdk/credential-provider-ini": "3.947.0",
        "@aws-sdk/credential-provider-process": "3.947.0",
        "@aws-sdk/credential-provider-sso": "3.947.0",
        "@aws-sdk/credential-provider-web-identity": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/credential-provider-imds": "^4.2.5",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-process": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-process/-/credential-provider-process-3.947.0.tgz",
      "integrity": "sha512-WpanFbHe08SP1hAJNeDdBDVz9SGgMu/gc0XJ9u3uNpW99nKZjDpvPRAdW7WLA4K6essMjxWkguIGNOpij6Do2Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-sso": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-sso/-/credential-provider-sso-3.947.0.tgz",
      "integrity": "sha512-NktnVHTGaUMaozxycYrepvb3yfFquHTQ53lt6hBEVjYBzK3C4tVz0siUpr+5RMGLSiZ5bLBp2UjJPgwx4i4waQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/client-sso": "3.947.0",
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/token-providers": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/credential-provider-web-identity": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/credential-provider-web-identity/-/credential-provider-web-identity-3.947.0.tgz",
      "integrity": "sha512-gokm/e/YHiHLrZgLq4j8tNAn8RJDPbIcglFRKgy08q8DmAqHQ8MXAKW3eS0QjAuRXU9mcMmUo1NrX6FRNBCCPw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/nested-clients": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-host-header": {
      "version": "3.936.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-host-header/-/middleware-host-header-3.936.0.tgz",
      "integrity": "sha512-tAaObaAnsP1XnLGndfkGWFuzrJYuk9W0b/nLvol66t8FZExIAf/WdkT2NNAWOYxljVs++oHnyHBCxIlaHrzSiw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.936.0",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-logger": {
      "version": "3.936.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-logger/-/middleware-logger-3.936.0.tgz",
      "integrity": "sha512-aPSJ12d3a3Ea5nyEnLbijCaaYJT2QjQ9iW+zGh5QcZYXmOGWbKVyPSxmVOboZQG+c1M8t6d2O7tqrwzIq8L8qw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.936.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-recursion-detection": {
      "version": "3.936.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-recursion-detection/-/middleware-recursion-detection-3.936.0.tgz",
      "integrity": "sha512-l4aGbHpXM45YNgXggIux1HgsCVAvvBoqHPkqLnqMl9QVapfuSTjJHfDYDsx1Xxct6/m7qSMUzanBALhiaGO2fA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.936.0",
        "@aws/lambda-invoke-store": "^0.2.0",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-sdk-s3": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-sdk-s3/-/middleware-sdk-s3-3.947.0.tgz",
      "integrity": "sha512-DS2tm5YBKhPW2PthrRBDr6eufChbwXe0NjtTZcYDfUCXf0OR+W6cIqyKguwHMJ+IyYdey30AfVw9/Lb5KB8U8A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@aws-sdk/util-arn-parser": "3.893.0",
        "@smithy/core": "^3.18.7",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/signature-v4": "^5.3.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "@smithy/util-config-provider": "^4.2.0",
        "@smithy/util-middleware": "^4.2.5",
        "@smithy/util-stream": "^4.5.6",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/middleware-user-agent": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/middleware-user-agent/-/middleware-user-agent-3.947.0.tgz",
      "integrity": "sha512-7rpKV8YNgCP2R4F9RjWZFcD2R+SO/0R4VHIbY9iZJdH2MzzJ8ZG7h8dZ2m8QkQd1fjx4wrFJGGPJUTYXPV3baA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@aws-sdk/util-endpoints": "3.936.0",
        "@smithy/core": "^3.18.7",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/nested-clients": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/nested-clients/-/nested-clients-3.947.0.tgz",
      "integrity": "sha512-DjRJEYNnHUTu9kGPPQDTSXquwSEd6myKR4ssI4FaYLFhdT3ldWpj73yYt807H3tdmhS7vPmdVqchSJnjurUQAw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/middleware-host-header": "3.936.0",
        "@aws-sdk/middleware-logger": "3.936.0",
        "@aws-sdk/middleware-recursion-detection": "3.936.0",
        "@aws-sdk/middleware-user-agent": "3.947.0",
        "@aws-sdk/region-config-resolver": "3.936.0",
        "@aws-sdk/types": "3.936.0",
        "@aws-sdk/util-endpoints": "3.936.0",
        "@aws-sdk/util-user-agent-browser": "3.936.0",
        "@aws-sdk/util-user-agent-node": "3.947.0",
        "@smithy/config-resolver": "^4.4.3",
        "@smithy/core": "^3.18.7",
        "@smithy/fetch-http-handler": "^5.3.6",
        "@smithy/hash-node": "^4.2.5",
        "@smithy/invalid-dependency": "^4.2.5",
        "@smithy/middleware-content-length": "^4.2.5",
        "@smithy/middleware-endpoint": "^4.3.14",
        "@smithy/middleware-retry": "^4.4.14",
        "@smithy/middleware-serde": "^4.2.6",
        "@smithy/middleware-stack": "^4.2.5",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/node-http-handler": "^4.4.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "@smithy/url-parser": "^4.2.5",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-body-length-browser": "^4.2.0",
        "@smithy/util-body-length-node": "^4.2.1",
        "@smithy/util-defaults-mode-browser": "^4.3.13",
        "@smithy/util-defaults-mode-node": "^4.2.16",
        "@smithy/util-endpoints": "^3.2.5",
        "@smithy/util-middleware": "^4.2.5",
        "@smithy/util-retry": "^4.2.5",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/region-config-resolver": {
      "version": "3.936.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/region-config-resolver/-/region-config-resolver-3.936.0.tgz",
      "integrity": "sha512-wOKhzzWsshXGduxO4pqSiNyL9oUtk4BEvjWm9aaq6Hmfdoydq6v6t0rAGHWPjFwy9z2haovGRi3C8IxdMB4muw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.936.0",
        "@smithy/config-resolver": "^4.4.3",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/signature-v4-multi-region": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/signature-v4-multi-region/-/signature-v4-multi-region-3.947.0.tgz",
      "integrity": "sha512-UaYmzoxf9q3mabIA2hc4T6x5YSFUG2BpNjAZ207EA1bnQMiK+d6vZvb83t7dIWL/U1de1sGV19c1C81Jf14rrA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/middleware-sdk-s3": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/signature-v4": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/token-providers": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/token-providers/-/token-providers-3.947.0.tgz",
      "integrity": "sha512-X/DyB8GuK44rsE89Tn5+s542B3PhGbXQSgV8lvqHDzvicwCt0tWny6790st6CPETrVVV2K3oJMfG5U3/jAmaZA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/core": "3.947.0",
        "@aws-sdk/nested-clients": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/types": {
      "version": "3.936.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/types/-/types-3.936.0.tgz",
      "integrity": "sha512-uz0/VlMd2pP5MepdrHizd+T+OKfyK4r3OA9JI+L/lPKg0YFQosdJNCKisr6o70E3dh8iMpFYxF1UN/4uZsyARg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/util-arn-parser": {
      "version": "3.893.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-arn-parser/-/util-arn-parser-3.893.0.tgz",
      "integrity": "sha512-u8H4f2Zsi19DGnwj5FSZzDMhytYF/bCh37vAtBsn3cNDL3YG578X5oc+wSX54pM3tOxS+NY7tvOAo52SW7koUA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/util-endpoints": {
      "version": "3.936.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-endpoints/-/util-endpoints-3.936.0.tgz",
      "integrity": "sha512-0Zx3Ntdpu+z9Wlm7JKUBOzS9EunwKAb4KdGUQQxDqh5Lc3ta5uBoub+FgmVuzwnmBu9U1Os8UuwVTH0Lgu+P5w==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.936.0",
        "@smithy/types": "^4.9.0",
        "@smithy/url-parser": "^4.2.5",
        "@smithy/util-endpoints": "^3.2.5",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/util-locate-window": {
      "version": "3.893.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-locate-window/-/util-locate-window-3.893.0.tgz",
      "integrity": "sha512-T89pFfgat6c8nMmpI8eKjBcDcgJq36+m9oiXbcUzeU55MP9ZuGgBomGjGnHaEyF36jenW9gmg3NfZDm0AO2XPg==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/util-user-agent-browser": {
      "version": "3.936.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-user-agent-browser/-/util-user-agent-browser-3.936.0.tgz",
      "integrity": "sha512-eZ/XF6NxMtu+iCma58GRNRxSq4lHo6zHQLOZRIeL/ghqYJirqHdenMOwrzPettj60KWlv827RVebP9oNVrwZbw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/types": "3.936.0",
        "@smithy/types": "^4.9.0",
        "bowser": "^2.11.0",
        "tslib": "^2.6.2"
      }
    },
    "node_modules/@aws-sdk/util-user-agent-node": {
      "version": "3.947.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/util-user-agent-node/-/util-user-agent-node-3.947.0.tgz",
      "integrity": "sha512-+vhHoDrdbb+zerV4noQk1DHaUMNzWFWPpPYjVTwW2186k5BEJIecAMChYkghRrBVJ3KPWP1+JnZwOd72F3d4rQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@aws-sdk/middleware-user-agent": "3.947.0",
        "@aws-sdk/types": "3.936.0",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      },
      "peerDependencies": {
        "aws-crt": ">=1.0.0"
      },
      "peerDependenciesMeta": {
        "aws-crt": {
          "optional": true
        }
      }
    },
    "node_modules/@aws-sdk/xml-builder": {
      "version": "3.930.0",
      "resolved": "https://registry.npmjs.org/@aws-sdk/xml-builder/-/xml-builder-3.930.0.tgz",
      "integrity": "sha512-YIfkD17GocxdmlUVc3ia52QhcWuRIUJonbF8A2CYfcWNV3HzvAqpcPeC0bYUhkK+8e8YO1ARnLKZQE0TlwzorA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "fast-xml-parser": "5.2.5",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@aws-sdk/xml-builder/node_modules/fast-xml-parser": {
      "version": "5.2.5",
      "resolved": "https://registry.npmjs.org/fast-xml-parser/-/fast-xml-parser-5.2.5.tgz",
      "integrity": "sha512-pfX9uG9Ki0yekDHx2SiuRIyFdyAr1kMIMitPvb0YBo8SUfKvia7w7FIyd/l6av85pFYRhZscS75MwMnbvY+hcQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/NaturalIntelligence"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "strnum": "^2.1.0"
      },
      "bin": {
        "fxparser": "src/cli/cli.js"
      }
    },
    "node_modules/@aws/lambda-invoke-store": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/@aws/lambda-invoke-store/-/lambda-invoke-store-0.2.2.tgz",
      "integrity": "sha512-C0NBLsIqzDIae8HFw9YIrIBsbc0xTiOtt7fAukGPnqQ/+zZNaq+4jhuccltK0QuWHBnNm/a6kLIRA6GFiM10eg==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@azure/abort-controller": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/@azure/abort-controller/-/abort-controller-2.1.2.tgz",
      "integrity": "sha512-nBrLsEWm4J2u5LpAPjxADTlq3trDgVZZXHNKabeXZtpq3d3AbN/KGO82R87rdDz5/lYB024rtEf10/q0urNgsA==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@azure/core-auth": {
      "version": "1.10.1",
      "resolved": "https://registry.npmjs.org/@azure/core-auth/-/core-auth-1.10.1.tgz",
      "integrity": "sha512-ykRMW8PjVAn+RS6ww5cmK9U2CyH9p4Q88YJwvUslfuMmN98w/2rdGRLPqJYObapBCdzBVeDgYWdJnFPFb7qzpg==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.1.2",
        "@azure/core-util": "^1.13.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/core-client": {
      "version": "1.10.1",
      "resolved": "https://registry.npmjs.org/@azure/core-client/-/core-client-1.10.1.tgz",
      "integrity": "sha512-Nh5PhEOeY6PrnxNPsEHRr9eimxLwgLlpmguQaHKBinFYA/RU9+kOYVOQqOrTsCL+KSxrLLl1gD8Dk5BFW/7l/w==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.1.2",
        "@azure/core-auth": "^1.10.0",
        "@azure/core-rest-pipeline": "^1.22.0",
        "@azure/core-tracing": "^1.3.0",
        "@azure/core-util": "^1.13.0",
        "@azure/logger": "^1.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/core-http-compat": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/@azure/core-http-compat/-/core-http-compat-2.3.1.tgz",
      "integrity": "sha512-az9BkXND3/d5VgdRRQVkiJb2gOmDU8Qcq4GvjtBmDICNiQ9udFmDk4ZpSB5Qq1OmtDJGlQAfBaS4palFsazQ5g==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.1.2",
        "@azure/core-client": "^1.10.0",
        "@azure/core-rest-pipeline": "^1.22.0"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/core-lro": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/@azure/core-lro/-/core-lro-2.7.2.tgz",
      "integrity": "sha512-0YIpccoX8m/k00O7mDDMdJpbr6mf1yWo2dfmxt5A8XVZVVMz2SSKaEbMCeJRvgQ0IaSlqhjT47p4hVIRRy90xw==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.0.0",
        "@azure/core-util": "^1.2.0",
        "@azure/logger": "^1.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@azure/core-paging": {
      "version": "1.6.2",
      "resolved": "https://registry.npmjs.org/@azure/core-paging/-/core-paging-1.6.2.tgz",
      "integrity": "sha512-YKWi9YuCU04B55h25cnOYZHxXYtEvQEbKST5vqRga7hWY9ydd3FZHdeQF8pyh+acWZvppw13M/LMGx0LABUVMA==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@azure/core-rest-pipeline": {
      "version": "1.22.2",
      "resolved": "https://registry.npmjs.org/@azure/core-rest-pipeline/-/core-rest-pipeline-1.22.2.tgz",
      "integrity": "sha512-MzHym+wOi8CLUlKCQu12de0nwcq9k9Kuv43j4Wa++CsCpJwps2eeBQwD2Bu8snkxTtDKDx4GwjuR9E8yC8LNrg==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.1.2",
        "@azure/core-auth": "^1.10.0",
        "@azure/core-tracing": "^1.3.0",
        "@azure/core-util": "^1.13.0",
        "@azure/logger": "^1.3.0",
        "@typespec/ts-http-runtime": "^0.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/core-tracing": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/@azure/core-tracing/-/core-tracing-1.3.1.tgz",
      "integrity": "sha512-9MWKevR7Hz8kNzzPLfX4EAtGM2b8mr50HPDBvio96bURP/9C+HjdH3sBlLSNNrvRAr5/k/svoH457gB5IKpmwQ==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/core-util": {
      "version": "1.13.1",
      "resolved": "https://registry.npmjs.org/@azure/core-util/-/core-util-1.13.1.tgz",
      "integrity": "sha512-XPArKLzsvl0Hf0CaGyKHUyVgF7oDnhKoP85Xv6M4StF/1AhfORhZudHtOyf2s+FcbuQ9dPRAjB8J2KvRRMUK2A==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.1.2",
        "@typespec/ts-http-runtime": "^0.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/core-xml": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@azure/core-xml/-/core-xml-1.5.0.tgz",
      "integrity": "sha512-D/sdlJBMJfx7gqoj66PKVmhDDaU6TKA49ptcolxdas29X7AfvLTmfAGLjAcIMBK7UZ2o4lygHIqVckOlQU3xWw==",
      "license": "MIT",
      "dependencies": {
        "fast-xml-parser": "^5.0.7",
        "tslib": "^2.8.1"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/logger": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@azure/logger/-/logger-1.3.0.tgz",
      "integrity": "sha512-fCqPIfOcLE+CGqGPd66c8bZpwAji98tZ4JI9i/mlTNTlsIWslCfpg48s/ypyLxZTump5sypjrKn2/kY7q8oAbA==",
      "license": "MIT",
      "dependencies": {
        "@typespec/ts-http-runtime": "^0.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/storage-blob": {
      "version": "12.29.1",
      "resolved": "https://registry.npmjs.org/@azure/storage-blob/-/storage-blob-12.29.1.tgz",
      "integrity": "sha512-7ktyY0rfTM0vo7HvtK6E3UvYnI9qfd6Oz6z/+92VhGRveWng3kJwMKeUpqmW/NmwcDNbxHpSlldG+vsUnRFnBg==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.1.2",
        "@azure/core-auth": "^1.9.0",
        "@azure/core-client": "^1.9.3",
        "@azure/core-http-compat": "^2.2.0",
        "@azure/core-lro": "^2.2.0",
        "@azure/core-paging": "^1.6.2",
        "@azure/core-rest-pipeline": "^1.19.1",
        "@azure/core-tracing": "^1.2.0",
        "@azure/core-util": "^1.11.0",
        "@azure/core-xml": "^1.4.5",
        "@azure/logger": "^1.1.4",
        "@azure/storage-common": "^12.1.1",
        "events": "^3.0.0",
        "tslib": "^2.8.1"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/storage-common": {
      "version": "12.1.1",
      "resolved": "https://registry.npmjs.org/@azure/storage-common/-/storage-common-12.1.1.tgz",
      "integrity": "sha512-eIOH1pqFwI6UmVNnDQvmFeSg0XppuzDLFeUNO/Xht7ODAzRLgGDh7h550pSxoA+lPDxBl1+D2m/KG3jWzCUjTg==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.1.2",
        "@azure/core-auth": "^1.9.0",
        "@azure/core-http-compat": "^2.2.0",
        "@azure/core-rest-pipeline": "^1.19.1",
        "@azure/core-tracing": "^1.2.0",
        "@azure/core-util": "^1.11.0",
        "@azure/logger": "^1.1.4",
        "events": "^3.3.0",
        "tslib": "^2.8.1"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@azure/storage-queue": {
      "version": "12.28.1",
      "resolved": "https://registry.npmjs.org/@azure/storage-queue/-/storage-queue-12.28.1.tgz",
      "integrity": "sha512-mAw7a8Asi2tcqzUAWHKrUHQHkD1rZj0kTt3DC+2ZgnDoZj2gPp3yGjaeNiONiSdDOdIhnEK4/IlAolinrMxs7A==",
      "license": "MIT",
      "dependencies": {
        "@azure/abort-controller": "^2.1.2",
        "@azure/core-auth": "^1.9.0",
        "@azure/core-client": "^1.9.3",
        "@azure/core-http-compat": "^2.0.0",
        "@azure/core-paging": "^1.6.2",
        "@azure/core-rest-pipeline": "^1.19.1",
        "@azure/core-tracing": "^1.2.0",
        "@azure/core-util": "^1.11.0",
        "@azure/core-xml": "^1.4.3",
        "@azure/logger": "^1.1.4",
        "@azure/storage-common": "^12.1.1",
        "tslib": "^2.8.1"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@prisma/client": {
      "version": "6.19.0",
      "resolved": "https://registry.npmjs.org/@prisma/client/-/client-6.19.0.tgz",
      "integrity": "sha512-QXFT+N/bva/QI2qoXmjBzL7D6aliPffIwP+81AdTGq0FXDoLxLkWivGMawG8iM5B9BKfxLIXxfWWAF6wbuJU6g==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "prisma": "*",
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "prisma": {
          "optional": true
        },
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@prisma/config": {
      "version": "6.19.0",
      "resolved": "https://registry.npmjs.org/@prisma/config/-/config-6.19.0.tgz",
      "integrity": "sha512-zwCayme+NzI/WfrvFEtkFhhOaZb/hI+X8TTjzjJ252VbPxAl2hWHK5NMczmnG9sXck2lsXrxIZuK524E25UNmg==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "c12": "3.1.0",
        "deepmerge-ts": "7.1.5",
        "effect": "3.18.4",
        "empathic": "2.0.0"
      }
    },
    "node_modules/@prisma/debug": {
      "version": "6.19.0",
      "resolved": "https://registry.npmjs.org/@prisma/debug/-/debug-6.19.0.tgz",
      "integrity": "sha512-8hAdGG7JmxrzFcTzXZajlQCidX0XNkMJkpqtfbLV54wC6LSSX6Vni25W/G+nAANwLnZ2TmwkfIuWetA7jJxJFA==",
      "devOptional": true,
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/engines": {
      "version": "6.19.0",
      "resolved": "https://registry.npmjs.org/@prisma/engines/-/engines-6.19.0.tgz",
      "integrity": "sha512-pMRJ+1S6NVdXoB8QJAPIGpKZevFjxhKt0paCkRDTZiczKb7F4yTgRP8M4JdVkpQwmaD4EoJf6qA+p61godDokw==",
      "devOptional": true,
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.19.0",
        "@prisma/engines-version": "6.19.0-26.2ba551f319ab1df4bc874a89965d8b3641056773",
        "@prisma/fetch-engine": "6.19.0",
        "@prisma/get-platform": "6.19.0"
      }
    },
    "node_modules/@prisma/engines-version": {
      "version": "6.19.0-26.2ba551f319ab1df4bc874a89965d8b3641056773",
      "resolved": "https://registry.npmjs.org/@prisma/engines-version/-/engines-version-6.19.0-26.2ba551f319ab1df4bc874a89965d8b3641056773.tgz",
      "integrity": "sha512-gV7uOBQfAFlWDvPJdQxMT1aSRur3a0EkU/6cfbAC5isV67tKDWUrPauyaHNpB+wN1ebM4A9jn/f4gH+3iHSYSQ==",
      "devOptional": true,
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/fetch-engine": {
      "version": "6.19.0",
      "resolved": "https://registry.npmjs.org/@prisma/fetch-engine/-/fetch-engine-6.19.0.tgz",
      "integrity": "sha512-OOx2Lda0DGrZ1rodADT06ZGqHzr7HY7LNMaFE2Vp8dp146uJld58sRuasdX0OiwpHgl8SqDTUKHNUyzEq7pDdQ==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.19.0",
        "@prisma/engines-version": "6.19.0-26.2ba551f319ab1df4bc874a89965d8b3641056773",
        "@prisma/get-platform": "6.19.0"
      }
    },
    "node_modules/@prisma/get-platform": {
      "version": "6.19.0",
      "resolved": "https://registry.npmjs.org/@prisma/get-platform/-/get-platform-6.19.0.tgz",
      "integrity": "sha512-ym85WDO2yDhC3fIXHWYpG3kVMBA49cL1XD2GCsCF8xbwoy2OkDQY44gEbAt2X46IQ4Apq9H6g0Ex1iFfPqEkHA==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.19.0"
      }
    },
    "node_modules/@redis/bloom": {
      "version": "5.10.0",
      "resolved": "https://registry.npmjs.org/@redis/bloom/-/bloom-5.10.0.tgz",
      "integrity": "sha512-doIF37ob+l47n0rkpRNgU8n4iacBlKM9xLiP1LtTZTvz8TloJB8qx/MgvhMhKdYG+CvCY2aPBnN2706izFn/4A==",
      "license": "MIT",
      "engines": {
        "node": ">= 18"
      },
      "peerDependencies": {
        "@redis/client": "^5.10.0"
      }
    },
    "node_modules/@redis/client": {
      "version": "5.10.0",
      "resolved": "https://registry.npmjs.org/@redis/client/-/client-5.10.0.tgz",
      "integrity": "sha512-JXmM4XCoso6C75Mr3lhKA3eNxSzkYi3nCzxDIKY+YOszYsJjuKbFgVtguVPbLMOttN4iu2fXoc2BGhdnYhIOxA==",
      "license": "MIT",
      "dependencies": {
        "cluster-key-slot": "1.1.2"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/@redis/json": {
      "version": "5.10.0",
      "resolved": "https://registry.npmjs.org/@redis/json/-/json-5.10.0.tgz",
      "integrity": "sha512-B2G8XlOmTPUuZtD44EMGbtoepQG34RCDXLZbjrtON1Djet0t5Ri7/YPXvL9aomXqP8lLTreaprtyLKF4tmXEEA==",
      "license": "MIT",
      "engines": {
        "node": ">= 18"
      },
      "peerDependencies": {
        "@redis/client": "^5.10.0"
      }
    },
    "node_modules/@redis/search": {
      "version": "5.10.0",
      "resolved": "https://registry.npmjs.org/@redis/search/-/search-5.10.0.tgz",
      "integrity": "sha512-3SVcPswoSfp2HnmWbAGUzlbUPn7fOohVu2weUQ0S+EMiQi8jwjL+aN2p6V3TI65eNfVsJ8vyPvqWklm6H6esmg==",
      "license": "MIT",
      "engines": {
        "node": ">= 18"
      },
      "peerDependencies": {
        "@redis/client": "^5.10.0"
      }
    },
    "node_modules/@redis/time-series": {
      "version": "5.10.0",
      "resolved": "https://registry.npmjs.org/@redis/time-series/-/time-series-5.10.0.tgz",
      "integrity": "sha512-cPkpddXH5kc/SdRhF0YG0qtjL+noqFT0AcHbQ6axhsPsO7iqPi1cjxgdkE9TNeKiBUUdCaU1DbqkR/LzbzPBhg==",
      "license": "MIT",
      "engines": {
        "node": ">= 18"
      },
      "peerDependencies": {
        "@redis/client": "^5.10.0"
      }
    },
    "node_modules/@smithy/abort-controller": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/abort-controller/-/abort-controller-4.2.5.tgz",
      "integrity": "sha512-j7HwVkBw68YW8UmFRcjZOmssE77Rvk0GWAIN1oFBhsaovQmZWYCIcGa9/pwRB0ExI8Sk9MWNALTjftjHZea7VA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/config-resolver": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/@smithy/config-resolver/-/config-resolver-4.4.3.tgz",
      "integrity": "sha512-ezHLe1tKLUxDJo2LHtDuEDyWXolw8WGOR92qb4bQdWq/zKenO5BvctZGrVJBK08zjezSk7bmbKFOXIVyChvDLw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/types": "^4.9.0",
        "@smithy/util-config-provider": "^4.2.0",
        "@smithy/util-endpoints": "^3.2.5",
        "@smithy/util-middleware": "^4.2.5",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/core": {
      "version": "3.18.7",
      "resolved": "https://registry.npmjs.org/@smithy/core/-/core-3.18.7.tgz",
      "integrity": "sha512-axG9MvKhMWOhFbvf5y2DuyTxQueO0dkedY9QC3mAfndLosRI/9LJv8WaL0mw7ubNhsO4IuXX9/9dYGPFvHrqlw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/middleware-serde": "^4.2.6",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-body-length-browser": "^4.2.0",
        "@smithy/util-middleware": "^4.2.5",
        "@smithy/util-stream": "^4.5.6",
        "@smithy/util-utf8": "^4.2.0",
        "@smithy/uuid": "^1.1.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/credential-provider-imds": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/credential-provider-imds/-/credential-provider-imds-4.2.5.tgz",
      "integrity": "sha512-BZwotjoZWn9+36nimwm/OLIcVe+KYRwzMjfhd4QT7QxPm9WY0HiOV8t/Wlh+HVUif0SBVV7ksq8//hPaBC/okQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/types": "^4.9.0",
        "@smithy/url-parser": "^4.2.5",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/fetch-http-handler": {
      "version": "5.3.6",
      "resolved": "https://registry.npmjs.org/@smithy/fetch-http-handler/-/fetch-http-handler-5.3.6.tgz",
      "integrity": "sha512-3+RG3EA6BBJ/ofZUeTFJA7mHfSYrZtQIrDP9dI8Lf7X6Jbos2jptuLrAAteDiFVrmbEmLSuRG/bUKzfAXk7dhg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/querystring-builder": "^4.2.5",
        "@smithy/types": "^4.9.0",
        "@smithy/util-base64": "^4.3.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/hash-node": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/hash-node/-/hash-node-4.2.5.tgz",
      "integrity": "sha512-DpYX914YOfA3UDT9CN1BM787PcHfWRBB43fFGCYrZFUH0Jv+5t8yYl+Pd5PW4+QzoGEDvn5d5QIO4j2HyYZQSA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "@smithy/util-buffer-from": "^4.2.0",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/invalid-dependency": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/invalid-dependency/-/invalid-dependency-4.2.5.tgz",
      "integrity": "sha512-2L2erASEro1WC5nV+plwIMxrTXpvpfzl4e+Nre6vBVRR2HKeGGcvpJyyL3/PpiSg+cJG2KpTmZmq934Olb6e5A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/is-array-buffer": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/is-array-buffer/-/is-array-buffer-4.2.0.tgz",
      "integrity": "sha512-DZZZBvC7sjcYh4MazJSGiWMI2L7E0oCiRHREDzIxi/M2LY79/21iXt6aPLHge82wi5LsuRF5A06Ds3+0mlh6CQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/middleware-content-length": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-content-length/-/middleware-content-length-4.2.5.tgz",
      "integrity": "sha512-Y/RabVa5vbl5FuHYV2vUCwvh/dqzrEY/K2yWPSqvhFUwIY0atLqO4TienjBXakoy4zrKAMCZwg+YEqmH7jaN7A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/middleware-endpoint": {
      "version": "4.3.14",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-endpoint/-/middleware-endpoint-4.3.14.tgz",
      "integrity": "sha512-v0q4uTKgBM8dsqGjqsabZQyH85nFaTnFcgpWU1uydKFsdyyMzfvOkNum9G7VK+dOP01vUnoZxIeRiJ6uD0kjIg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/core": "^3.18.7",
        "@smithy/middleware-serde": "^4.2.6",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "@smithy/url-parser": "^4.2.5",
        "@smithy/util-middleware": "^4.2.5",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/middleware-retry": {
      "version": "4.4.14",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-retry/-/middleware-retry-4.4.14.tgz",
      "integrity": "sha512-Z2DG8Ej7FyWG1UA+7HceINtSLzswUgs2np3sZX0YBBxCt+CXG4QUxv88ZDS3+2/1ldW7LqtSY1UO/6VQ1pND8Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/service-error-classification": "^4.2.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "@smithy/util-middleware": "^4.2.5",
        "@smithy/util-retry": "^4.2.5",
        "@smithy/uuid": "^1.1.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/middleware-serde": {
      "version": "4.2.6",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-serde/-/middleware-serde-4.2.6.tgz",
      "integrity": "sha512-VkLoE/z7e2g8pirwisLz8XJWedUSY8my/qrp81VmAdyrhi94T+riBfwP+AOEEFR9rFTSonC/5D2eWNmFabHyGQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/middleware-stack": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/middleware-stack/-/middleware-stack-4.2.5.tgz",
      "integrity": "sha512-bYrutc+neOyWxtZdbB2USbQttZN0mXaOyYLIsaTbJhFsfpXyGWUxJpEuO1rJ8IIJm2qH4+xJT0mxUSsEDTYwdQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/node-config-provider": {
      "version": "4.3.5",
      "resolved": "https://registry.npmjs.org/@smithy/node-config-provider/-/node-config-provider-4.3.5.tgz",
      "integrity": "sha512-UTurh1C4qkVCtqggI36DGbLB2Kv8UlcFdMXDcWMbqVY2uRg0XmT9Pb4Vj6oSQ34eizO1fvR0RnFV4Axw4IrrAg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/property-provider": "^4.2.5",
        "@smithy/shared-ini-file-loader": "^4.4.0",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/node-http-handler": {
      "version": "4.4.5",
      "resolved": "https://registry.npmjs.org/@smithy/node-http-handler/-/node-http-handler-4.4.5.tgz",
      "integrity": "sha512-CMnzM9R2WqlqXQGtIlsHMEZfXKJVTIrqCNoSd/QpAyp+Dw0a1Vps13l6ma1fH8g7zSPNsA59B/kWgeylFuA/lw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/abort-controller": "^4.2.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/querystring-builder": "^4.2.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/property-provider": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/property-provider/-/property-provider-4.2.5.tgz",
      "integrity": "sha512-8iLN1XSE1rl4MuxvQ+5OSk/Zb5El7NJZ1td6Tn+8dQQHIjp59Lwl6bd0+nzw6SKm2wSSriH2v/I9LPzUic7EOg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/protocol-http": {
      "version": "5.3.5",
      "resolved": "https://registry.npmjs.org/@smithy/protocol-http/-/protocol-http-5.3.5.tgz",
      "integrity": "sha512-RlaL+sA0LNMp03bf7XPbFmT5gN+w3besXSWMkA8rcmxLSVfiEXElQi4O2IWwPfxzcHkxqrwBFMbngB8yx/RvaQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/querystring-builder": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/querystring-builder/-/querystring-builder-4.2.5.tgz",
      "integrity": "sha512-y98otMI1saoajeik2kLfGyRp11e5U/iJYH/wLCh3aTV/XutbGT9nziKGkgCaMD1ghK7p6htHMm6b6scl9JRUWg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "@smithy/util-uri-escape": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/querystring-parser": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/querystring-parser/-/querystring-parser-4.2.5.tgz",
      "integrity": "sha512-031WCTdPYgiQRYNPXznHXof2YM0GwL6SeaSyTH/P72M1Vz73TvCNH2Nq8Iu2IEPq9QP2yx0/nrw5YmSeAi/AjQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/service-error-classification": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/service-error-classification/-/service-error-classification-4.2.5.tgz",
      "integrity": "sha512-8fEvK+WPE3wUAcDvqDQG1Vk3ANLR8Px979te96m84CbKAjBVf25rPYSzb4xU4hlTyho7VhOGnh5i62D/JVF0JQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/shared-ini-file-loader": {
      "version": "4.4.0",
      "resolved": "https://registry.npmjs.org/@smithy/shared-ini-file-loader/-/shared-ini-file-loader-4.4.0.tgz",
      "integrity": "sha512-5WmZ5+kJgJDjwXXIzr1vDTG+RhF9wzSODQBfkrQ2VVkYALKGvZX1lgVSxEkgicSAFnFhPj5rudJV0zoinqS0bA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/signature-v4": {
      "version": "5.3.5",
      "resolved": "https://registry.npmjs.org/@smithy/signature-v4/-/signature-v4-5.3.5.tgz",
      "integrity": "sha512-xSUfMu1FT7ccfSXkoLl/QRQBi2rOvi3tiBZU2Tdy3I6cgvZ6SEi9QNey+lqps/sJRnogIS+lq+B1gxxbra2a/w==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^4.2.0",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "@smithy/util-hex-encoding": "^4.2.0",
        "@smithy/util-middleware": "^4.2.5",
        "@smithy/util-uri-escape": "^4.2.0",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/smithy-client": {
      "version": "4.9.10",
      "resolved": "https://registry.npmjs.org/@smithy/smithy-client/-/smithy-client-4.9.10.tgz",
      "integrity": "sha512-Jaoz4Jw1QYHc1EFww/E6gVtNjhoDU+gwRKqXP6C3LKYqqH2UQhP8tMP3+t/ePrhaze7fhLE8vS2q6vVxBANFTQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/core": "^3.18.7",
        "@smithy/middleware-endpoint": "^4.3.14",
        "@smithy/middleware-stack": "^4.2.5",
        "@smithy/protocol-http": "^5.3.5",
        "@smithy/types": "^4.9.0",
        "@smithy/util-stream": "^4.5.6",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/types": {
      "version": "4.9.0",
      "resolved": "https://registry.npmjs.org/@smithy/types/-/types-4.9.0.tgz",
      "integrity": "sha512-MvUbdnXDTwykR8cB1WZvNNwqoWVaTRA0RLlLmf/cIFNMM2cKWz01X4Ly6SMC4Kks30r8tT3Cty0jmeWfiuyHTA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/url-parser": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/url-parser/-/url-parser-4.2.5.tgz",
      "integrity": "sha512-VaxMGsilqFnK1CeBX+LXnSuaMx4sTL/6znSZh2829txWieazdVxr54HmiyTsIbpOTLcf5nYpq9lpzmwRdxj6rQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/querystring-parser": "^4.2.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-base64": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-base64/-/util-base64-4.3.0.tgz",
      "integrity": "sha512-GkXZ59JfyxsIwNTWFnjmFEI8kZpRNIBfxKjv09+nkAWPt/4aGaEWMM04m4sxgNVWkbt2MdSvE3KF/PfX4nFedQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^4.2.0",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-body-length-browser": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-body-length-browser/-/util-body-length-browser-4.2.0.tgz",
      "integrity": "sha512-Fkoh/I76szMKJnBXWPdFkQJl2r9SjPt3cMzLdOB6eJ4Pnpas8hVoWPYemX/peO0yrrvldgCUVJqOAjUrOLjbxg==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-body-length-node": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/@smithy/util-body-length-node/-/util-body-length-node-4.2.1.tgz",
      "integrity": "sha512-h53dz/pISVrVrfxV1iqXlx5pRg3V2YWFcSQyPyXZRrZoZj4R4DeWRDo1a7dd3CPTcFi3kE+98tuNyD2axyZReA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-buffer-from": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-buffer-from/-/util-buffer-from-4.2.0.tgz",
      "integrity": "sha512-kAY9hTKulTNevM2nlRtxAG2FQ3B2OR6QIrPY3zE5LqJy1oxzmgBGsHLWTcNhWXKchgA0WHW+mZkQrng/pgcCew==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/is-array-buffer": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-config-provider": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-config-provider/-/util-config-provider-4.2.0.tgz",
      "integrity": "sha512-YEjpl6XJ36FTKmD+kRJJWYvrHeUvm5ykaUS5xK+6oXffQPHeEM4/nXlZPe+Wu0lsgRUcNZiliYNh/y7q9c2y6Q==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-defaults-mode-browser": {
      "version": "4.3.13",
      "resolved": "https://registry.npmjs.org/@smithy/util-defaults-mode-browser/-/util-defaults-mode-browser-4.3.13.tgz",
      "integrity": "sha512-hlVLdAGrVfyNei+pKIgqDTxfu/ZI2NSyqj4IDxKd5bIsIqwR/dSlkxlPaYxFiIaDVrBy0he8orsFy+Cz119XvA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/property-provider": "^4.2.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-defaults-mode-node": {
      "version": "4.2.16",
      "resolved": "https://registry.npmjs.org/@smithy/util-defaults-mode-node/-/util-defaults-mode-node-4.2.16.tgz",
      "integrity": "sha512-F1t22IUiJLHrxW9W1CQ6B9PN+skZ9cqSuzB18Eh06HrJPbjsyZ7ZHecAKw80DQtyGTRcVfeukKaCRYebFwclbg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/config-resolver": "^4.4.3",
        "@smithy/credential-provider-imds": "^4.2.5",
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/property-provider": "^4.2.5",
        "@smithy/smithy-client": "^4.9.10",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-endpoints": {
      "version": "3.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/util-endpoints/-/util-endpoints-3.2.5.tgz",
      "integrity": "sha512-3O63AAWu2cSNQZp+ayl9I3NapW1p1rR5mlVHcF6hAB1dPZUQFfRPYtplWX/3xrzWthPGj5FqB12taJJCfH6s8A==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/node-config-provider": "^4.3.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-hex-encoding": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-hex-encoding/-/util-hex-encoding-4.2.0.tgz",
      "integrity": "sha512-CCQBwJIvXMLKxVbO88IukazJD9a4kQ9ZN7/UMGBjBcJYvatpWk+9g870El4cB8/EJxfe+k+y0GmR9CAzkF+Nbw==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-middleware": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/util-middleware/-/util-middleware-4.2.5.tgz",
      "integrity": "sha512-6Y3+rvBF7+PZOc40ybeZMcGln6xJGVeY60E7jy9Mv5iKpMJpHgRE6dKy9ScsVxvfAYuEX4Q9a65DQX90KaQ3bA==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-retry": {
      "version": "4.2.5",
      "resolved": "https://registry.npmjs.org/@smithy/util-retry/-/util-retry-4.2.5.tgz",
      "integrity": "sha512-GBj3+EZBbN4NAqJ/7pAhsXdfzdlznOh8PydUijy6FpNIMnHPSMO2/rP4HKu+UFeikJxShERk528oy7GT79YiJg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/service-error-classification": "^4.2.5",
        "@smithy/types": "^4.9.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-stream": {
      "version": "4.5.6",
      "resolved": "https://registry.npmjs.org/@smithy/util-stream/-/util-stream-4.5.6.tgz",
      "integrity": "sha512-qWw/UM59TiaFrPevefOZ8CNBKbYEP6wBAIlLqxn3VAIo9rgnTNc4ASbVrqDmhuwI87usnjhdQrxodzAGFFzbRQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/fetch-http-handler": "^5.3.6",
        "@smithy/node-http-handler": "^4.4.5",
        "@smithy/types": "^4.9.0",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-buffer-from": "^4.2.0",
        "@smithy/util-hex-encoding": "^4.2.0",
        "@smithy/util-utf8": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-uri-escape": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-uri-escape/-/util-uri-escape-4.2.0.tgz",
      "integrity": "sha512-igZpCKV9+E/Mzrpq6YacdTQ0qTiLm85gD6N/IrmyDvQFA4UnU3d5g3m8tMT/6zG/vVkWSU+VxeUyGonL62DuxA==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/util-utf8": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/@smithy/util-utf8/-/util-utf8-4.2.0.tgz",
      "integrity": "sha512-zBPfuzoI8xyBtR2P6WQj63Rz8i3AmfAaJLuNG8dWsfvPe8lO4aCPYLn879mEgHndZH1zQ2oXmG8O1GGzzaoZiw==",
      "license": "Apache-2.0",
      "dependencies": {
        "@smithy/util-buffer-from": "^4.2.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@smithy/uuid": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@smithy/uuid/-/uuid-1.1.0.tgz",
      "integrity": "sha512-4aUIteuyxtBUhVdiQqcDhKFitwfd9hqoSDYY2KRXiWtgoWJ9Bmise+KfEPDiVHWeJepvF8xJO9/9+WDIciMFFw==",
      "license": "Apache-2.0",
      "dependencies": {
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=18.0.0"
      }
    },
    "node_modules/@standard-schema/spec": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0.tgz",
      "integrity": "sha512-m2bOd0f2RT9k8QJx1JN85cZYyH1RqFBdlwtkSlf4tBDYLCiiZnv1fIIwacK6cqwXavOydf0NPToMQgpKq+dVlA==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/@streamparser/json": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/@streamparser/json/-/json-0.0.6.tgz",
      "integrity": "sha512-vL9EVn/v+OhZ+Wcs6O4iKE9EUpwHUqHmCtNUMWjqp+6dr85+XPOSGTEsqYNq1Vn04uk9SWlOVmx9J48ggJVT2Q==",
      "license": "MIT"
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.11.tgz",
      "integrity": "sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.4.tgz",
      "integrity": "sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@turf/along": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/along/-/along-7.3.1.tgz",
      "integrity": "sha512-z84b9PKsUB69BhkeHA6oPqRO7VaJHwTid1SpuIbwWzDqHTpq8buJBKlrKgHIIthuVr5P/AZiEXmf3R4ifRhDmw==",
      "license": "MIT",
      "dependencies": {
        "@turf/bearing": "7.3.1",
        "@turf/destination": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/angle": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/angle/-/angle-7.3.1.tgz",
      "integrity": "sha512-Pcb0Fg8WHsOMKFvIPaYfORrlLYdytWjVAkVTnAqJdmGI+2n+eLROPjJO2sJbpX9yU/dlBgujOB7a1d0PJjhHyQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/bearing": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/rhumb-bearing": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/area": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/area/-/area-7.3.1.tgz",
      "integrity": "sha512-9nSiwt4zB5QDMcSoTxF28WpK1f741MNKcpUJDiHVRX08CZ4qfGWGV9ZIPQ8TVEn5RE4LyYkFuQ47Z9pdEUZE9Q==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/bbox": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/bbox/-/bbox-7.3.1.tgz",
      "integrity": "sha512-/IyMKoS7P9B0ch5PIlQ6gMfoE8gRr48+cSbzlyexvEjuDuaAV1VURjH1jAthS0ipFG8RrFxFJKnp7TLL1Skong==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/bbox-clip": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/bbox-clip/-/bbox-clip-7.3.1.tgz",
      "integrity": "sha512-YUeITFtp5QLbpSS0XyQa0GlgMqK4PMgjOeOGOTlWsfDYaqc5SErf7o5UyCOsLAPQW16QZVxJ26uTAE20YkluAA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/bbox-polygon": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/bbox-polygon/-/bbox-polygon-7.3.1.tgz",
      "integrity": "sha512-2NvwPfuRtwJk7w5HIC/Knei3mUXrVT+t/0FB1zStgDbakmXrqKISaftlIh4YTOVlUsVnvq0tggjFMLZ/Xxo+lQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/bearing": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/bearing/-/bearing-7.3.1.tgz",
      "integrity": "sha512-ex78l/LiY6uO6jO8AJepyWE6/tiWEbXjKLOgqUfJSkW23UcMVlhbAKzXDjbsdz9T66sXFC/6QNAh8oaZzmoo6w==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/bezier-spline": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/bezier-spline/-/bezier-spline-7.3.1.tgz",
      "integrity": "sha512-7Mal/d8ttTQ5eu/mwgC53iH9eYBRTBHXsIqEEiTVHChh1iajNuS4/bwYdaxsQsRXKVaFfx+4dCy0cRmqhjgTrw==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-clockwise": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-clockwise/-/boolean-clockwise-7.3.1.tgz",
      "integrity": "sha512-ik9j0CCrsp/JZ42tbCnyZg86YFoavEU/nyal3HsEgdY5WFYq43aMYqLPRi6yNqE48THEk3fl1BcfgJqAiUhDFA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-concave": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-concave/-/boolean-concave-7.3.1.tgz",
      "integrity": "sha512-jAAt5MhqXSKmRmX7l09oeo9dObf7bMDuzfeUSSNAK+yAi9TE5QWlP4JtzOWC5+gKXsL8dvzE8mvsQj38FzQdEA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-contains": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-contains/-/boolean-contains-7.3.1.tgz",
      "integrity": "sha512-VvytV9ZcUgnitzm5ILVWIoOhoZOh8VZ4dnweUJM3N+A77CzXXFk8e4NqPNZ6tZVPY3ehxzDXrq1+iN87pMcB7g==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/boolean-point-on-line": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-crosses": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-crosses/-/boolean-crosses-7.3.1.tgz",
      "integrity": "sha512-Fn99AxTXQORiQjclUqUYQcA40oJJoJxMBFx/Vycd7v949Lnplt1qrUkBpbZNXQlvHF2gxrgirSfgBDaUnUJjzQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/line-intersect": "7.3.1",
        "@turf/polygon-to-line": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-disjoint": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-disjoint/-/boolean-disjoint-7.3.1.tgz",
      "integrity": "sha512-bqVo+eAYaCq0lcr09zsZdWIAdv22UzGc/h2CCfaBwP5r4o/rFudNFLU9gb9BcM6dBUzrtTgBguShAZr7k3cGbw==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/line-intersect": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/polygon-to-line": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-equal": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-equal/-/boolean-equal-7.3.1.tgz",
      "integrity": "sha512-nEsmmNdwD1nzYZLsO6hPC/X/Uag+eT0yuWamD0XxJAQhXBsnSATxKisCJXVJgXvO8M0qvEMW1zZrUGB6Fjfzzw==",
      "license": "MIT",
      "dependencies": {
        "@turf/clean-coords": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "geojson-equality-ts": "^1.0.2",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-intersects": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-intersects/-/boolean-intersects-7.3.1.tgz",
      "integrity": "sha512-nc6W8qFdzFkfsR6p506HINGu85nHk/Skm+cw3TRQZ5/A44hjf0kYnbhvS3qrCAws3bR+/FKK8O1bsO/Udk8kkg==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-disjoint": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-overlap": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-overlap/-/boolean-overlap-7.3.1.tgz",
      "integrity": "sha512-QhhsgCLzkwXIeZhaCmgE3H8yTANJGZatJ5IzQG3xnPTx7LiNAaa/ReN2/NroEv++8Yc0sr5Bkh6xWZOtew1dvQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/line-intersect": "7.3.1",
        "@turf/line-overlap": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "geojson-equality-ts": "^1.0.2",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-parallel": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-parallel/-/boolean-parallel-7.3.1.tgz",
      "integrity": "sha512-SXPyYiuaRB1ES/LtcUP11HWyloMJGzN1nYaCLG7H+6l2OKjVJl025qR6uxVElWCzAdElek9nGNeNya1hd9ZHaw==",
      "license": "MIT",
      "dependencies": {
        "@turf/clean-coords": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/line-segment": "7.3.1",
        "@turf/rhumb-bearing": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-point-in-polygon": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-point-in-polygon/-/boolean-point-in-polygon-7.3.1.tgz",
      "integrity": "sha512-BUPW63vE43LctwkgannjmEFTX1KFR/18SS7WzFahJWK1ZoP0s1jrfxGX+pi0BH/3Dd9mA71hkGKDDnj1Ndcz0g==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "point-in-polygon-hao": "^1.1.0",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-point-on-line": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-point-on-line/-/boolean-point-on-line-7.3.1.tgz",
      "integrity": "sha512-8Hywuv7XFpSc8nfH0BJBtt+XTcJ7OjfjpX2Sz+ty8gyiY/2nCLLqq6amu3ebr67ruqZTDpPNQoGGUbUePjF3rA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-touches": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-touches/-/boolean-touches-7.3.1.tgz",
      "integrity": "sha512-XqrQzYGTakoTWeTWT274pfObpbIpAM7L8CzGUa04rJD0l3bv3VK4TUw0v6+bywi5ea6TnJzvOzgvzTb1DtvBKA==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/boolean-point-on-line": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-valid": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-valid/-/boolean-valid-7.3.1.tgz",
      "integrity": "sha512-lpw4J5HaV4Tv033s2j/i6QHt6Zx/8Lc90DTfOU0axgRSrs127kbKNJsmDEGvtmV7YjNp8aPbIG1wwAX9wg/dMA==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/boolean-crosses": "7.3.1",
        "@turf/boolean-disjoint": "7.3.1",
        "@turf/boolean-overlap": "7.3.1",
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/boolean-point-on-line": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/line-intersect": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "geojson-polygon-self-intersections": "^1.2.1",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/boolean-within": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/boolean-within/-/boolean-within-7.3.1.tgz",
      "integrity": "sha512-oxP4VU81RRCf59TXCBhVWEyJ5Lsr+wrqvqSAFxyBuur5oLmBqZdYyvL7FQJmYvG0uOxX7ohyHmSJMaTe4EhGDA==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/boolean-point-on-line": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/buffer": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/buffer/-/buffer-7.3.1.tgz",
      "integrity": "sha512-jtdI0Ir3GwPyY1V2dFX039HNhD8MIYLX39c7b9AZdLh7kBuD2VgXJmPvhtnivqMV2SmRlS4fd9cKzNj369/cGg==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/center": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/jsts": "^2.7.1",
        "@turf/meta": "7.3.1",
        "@turf/projection": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "d3-geo": "1.7.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/center": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/center/-/center-7.3.1.tgz",
      "integrity": "sha512-czqNKLGGdik3phYsWCK5SHKBRkDulUArMlG4v62IQcNcRFq9MbOGqyN21GSshSMO792ynDeWzdXdcKmycQ14Yg==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/center-mean": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/center-mean/-/center-mean-7.3.1.tgz",
      "integrity": "sha512-koVenhCl8JPEvtDwH6nhZpLAm9+7XOXosqKdkXyK1uDae3NRyoQQeIYD7nIJHJPCOyeacw6buWzAEoAleBj0XA==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/center-median": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/center-median/-/center-median-7.3.1.tgz",
      "integrity": "sha512-XIvxqnSdcUFOev4WO8AEQth4U3uzfQkxYVkKhZrxpVitqEeSDm5v3ANUeVGYqQ/QNTWvFAFn4zB5+XRRd8tayA==",
      "license": "MIT",
      "dependencies": {
        "@turf/center-mean": "7.3.1",
        "@turf/centroid": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/center-of-mass": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/center-of-mass/-/center-of-mass-7.3.1.tgz",
      "integrity": "sha512-w2O7RLc0tSs+eEsZCaWa1lYiACsaQTJtie/a4bj5ta1TDTAEjyxC6Rp6br4mN1XPzeSFbEuNw+q9/VdSXU/mGA==",
      "license": "MIT",
      "dependencies": {
        "@turf/centroid": "7.3.1",
        "@turf/convex": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/centroid": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/centroid/-/centroid-7.3.1.tgz",
      "integrity": "sha512-hRnsDdVBH4pX9mAjYympb2q5W8TCMUMNEjcRrAF7HTCyjIuRmjJf8vUtlzf7TTn9RXbsvPc1vtm3kLw20Jm8DQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/circle": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/circle/-/circle-7.3.1.tgz",
      "integrity": "sha512-UY2OM1OK7IuyrtN3YE8026ZM3xM9VIkqZ0vRZln8g33D0AogrJVJ/I9T81/VpRPlxTnrbDpzQxJQBH+3vPG/Ow==",
      "license": "MIT",
      "dependencies": {
        "@turf/destination": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/clean-coords": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/clean-coords/-/clean-coords-7.3.1.tgz",
      "integrity": "sha512-uNo4lnTekvkw8dUCXIVCc38nZiHBrpy5jn0T8hlodZo/A4XAChFtLQi8NLcX8rtXcaNxeJo+yaPfpP3PSVI2jw==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-on-line": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/clone": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/clone/-/clone-7.3.1.tgz",
      "integrity": "sha512-r7xDOfw9ohA7PhZW+8X9RMsO4szB4YqkhEROaELJyLtQ1bo8VNFtndpZdE6YHQpD7Pjlvlb6i99q8w1QLisEPg==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/clusters": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/clusters/-/clusters-7.3.1.tgz",
      "integrity": "sha512-ZELehyYnsozw+AHOc426abmPaGJOt46BHnCN+hwtPOkqEbvdZYu+16Y+cjiFnY7FwbvzBjDMb9HRtKJFlAmupg==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/clusters-dbscan": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/clusters-dbscan/-/clusters-dbscan-7.3.1.tgz",
      "integrity": "sha512-rY1wbQlljRhX5e+XM/yw4dKs2HniN45v+Xf5Xde6nv23WyEf/LLjpyD5yrsLa1awfJjD/NmD6axGVebnBBn9YA==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "rbush": "^3.0.1",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/clusters-kmeans": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/clusters-kmeans/-/clusters-kmeans-7.3.1.tgz",
      "integrity": "sha512-HYvRninBY/b5ftkIkoVWjV/wHilNE56cdr6gTlrxuvm4EClilsLDSVYjeiMYU0pjI3xDTc7PlicQDGdnIavUqQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "skmeans": "0.9.7",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/collect": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/collect/-/collect-7.3.1.tgz",
      "integrity": "sha512-yVDz5YLcRGFipttb60Y4IAd7zWfbQk6mNW5Kt6/wa8+YueHFzsKJdtbErWfozCVuiKplQZWT5r+9J9g6RnhpjQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "rbush": "^3.0.1",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/combine": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/combine/-/combine-7.3.1.tgz",
      "integrity": "sha512-iZBe36sKRq08fY3Ars0JpfYJm8N3LtLLnNzdTxHp8Ry2ORJGHvZHpcv3lQXWL7gyJwDPAye7pyrX7S99IB/1VA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/concave": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/concave/-/concave-7.3.1.tgz",
      "integrity": "sha512-vZWqyAYH4qzOuiqPb+bj2jvpIGzYAH8byUhfFJ2gRFRL3/RfV8jdXL2r0Y6VFScqE6OLVGvtM3ITzXX1/9wTaA==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/tin": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "topojson-client": "3.x",
        "topojson-server": "3.x",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/convex": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/convex/-/convex-7.3.1.tgz",
      "integrity": "sha512-k2T8QVSie4w+KhwUxjzi/6S6VFr33H9gnUawOh4chCGAgje9PljUZLCGbktHgDfAjX1FVzyUyriH+dm86Z7njQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "concaveman": "^1.2.1",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/destination": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/destination/-/destination-7.3.1.tgz",
      "integrity": "sha512-yyiJtbQJ4AB9Ny/FKDDNuWI9Sg4Jtd2PMpQPqOV3AFq8NNkg0xJSNmDHDxupb3oPqPWYPxyfVI3tBoF+Xhhoig==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/difference": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/difference/-/difference-7.3.1.tgz",
      "integrity": "sha512-Ne2AR+1AdeH8aqY2VHcws+Z/1MHl8SlSbSWHBNVZUVEfvyzTrRg8/E+OC5vFaSUvNZXkB/OUufTCM9xsatLKXQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "polyclip-ts": "^0.16.8",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/dissolve": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/dissolve/-/dissolve-7.3.1.tgz",
      "integrity": "sha512-Xmjl4E1aGRMdJjq+HfsiAXZtfMKruq7O+8xvsqnHM6E8iBWlJNSw8ucrNB5RZME8BUojx0q8bvXgS3k68koGyw==",
      "license": "MIT",
      "dependencies": {
        "@turf/flatten": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "polyclip-ts": "^0.16.8",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/distance": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/distance/-/distance-7.3.1.tgz",
      "integrity": "sha512-DK//doTGgYYjBkcWUywAe7wbZYcdP97hdEJ6rXYVYRoULwGGR3lhY96GNjozg6gaW9q2eSNYnZLpcL5iFVHqgw==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/distance-weight": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/distance-weight/-/distance-weight-7.3.1.tgz",
      "integrity": "sha512-h82qLPeMxOfgN62ZysscQCu9IYB5AO+duw7peAQnMtFobpbcQK58158P0cNzxAoTVJXSO/mfR9dI9Zdz7NF75w==",
      "license": "MIT",
      "dependencies": {
        "@turf/centroid": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/ellipse": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/ellipse/-/ellipse-7.3.1.tgz",
      "integrity": "sha512-tcGbS+U7EktZg+UJad17LRU+8C067XDWdmURPCmycaib2zRxeNrImh2Y/589us6wsldlYYoBYRxDY/c1oxIUCA==",
      "license": "MIT",
      "dependencies": {
        "@turf/destination": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/transform-rotate": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/envelope": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/envelope/-/envelope-7.3.1.tgz",
      "integrity": "sha512-Sp3ct/LpWyHN5tTfPOcKXFoVDI1QH9BXtQ+aQzABFp3U5nY2Sz8LFg8SeFQm3K7PpoCnUwSfwDFA4aa+z+4l1g==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/bbox-polygon": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/explode": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/explode/-/explode-7.3.1.tgz",
      "integrity": "sha512-H0Q8NnmrPoWKhsYYmVmkuT5F4t50N53ByGBf6Ys1n5B9YrFyrT+/aLDXF2C05r+QnW8nFtkM4lFG3ZSBHiq4Xg==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/flatten": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/flatten/-/flatten-7.3.1.tgz",
      "integrity": "sha512-cM/uuQP8oZ4IDJG342uOlqQ8yD9RsAY9Gg9nsDOgJn6tN065aigRCNy2lfrNyLdK/CPTVEWQzx1EQa+zXGSgAg==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/flip": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/flip/-/flip-7.3.1.tgz",
      "integrity": "sha512-6sF41pWY8Tw7w72hYc87sR9zzDei7UZ4Db/z0mKuNKueyzl4iTQ/H2JVd/XLZ7Tasz7H8htmrbUO0GR8GY7qiQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/geojson-rbush": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/geojson-rbush/-/geojson-rbush-7.3.1.tgz",
      "integrity": "sha512-EsrBBftZS5TvzRP2opLzwfnPXfmJi45KkGUcKSSFD0bxQe3BQUSmBrZbHMT8avB2s/XHrS/MniqsyeVOMwc35Q==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "rbush": "^3.0.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/great-circle": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/great-circle/-/great-circle-7.3.1.tgz",
      "integrity": "sha512-pfs7PzBRgYEEyecM0ni6iEF19grn9FmbHyaLz7voYInmc2ZHfWQaxuY4dcf9cziWDaiPlbuyr/RyE6envg1xpw==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/helpers": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/helpers/-/helpers-7.3.1.tgz",
      "integrity": "sha512-zkL34JVhi5XhsuMEO0MUTIIFEJ8yiW1InMu4hu/oRqamlY4mMoZql0viEmH6Dafh/p+zOl8OYvMJ3Vm3rFshgg==",
      "license": "MIT",
      "dependencies": {
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/hex-grid": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/hex-grid/-/hex-grid-7.3.1.tgz",
      "integrity": "sha512-cWAKxlU1aa06976C3RhpcilDzLnWwXkH/atNIWKGpLV/HubHrMXxhp9VMBKWaqsLbdn5x2uJjv4MxwWw9/373g==",
      "license": "MIT",
      "dependencies": {
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/intersect": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/interpolate": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/interpolate/-/interpolate-7.3.1.tgz",
      "integrity": "sha512-dquwDplzkSANMQdvxAu0dRF69EBIIlW/1zTPOB/BQfb/s7j6t8RskgbuV8ew1KpJPMmj7EbexejiMBtRWXTu4Q==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/centroid": "7.3.1",
        "@turf/clone": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/hex-grid": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/point-grid": "7.3.1",
        "@turf/square-grid": "7.3.1",
        "@turf/triangle-grid": "7.3.1",
        "@types/geojson": "^7946.0.10"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/intersect": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/intersect/-/intersect-7.3.1.tgz",
      "integrity": "sha512-676688YnF9wpprMioQWvxPlUMhtTvYITzw4XoG3lQmLjd/yt2cByanQHWpzWauLfYUlfuL13AeRGdqXRhSkhTQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "polyclip-ts": "^0.16.8",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/invariant": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/invariant/-/invariant-7.3.1.tgz",
      "integrity": "sha512-IdZJfDjIDCLH+Gu2yLFoSM7H23sdetIo5t4ET1/25X8gi3GE2XSqbZwaGjuZgNh02nisBewLqNiJs2bo+hrqZA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/isobands": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/isobands/-/isobands-7.3.1.tgz",
      "integrity": "sha512-An6+yUSrOStQSpZwKW9XN891kCW6eagtuofyudZ2BkoxcYRJ0vcDXo7RoiXuf9nHaG4k/xwhAzTqe8hdO1ltWA==",
      "license": "MIT",
      "dependencies": {
        "@turf/area": "7.3.1",
        "@turf/bbox": "7.3.1",
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/explode": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/isolines": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/isolines/-/isolines-7.3.1.tgz",
      "integrity": "sha512-TcwbTd7Z4BffYe1PtpXUtZvWCwTffta8VxqryGU30CbqKjNJYqrFbEQXS0mo4l3BEPPmT1lfMskUQ2g97O2MWQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/jsts": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/@turf/jsts/-/jsts-2.7.2.tgz",
      "integrity": "sha512-zAezGlwWHPyU0zxwcX2wQY3RkRpwuoBmhhNE9HY9kWhFDkCxZ3aWK5URKwa/SWKJbj9aztO+8vtdiBA28KVJFg==",
      "license": "(EDL-1.0 OR EPL-1.0)",
      "dependencies": {
        "jsts": "2.7.1"
      }
    },
    "node_modules/@turf/kinks": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/kinks/-/kinks-7.3.1.tgz",
      "integrity": "sha512-gGXNrhlF7zvLwRX672S0Be7bmYjbZEoZYnOGN6RvhyBFSSLFIbne+I74I+lWRzAzG/NhAMBXma5TpB09iTH06Q==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/length": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/length/-/length-7.3.1.tgz",
      "integrity": "sha512-QOr4qS3yi6qWIfQ/KLcy4rDLdemGCYpqz2YDh29R46seE+arSvlBI0KXvI36rPzgEMcUbQuVQyO65sOSqPaEjQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-arc": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-arc/-/line-arc-7.3.1.tgz",
      "integrity": "sha512-QSuVP0YWcfl76QjPb5Y2GJqXnziSJ2AuaJm5RKEFt5ELugXdEcHkRtydkGov+ZRPmI93jVmXoEE0UXwQx7aYHA==",
      "license": "MIT",
      "dependencies": {
        "@turf/circle": "7.3.1",
        "@turf/destination": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-chunk": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-chunk/-/line-chunk-7.3.1.tgz",
      "integrity": "sha512-fbJw/7Qlqz0XRMz0TgtFUivFHr51+++ZUBrARgs3w/pogeAdkrcWKBbuT2cowEsUkXDHaQ7MMpmuV8Uteru1qw==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/length": "7.3.1",
        "@turf/line-slice-along": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-intersect": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-intersect/-/line-intersect-7.3.1.tgz",
      "integrity": "sha512-HFPH4Hi+rG7XZ5rijkYL5C9JGVKd6gz6TToShVfqOt/qgGY9/bLYQxymgum/MG7sRhIa8xcKff2d57JrIVuSWA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "sweepline-intersections": "^1.5.0",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-offset": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-offset/-/line-offset-7.3.1.tgz",
      "integrity": "sha512-PyElfSyXETXcI8OKRsAJNdOcxlM718EG0d+b9zeO2uRztf2IlSb5w3lYiTIUSslEDA1gMQE31cJE8sAW40+nhg==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-overlap": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-overlap/-/line-overlap-7.3.1.tgz",
      "integrity": "sha512-xIhTfPhJMwz57DvM+/JuzG2BUL/gR/pJfH6w+vofI3akej33LTR8b296h2dhcJjDixxprVVH062AD1Q3AGKyfg==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-on-line": "7.3.1",
        "@turf/geojson-rbush": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/line-segment": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/nearest-point-on-line": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "fast-deep-equal": "^3.1.3",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-segment": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-segment/-/line-segment-7.3.1.tgz",
      "integrity": "sha512-hHz1fM2LigNKmnhyHDXtbRrkBqltH/lYEvhgSmv3laZ9PsEYL8jvA3o7+IhLM9B4KPa8N6VGim6ZR5YA5bhLvQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-slice": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-slice/-/line-slice-7.3.1.tgz",
      "integrity": "sha512-bp1L4sc7ZOYC4fwxpfWu+IR/COvLFGm5mjbLPK8VBJYa+kUNrzNcB3QE3A8yFRjwPtlUTCm5fDMLSoGtiJcy2g==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/nearest-point-on-line": "7.3.1",
        "@types/geojson": "^7946.0.10"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-slice-along": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-slice-along/-/line-slice-along-7.3.1.tgz",
      "integrity": "sha512-RizIhPytHxEewCyUCSMrZ5a58sQev0kZ0jzAV/9iTzvGfRD1VU/RG2ThLpSEqXYKBBSty98rTeSlnwsvZpAraA==",
      "license": "MIT",
      "dependencies": {
        "@turf/bearing": "7.3.1",
        "@turf/destination": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-split": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-split/-/line-split-7.3.1.tgz",
      "integrity": "sha512-Ee4NRN+eYKYX8vJDNvMpyZFjOntKFokQ/E8yFtKMcN++vG7RbnPOo2/ag6TMZaIHsahj4UR2yhqJbHTaB6Dp+g==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/geojson-rbush": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/line-intersect": "7.3.1",
        "@turf/line-segment": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/nearest-point-on-line": "7.3.1",
        "@turf/truncate": "7.3.1",
        "@types/geojson": "^7946.0.10"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/line-to-polygon": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/line-to-polygon/-/line-to-polygon-7.3.1.tgz",
      "integrity": "sha512-GL4fjbdYYjfOmwTu4dtllNHm18E7+hoXqyca2Rqb2ZzXj++NHvifJ9iYHUSdpV4/mkvVD3U2rU6jzNkjQeXIaA==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/mask": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/mask/-/mask-7.3.1.tgz",
      "integrity": "sha512-rSNS6wNuBiaUR1aU7tobgkzHpot5v9GKCn+n5gQ3ad7KWqwwqLWfcCPeyHBWkWEoEwc2yfPqikMQugZbmxrorg==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "polyclip-ts": "^0.16.8",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/meta": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/meta/-/meta-7.3.1.tgz",
      "integrity": "sha512-NWsfOE5RVtWpLQNkfOF/RrYvLRPwwruxhZUV0UFIzHqfiRJ50aO9Y6uLY4bwCUe2TumLJQSR4yaoA72Rmr2mnQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/midpoint": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/midpoint/-/midpoint-7.3.1.tgz",
      "integrity": "sha512-hx3eT9ut0Qyl8fyitCREp9l+v5Q4uBILht5+VKQS3p5eK2ijLEsKw4VikNZhh2rZ7bHGrs6obG5/P5ZqDTObiA==",
      "license": "MIT",
      "dependencies": {
        "@turf/bearing": "7.3.1",
        "@turf/destination": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/moran-index": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/moran-index/-/moran-index-7.3.1.tgz",
      "integrity": "sha512-9t70AjBB0bycJWLVprqS7mtRU+Ha+U4ji5lkKzyg31ZWAr0IwuawY2VQ/ydsodFMLCqmIf8QbWsltV/I/bRdjQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/distance-weight": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/nearest-neighbor-analysis": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/nearest-neighbor-analysis/-/nearest-neighbor-analysis-7.3.1.tgz",
      "integrity": "sha512-qwZON/7v1NbD1H1v3kTHJfLLml2/TNj5QQFRFBJiXRSCydMJT1sKEs5BwJe/9cBbmd0ln3gBWXCkG7Sk3sPgOQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/area": "7.3.1",
        "@turf/bbox": "7.3.1",
        "@turf/bbox-polygon": "7.3.1",
        "@turf/centroid": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/nearest-point": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/nearest-point": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/nearest-point/-/nearest-point-7.3.1.tgz",
      "integrity": "sha512-hLKGFzwAEop5z04X5BeurJvz0oVPHQX0rjeL3v83kgIjR/eavQucXKO3XkJBoF1AaT9Dv0mgB8rmj/qrwroWgg==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/nearest-point-on-line": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/nearest-point-on-line/-/nearest-point-on-line-7.3.1.tgz",
      "integrity": "sha512-FialyHfXXZWLayKQcUtdOtKv3ulOQ9FSI45kSmkDl8b96+VFWHX983Pc94tTrSTSg89+XX7MDr6gRl0yowmF4Q==",
      "license": "MIT",
      "dependencies": {
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/nearest-point-to-line": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/nearest-point-to-line/-/nearest-point-to-line-7.3.1.tgz",
      "integrity": "sha512-7zvhE15vlKBW7F3gYmxZMrnsS2HhXIt0Mpdymy6Y1oMWAXrYIqSeHl1Y/h2CiDh0v91K1KJXf2WyRYacosWiNA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/point-to-line-distance": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/planepoint": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/planepoint/-/planepoint-7.3.1.tgz",
      "integrity": "sha512-/DVTAZcOsSW54B9XDYUXyiL000vJ8WfONCF4FoM71VMeLS7PM3e+4W9gzN21q15XRn3nUftH12tJhqKEqDouvw==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/point-grid": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/point-grid/-/point-grid-7.3.1.tgz",
      "integrity": "sha512-KqBlGgBzI/M7/awK25o9p8Q+mRjQDRU4mpHtqNzqNxgidk4JxnUnGybYTnsjp3n1Zid3yASv5kARJ4i/Jc5F7w==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-within": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/point-on-feature": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/point-on-feature/-/point-on-feature-7.3.1.tgz",
      "integrity": "sha512-uX15wjujBMeMKAN7OLK4RV6KCLxsoQiFRB9kMtbTeZj13mDo+Bz5SyNN+M2AXqrdsQI9+4h0UTwu3EjcXj/nEw==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/center": "7.3.1",
        "@turf/explode": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/nearest-point": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/point-to-line-distance": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/point-to-line-distance/-/point-to-line-distance-7.3.1.tgz",
      "integrity": "sha512-vynnX3zIMmJY633fyAIKnzlsmL7OBhbk05YhWVSjCKvSQV8C2xMA9pWaLFacn1xu4nfMSVDUaNOrcAqwubN9pg==",
      "license": "MIT",
      "dependencies": {
        "@turf/bearing": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/nearest-point-on-line": "7.3.1",
        "@turf/projection": "7.3.1",
        "@turf/rhumb-bearing": "7.3.1",
        "@turf/rhumb-distance": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/point-to-polygon-distance": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/point-to-polygon-distance/-/point-to-polygon-distance-7.3.1.tgz",
      "integrity": "sha512-A2hTQjMKO2VEMdgOariICLCjt0BDc1wAQ7Mzqc4vFuol1/GlAed4JqyLg1zXuOVlZcojvXDk/XRuZwXDlRJkBA==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/point-to-line-distance": "7.3.1",
        "@turf/polygon-to-line": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/points-within-polygon": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/points-within-polygon/-/points-within-polygon-7.3.1.tgz",
      "integrity": "sha512-tVcQVykc1vvSqz+l/PA4EKVWfMrGtA3ZUxDYBoD2tSaM79EpdTcY1BzfxT5O2582SQ0AdNFXDXRTf7VI6u/+2Q==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/polygon-smooth": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/polygon-smooth/-/polygon-smooth-7.3.1.tgz",
      "integrity": "sha512-CNi4SdpOycZRSBr4o0MlrFdC6x5xcXP6jKx2yXZf9FPrOWamHsDXa+NrywCOAPhgZKnBodRF6usKWudVMyPIgg==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/polygon-tangents": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/polygon-tangents/-/polygon-tangents-7.3.1.tgz",
      "integrity": "sha512-XPLeCLQAcU2xco+3kS5Mp4AKmCKjOGzyZoC6oy8BuvHg1HaaEs0ZRzcmf0x17cq7bruhJ7n/QkcudnAueae5mg==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/boolean-within": "7.3.1",
        "@turf/explode": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/nearest-point": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/polygon-to-line": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/polygon-to-line/-/polygon-to-line-7.3.1.tgz",
      "integrity": "sha512-qTOFzn7SLQ0TcKBsPFAFYz7iiq34ijqinpjyr9fHQlFHRHeWzUXiWyIn5a2uOHazkdhHCEXNX8JPkt6hjdZ/fQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/polygonize": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/polygonize/-/polygonize-7.3.1.tgz",
      "integrity": "sha512-BSamH4eDSbREtye/RZiIyt488KI/hO3+2FiDB8JUoHNESe3VNWk4KEy+sL6oqfhOZcRWndHtJ6MOi3HFptyJrw==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/envelope": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/projection": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/projection/-/projection-7.3.1.tgz",
      "integrity": "sha512-nDM3LG2j37B1tCpF4xL4rUBrQJcG585IRyDIxL2QEvP1LLv6dcm4fodw70HcGAj05Ux8bJr7IOXQXnobOJrlRA==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/quadrat-analysis": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/quadrat-analysis/-/quadrat-analysis-7.3.1.tgz",
      "integrity": "sha512-Kwqtih5CnijULGoTobS0pXdzh/Yr3iGatJcKks4IaxA4+hlJ6Z+Mj47QfKvUtl/IP3lZpVzezewJ51Y989YtVg==",
      "license": "MIT",
      "dependencies": {
        "@turf/area": "7.3.1",
        "@turf/bbox": "7.3.1",
        "@turf/bbox-polygon": "7.3.1",
        "@turf/centroid": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/point-grid": "7.3.1",
        "@turf/random": "7.3.1",
        "@turf/square-grid": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/random": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/random/-/random-7.3.1.tgz",
      "integrity": "sha512-Iruica0gfdAuuqWG3SLe1MQOEP4IOGelPp81Cu552AamhHJmkEZCaiis2n28qdOlAbDs1NJZeJhRFNkiopiy+Q==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/rectangle-grid": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/rectangle-grid/-/rectangle-grid-7.3.1.tgz",
      "integrity": "sha512-3/fwd1dzeGApxGXAzyVINFylmn8trYTPLG6jtqOgriAdiHPMTtPqSW58wpScC43oKbK3Bps9dSZ43jvcbrfGxw==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-intersects": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/rewind": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/rewind/-/rewind-7.3.1.tgz",
      "integrity": "sha512-gD2TGPNq3SE6IlpDwkVHQthZ2U2MElh6X4Vfld3K7VsBHJv4eBct6OOgSWZLkVVPHuWNlVFTNtcRh2LAznMtgw==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-clockwise": "7.3.1",
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/rhumb-bearing": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/rhumb-bearing/-/rhumb-bearing-7.3.1.tgz",
      "integrity": "sha512-GA/EUSOMapLp6qK5kOX+PkFg2MMUHzUSm/jVezv6Fted0dAlCgXHOrKgLm0tN8PqbH7Oj9xQhv9+3/1ze7W8YA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/rhumb-destination": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/rhumb-destination/-/rhumb-destination-7.3.1.tgz",
      "integrity": "sha512-HjtAFr5DTISUn9b4oaZpX79tYl72r4EyAj40HKwjQeV6KkwIe5/h4zryOSEpnvAK2Gnkmu1GxYeTGfM5z3J9JA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/rhumb-distance": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/rhumb-distance/-/rhumb-distance-7.3.1.tgz",
      "integrity": "sha512-9ZvXU0ii2aywdphLhiawl3uxMEHucMmXCBiRj3WhmssTY9CZkFii9iImbJEqz5glxh6/gzXDcz1CCFQUdNP2xA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/sample": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/sample/-/sample-7.3.1.tgz",
      "integrity": "sha512-s9IkXrrtaHRllgk9X2tmg8+SJKLG6orQwf0p1wZX8WxnHXvmnHaju465A3nmtGGVDI/RSD8KwU9aqPcc4AinNw==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/sector": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/sector/-/sector-7.3.1.tgz",
      "integrity": "sha512-3BYJk7pQaqVr1Ji1ors6FUnhCJVHuobNf4bYW2yAUW1rxL+snuo6aTCsu39hpkwLj4BBknYt5w4MIOy5b8+QKg==",
      "license": "MIT",
      "dependencies": {
        "@turf/circle": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/line-arc": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/shortest-path": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/shortest-path/-/shortest-path-7.3.1.tgz",
      "integrity": "sha512-B0j6MoTSeGw1inRJPfj+6lU4WVXBNFAafqs/BkccScnCHLLK+vMnsOkyQoDX2vdZnhPTEaGj7TEL1SIjV6IMgA==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/bbox-polygon": "7.3.1",
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/clean-coords": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/transform-scale": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/simplify": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/simplify/-/simplify-7.3.1.tgz",
      "integrity": "sha512-8LRITQAyNAdvVInjm8pal3J7ZAZZBYrYd5oApXqHlIFK7gEiE21Hx9CZyog6AHDjxZCinwnEoGkzDxORh/mNMg==",
      "license": "MIT",
      "dependencies": {
        "@turf/clean-coords": "7.3.1",
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/square": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/square/-/square-7.3.1.tgz",
      "integrity": "sha512-LvMkII6bbHaFHp67jI029xHjWFK3pnqwF8c2pUNU+0dL+45KgrO2jaFTnNQdsjexPymI+uaNLlG809Y0aGGQlw==",
      "license": "MIT",
      "dependencies": {
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/square-grid": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/square-grid/-/square-grid-7.3.1.tgz",
      "integrity": "sha512-WYCX8+nrqHyAhKBSBHFp1eU1gWrcojz9uVvhCbDO8NO14SLHowzWOgB61Gv8KlLXCUBjDr+rYWCt3ymyPzU5TA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/rectangle-grid": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/standard-deviational-ellipse": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/standard-deviational-ellipse/-/standard-deviational-ellipse-7.3.1.tgz",
      "integrity": "sha512-u9ojpWyv3rnFioYZyya6VXVDrRPYymNROVKwGqnQzffYE1MdxhJ6ik/CvdcChzCNvSNVBJQUvnjjPq2C2uOsLA==",
      "license": "MIT",
      "dependencies": {
        "@turf/center-mean": "7.3.1",
        "@turf/ellipse": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/points-within-polygon": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/tag": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/tag/-/tag-7.3.1.tgz",
      "integrity": "sha512-Y7G2EWm0/j78ss5wCnjGWKfmPbXw9yKJFg93EuMnwggIsDfKdQi/vdUInjQ0462RIQA87StlydPG09X/8bquwQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/tesselate": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/tesselate/-/tesselate-7.3.1.tgz",
      "integrity": "sha512-iJnatp9RcJvyffBjqJaw5GbKE/PQosT8DH2kgG7pv4Re0xl3h/QvCjvTlCTEmJ5cNY4geZVKUXDvkkCkgQQVuA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "earcut": "^2.2.4",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/tin": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/tin/-/tin-7.3.1.tgz",
      "integrity": "sha512-pDtHE8rLXvV4zAC9mWmwToDDda2ZTty8IZqZIoUqTnlf6AJjzF7TJrhoE3a+zukRTUI1wowTFqe2NvwgNX0yew==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/transform-rotate": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/transform-rotate/-/transform-rotate-7.3.1.tgz",
      "integrity": "sha512-KAYebOkk7IT2j7S8M+ZxDAmyqeni9ZZGU9ouD6mvd/hTpDOlGG+ORRmg312RxG0NiThzCHLyeG1Nea1nEud6bg==",
      "license": "MIT",
      "dependencies": {
        "@turf/centroid": "7.3.1",
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/rhumb-bearing": "7.3.1",
        "@turf/rhumb-destination": "7.3.1",
        "@turf/rhumb-distance": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/transform-scale": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/transform-scale/-/transform-scale-7.3.1.tgz",
      "integrity": "sha512-e8jBSWEn0BMxG0HR8ZMvkHgBgdwNrFRzbhy8DqQwZDgUN59fMeWGbjX5QR5Exl2gZBPaBXkgbDgEhh/JD3kYhw==",
      "license": "MIT",
      "dependencies": {
        "@turf/bbox": "7.3.1",
        "@turf/center": "7.3.1",
        "@turf/centroid": "7.3.1",
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/rhumb-bearing": "7.3.1",
        "@turf/rhumb-destination": "7.3.1",
        "@turf/rhumb-distance": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/transform-translate": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/transform-translate/-/transform-translate-7.3.1.tgz",
      "integrity": "sha512-yeaW1EqfuuY4l5VBWSsItglaZ9qdTFD0QEIUW1ooOYuQvtKQ2MTKrcQIKLXZckxQrrNq4TXsZDaBbFs+U1wtcQ==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/rhumb-destination": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/triangle-grid": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/triangle-grid/-/triangle-grid-7.3.1.tgz",
      "integrity": "sha512-lhZyqnQC/M8x8DgQURHNZP/HaJIqrL5We5ZvzJBX+lrH2u4DO831awJcuDniRuJ5e0QE5n4yMsBJO77KMNdKfw==",
      "license": "MIT",
      "dependencies": {
        "@turf/distance": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/intersect": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/truncate": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/truncate/-/truncate-7.3.1.tgz",
      "integrity": "sha512-rcXHM2m17hyKoW1dJpOvTgUUWFOKluTKKsoLmhEE6aRAYwtuVetkcInt4qBtS1bv7MaL//glbvq0kdEGR0YaOA==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/turf": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/turf/-/turf-7.3.1.tgz",
      "integrity": "sha512-0uKkNnM6Bo6cIzZcJ6wQ+FjFioTFXWS3woGDvQ5R7EPehNfdr4HTS39m1seE+HdI8lGItMZehb6fb0jtjP4Clg==",
      "license": "MIT",
      "dependencies": {
        "@turf/along": "7.3.1",
        "@turf/angle": "7.3.1",
        "@turf/area": "7.3.1",
        "@turf/bbox": "7.3.1",
        "@turf/bbox-clip": "7.3.1",
        "@turf/bbox-polygon": "7.3.1",
        "@turf/bearing": "7.3.1",
        "@turf/bezier-spline": "7.3.1",
        "@turf/boolean-clockwise": "7.3.1",
        "@turf/boolean-concave": "7.3.1",
        "@turf/boolean-contains": "7.3.1",
        "@turf/boolean-crosses": "7.3.1",
        "@turf/boolean-disjoint": "7.3.1",
        "@turf/boolean-equal": "7.3.1",
        "@turf/boolean-intersects": "7.3.1",
        "@turf/boolean-overlap": "7.3.1",
        "@turf/boolean-parallel": "7.3.1",
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/boolean-point-on-line": "7.3.1",
        "@turf/boolean-touches": "7.3.1",
        "@turf/boolean-valid": "7.3.1",
        "@turf/boolean-within": "7.3.1",
        "@turf/buffer": "7.3.1",
        "@turf/center": "7.3.1",
        "@turf/center-mean": "7.3.1",
        "@turf/center-median": "7.3.1",
        "@turf/center-of-mass": "7.3.1",
        "@turf/centroid": "7.3.1",
        "@turf/circle": "7.3.1",
        "@turf/clean-coords": "7.3.1",
        "@turf/clone": "7.3.1",
        "@turf/clusters": "7.3.1",
        "@turf/clusters-dbscan": "7.3.1",
        "@turf/clusters-kmeans": "7.3.1",
        "@turf/collect": "7.3.1",
        "@turf/combine": "7.3.1",
        "@turf/concave": "7.3.1",
        "@turf/convex": "7.3.1",
        "@turf/destination": "7.3.1",
        "@turf/difference": "7.3.1",
        "@turf/dissolve": "7.3.1",
        "@turf/distance": "7.3.1",
        "@turf/distance-weight": "7.3.1",
        "@turf/ellipse": "7.3.1",
        "@turf/envelope": "7.3.1",
        "@turf/explode": "7.3.1",
        "@turf/flatten": "7.3.1",
        "@turf/flip": "7.3.1",
        "@turf/geojson-rbush": "7.3.1",
        "@turf/great-circle": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/hex-grid": "7.3.1",
        "@turf/interpolate": "7.3.1",
        "@turf/intersect": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@turf/isobands": "7.3.1",
        "@turf/isolines": "7.3.1",
        "@turf/kinks": "7.3.1",
        "@turf/length": "7.3.1",
        "@turf/line-arc": "7.3.1",
        "@turf/line-chunk": "7.3.1",
        "@turf/line-intersect": "7.3.1",
        "@turf/line-offset": "7.3.1",
        "@turf/line-overlap": "7.3.1",
        "@turf/line-segment": "7.3.1",
        "@turf/line-slice": "7.3.1",
        "@turf/line-slice-along": "7.3.1",
        "@turf/line-split": "7.3.1",
        "@turf/line-to-polygon": "7.3.1",
        "@turf/mask": "7.3.1",
        "@turf/meta": "7.3.1",
        "@turf/midpoint": "7.3.1",
        "@turf/moran-index": "7.3.1",
        "@turf/nearest-neighbor-analysis": "7.3.1",
        "@turf/nearest-point": "7.3.1",
        "@turf/nearest-point-on-line": "7.3.1",
        "@turf/nearest-point-to-line": "7.3.1",
        "@turf/planepoint": "7.3.1",
        "@turf/point-grid": "7.3.1",
        "@turf/point-on-feature": "7.3.1",
        "@turf/point-to-line-distance": "7.3.1",
        "@turf/point-to-polygon-distance": "7.3.1",
        "@turf/points-within-polygon": "7.3.1",
        "@turf/polygon-smooth": "7.3.1",
        "@turf/polygon-tangents": "7.3.1",
        "@turf/polygon-to-line": "7.3.1",
        "@turf/polygonize": "7.3.1",
        "@turf/projection": "7.3.1",
        "@turf/quadrat-analysis": "7.3.1",
        "@turf/random": "7.3.1",
        "@turf/rectangle-grid": "7.3.1",
        "@turf/rewind": "7.3.1",
        "@turf/rhumb-bearing": "7.3.1",
        "@turf/rhumb-destination": "7.3.1",
        "@turf/rhumb-distance": "7.3.1",
        "@turf/sample": "7.3.1",
        "@turf/sector": "7.3.1",
        "@turf/shortest-path": "7.3.1",
        "@turf/simplify": "7.3.1",
        "@turf/square": "7.3.1",
        "@turf/square-grid": "7.3.1",
        "@turf/standard-deviational-ellipse": "7.3.1",
        "@turf/tag": "7.3.1",
        "@turf/tesselate": "7.3.1",
        "@turf/tin": "7.3.1",
        "@turf/transform-rotate": "7.3.1",
        "@turf/transform-scale": "7.3.1",
        "@turf/transform-translate": "7.3.1",
        "@turf/triangle-grid": "7.3.1",
        "@turf/truncate": "7.3.1",
        "@turf/union": "7.3.1",
        "@turf/unkink-polygon": "7.3.1",
        "@turf/voronoi": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/union": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/union/-/union-7.3.1.tgz",
      "integrity": "sha512-Fk8HvP2gRrRJz8xefeoFJJUeLwhih3HoPPKlqaDf/6L43jwAzBD6BPu59+AwRXOlaZeOUMNMGzgSgx0KKrBwBg==",
      "license": "MIT",
      "dependencies": {
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "polyclip-ts": "^0.16.8",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/unkink-polygon": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/unkink-polygon/-/unkink-polygon-7.3.1.tgz",
      "integrity": "sha512-6NVFkCpJUT2P4Yf3z/FI2uGDXqVdEqZqKGl2hYitmH7mNiKhU4bAvvcw7nCSfNG3sUyNhibbtOEopYMRgwimPw==",
      "license": "MIT",
      "dependencies": {
        "@turf/area": "7.3.1",
        "@turf/boolean-point-in-polygon": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/meta": "7.3.1",
        "@types/geojson": "^7946.0.10",
        "rbush": "^3.0.1",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@turf/voronoi": {
      "version": "7.3.1",
      "resolved": "https://registry.npmjs.org/@turf/voronoi/-/voronoi-7.3.1.tgz",
      "integrity": "sha512-yS+0EDwSIOizEXI+05qixw/OGZalpfsz9xzBWbCBA3Gu2boLMXErFZ73qzfu39Vwk+ILbu5em0p+VhULBzvH9w==",
      "license": "MIT",
      "dependencies": {
        "@turf/clone": "7.3.1",
        "@turf/helpers": "7.3.1",
        "@turf/invariant": "7.3.1",
        "@types/d3-voronoi": "^1.1.12",
        "@types/geojson": "^7946.0.10",
        "d3-voronoi": "1.1.2",
        "tslib": "^2.8.1"
      },
      "funding": {
        "url": "https://opencollective.com/turf"
      }
    },
    "node_modules/@types/bcryptjs": {
      "version": "2.4.6",
      "resolved": "https://registry.npmjs.org/@types/bcryptjs/-/bcryptjs-2.4.6.tgz",
      "integrity": "sha512-9xlo6R2qDs5uixm0bcIqCeMCE6HiQsIyel9KQySStiyqNl2tnj2mP3DX1Nf56MD6KMenNNlBBsy3LJ7gUEQPXQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/body-parser": {
      "version": "1.19.6",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.6.tgz",
      "integrity": "sha512-HLFeCYgz89uk22N5Qg3dvGvsv46B8GLvKKo1zKG4NybA8U2DiEO3w9lqGg29t/tfLRJpJ6iQxnVw4OnB7MoM9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/connect": {
      "version": "3.4.38",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/cookie-parser": {
      "version": "1.4.10",
      "resolved": "https://registry.npmjs.org/@types/cookie-parser/-/cookie-parser-1.4.10.tgz",
      "integrity": "sha512-B4xqkqfZ8Wek+rCOeRxsjMS9OgvzebEzzLYw7NHYuvzb7IdxOkI0ZHGgeEBX4PUM7QGVvNSK60T3OvWj3YfBRg==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/express": "*"
      }
    },
    "node_modules/@types/cors": {
      "version": "2.8.19",
      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.19.tgz",
      "integrity": "sha512-mFNylyeyqN93lfe/9CSxOGREz8cpzAhH+E93xJ4xWQf62V8sQ/24reV2nyzUWM6H6Xji+GGHpkbLe7pVoUEskg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/d3-voronoi": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/@types/d3-voronoi/-/d3-voronoi-1.1.12.tgz",
      "integrity": "sha512-DauBl25PKZZ0WVJr42a6CNvI6efsdzofl9sajqZr2Gf5Gu733WkDdUGiPkUHXiUvYGzNNlFQde2wdZdfQPG+yw==",
      "license": "MIT"
    },
    "node_modules/@types/express": {
      "version": "5.0.5",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-5.0.5.tgz",
      "integrity": "sha512-LuIQOcb6UmnF7C1PCFmEU1u2hmiHL43fgFQX67sN3H4Z+0Yk0Neo++mFsBjhOAuLzvlQeqAAkeDOZrJs9rzumQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^5.0.0",
        "@types/serve-static": "^1"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-5.1.0.tgz",
      "integrity": "sha512-jnHMsrd0Mwa9Cf4IdOzbz543y4XJepXrbia2T4b6+spXC2We3t1y6K44D3mR8XMFSXMCf3/l7rCgddfx7UNVBA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/geojson": {
      "version": "7946.0.16",
      "resolved": "https://registry.npmjs.org/@types/geojson/-/geojson-7946.0.16.tgz",
      "integrity": "sha512-6C8nqWur3j98U6+lXDfTUWIfgvZU+EumvpHKcYjujKH7woYyLj2sUmff0tRhrqM7BohUw7Pz3ZB1jj2gW9Fvmg==",
      "license": "MIT"
    },
    "node_modules/@types/http-errors": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.5.tgz",
      "integrity": "sha512-r8Tayk8HJnX0FztbZN7oVqGccWgw98T/0neJphO91KkmOzug1KkofZURD4UaD5uH8AqcFLfdPErnBod0u71/qg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json2csv": {
      "version": "5.0.7",
      "resolved": "https://registry.npmjs.org/@types/json2csv/-/json2csv-5.0.7.tgz",
      "integrity": "sha512-Ma25zw9G9GEBnX8b12R4EYvnFT6dBh8L3jwsN5EUFXa+fl2dqmbLDbNWN0XuQU3rSXdsbBeCYjI9uHU2PUBxhA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.10",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.10.tgz",
      "integrity": "sha512-asx5hIG9Qmf/1oStypjanR7iKTv0gXQ1Ov/jfrX6kS/EO0OFni8orbmGCn0672NHR3kXHwpAwR+B368ZGN/2rA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/ms": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/mime": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/ms": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@types/ms/-/ms-2.1.0.tgz",
      "integrity": "sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/multer": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/@types/multer/-/multer-2.0.0.tgz",
      "integrity": "sha512-C3Z9v9Evij2yST3RSBktxP9STm6OdMc5uR1xF1SGr98uv8dUlAL2hqwrZ3GVB3uyMyiegnscEK6PGtYvNrjTjw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/express": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "24.10.0",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.10.0.tgz",
      "integrity": "sha512-qzQZRBqkFsYyaSWXuEHc2WR9c0a0CXwiE5FWUvn7ZM+vdy1uZLfCunD38UzhuB7YN/J11ndbDBcTmOdxJo9Q7A==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.16.0"
      }
    },
    "node_modules/@types/nodemailer": {
      "version": "7.0.4",
      "resolved": "https://registry.npmjs.org/@types/nodemailer/-/nodemailer-7.0.4.tgz",
      "integrity": "sha512-ee8fxWqOchH+Hv6MDDNNy028kwvVnLplrStm4Zf/3uHWw5zzo8FoYYeffpJtGs2wWysEumMH0ZIdMGMY1eMAow==",
      "license": "MIT",
      "dependencies": {
        "@aws-sdk/client-sesv2": "^3.839.0",
        "@types/node": "*"
      }
    },
    "node_modules/@types/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-eOunJqu0K1923aExK6y8p6fsihYEn/BYuQ4g0CxAAgFc4b/ZLN4CrsRZ55srTdqoiLzU2B2evC+apEIxprEzkQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/send": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/@types/send/-/send-1.2.1.tgz",
      "integrity": "sha512-arsCikDvlU99zl1g69TcAB3mzZPpxgw0UQnaHeC1Nwb015xp8bknZv5rIfri9xTOcMuaVgvabfIRA7PSZVuZIQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/serve-static": {
      "version": "1.15.10",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.10.tgz",
      "integrity": "sha512-tRs1dB+g8Itk72rlSI2ZrW6vZg0YrLI81iQSTkMmOqnqCaNr/8Ek4VwWcN5vZgCYWbg/JJSGBlUaYGAOP73qBw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/http-errors": "*",
        "@types/node": "*",
        "@types/send": "<1"
      }
    },
    "node_modules/@types/serve-static/node_modules/@types/send": {
      "version": "0.17.6",
      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.6.tgz",
      "integrity": "sha512-Uqt8rPBE8SY0RK8JB1EzVOIZ32uqy8HwdxCnoCOsYrvnswqmFZ/k+9Ikidlk/ImhsdvBsloHbAlewb2IEBV/Og==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/mime": "^1",
        "@types/node": "*"
      }
    },
    "node_modules/@types/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/@types/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-7gqG38EyHgyP1S+7+xomFtL+ZNHcKv6DwNaCZmJmo1vgMugyF3TCnXVg4t1uk89mLNwnLtnY3TpOpCOyp1/xHQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@typespec/ts-http-runtime": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/@typespec/ts-http-runtime/-/ts-http-runtime-0.3.2.tgz",
      "integrity": "sha512-IlqQ/Gv22xUC1r/WQm4StLkYQmaaTsXAhUVsNE0+xiyf0yRFiH5++q78U3bw6bLKDCTmh0uqKB9eG9+Bt75Dkg==",
      "license": "MIT",
      "dependencies": {
        "http-proxy-agent": "^7.0.0",
        "https-proxy-agent": "^7.0.0",
        "tslib": "^2.6.2"
      },
      "engines": {
        "node": ">=20.0.0"
      }
    },
    "node_modules/accepts": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz",
      "integrity": "sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "^3.0.0",
        "negotiator": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.3.4",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.4.tgz",
      "integrity": "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "acorn": "^8.11.0"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/agent-base": {
      "version": "7.1.4",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
      "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/append-field": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/append-field/-/append-field-1.0.0.tgz",
      "integrity": "sha512-klpgFSWLW1ZEs8svjfb7g4qWY0YS5imI82dTg+QahUvJ8YqAY0P10Uk8tTyh9ZGuYEZEMaeJYCF5BFuX552hsw==",
      "license": "MIT"
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/axios": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.13.2.tgz",
      "integrity": "sha512-VPk9ebNqPcy5lRGuSlKx752IlDatOjT9paPlm8A7yOuW2Fbvp4X3JznJtT4f0GzGLLiWE9W8onz51SqLYwzGaA==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.4",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/bcryptjs": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/bcryptjs/-/bcryptjs-3.0.3.tgz",
      "integrity": "sha512-GlF5wPWnSa/X5LKM1o0wz0suXIINz1iHRLvTS+sLyi7XPbe5ycmYI3DlZqVGZZtDgl4DmasFg7gOB3JYbphV5g==",
      "license": "BSD-3-Clause",
      "bin": {
        "bcrypt": "bin/bcrypt"
      }
    },
    "node_modules/bignumber.js": {
      "version": "9.3.1",
      "resolved": "https://registry.npmjs.org/bignumber.js/-/bignumber.js-9.3.1.tgz",
      "integrity": "sha512-Ko0uX15oIUS7wJ3Rb30Fs6SkVbLmPBAKdlm7q9+ak9bbIeFf0MwuBsQV6z7+X768/cHsfg+WlysDWJcmthjsjQ==",
      "license": "MIT",
      "engines": {
        "node": "*"
      }
    },
    "node_modules/body-parser": {
      "version": "2.2.1",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-2.2.1.tgz",
      "integrity": "sha512-nfDwkulwiZYQIGwxdy0RUmowMhKcFVcYXUU7m4QlKYim1rUtg83xm2yjZ40QjDuc291AJjjeSc9b++AWHSgSHw==",
      "license": "MIT",
      "dependencies": {
        "bytes": "^3.1.2",
        "content-type": "^1.0.5",
        "debug": "^4.4.3",
        "http-errors": "^2.0.0",
        "iconv-lite": "^0.7.0",
        "on-finished": "^2.4.1",
        "qs": "^6.14.0",
        "raw-body": "^3.0.1",
        "type-is": "^2.0.1"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/bowser": {
      "version": "2.13.1",
      "resolved": "https://registry.npmjs.org/bowser/-/bowser-2.13.1.tgz",
      "integrity": "sha512-OHawaAbjwx6rqICCKgSG0SAnT05bzd7ppyKLVUITZpANBaaMFBAsaNkto3LoQ31tyFP5kNujE8Cdx85G9VzOkw==",
      "license": "MIT"
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
      "license": "MIT"
    },
    "node_modules/busboy": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/busboy/-/busboy-1.6.0.tgz",
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": {
        "streamsearch": "^1.1.0"
      },
      "engines": {
        "node": ">=10.16.0"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/c12": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/c12/-/c12-3.1.0.tgz",
      "integrity": "sha512-uWoS8OU1MEIsOv8p/5a82c3H31LsWVR5qiyXVfBNOzfffjUWtPnhAb4BYI2uG2HfGmZmFjCtui5XNWaps+iFuw==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^4.0.3",
        "confbox": "^0.2.2",
        "defu": "^6.1.4",
        "dotenv": "^16.6.1",
        "exsolve": "^1.0.7",
        "giget": "^2.0.0",
        "jiti": "^2.4.2",
        "ohash": "^2.0.11",
        "pathe": "^2.0.3",
        "perfect-debounce": "^1.0.0",
        "pkg-types": "^2.2.0",
        "rc9": "^2.1.2"
      },
      "peerDependencies": {
        "magicast": "^0.3.5"
      },
      "peerDependenciesMeta": {
        "magicast": {
          "optional": true
        }
      }
    },
    "node_modules/c12/node_modules/dotenv": {
      "version": "16.6.1",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-16.6.1.tgz",
      "integrity": "sha512-uBq4egWHTcTt33a72vpSG0z3HnPuIl6NqYcTrKEg2azoEyl2hpW0zqlxysq2pK9HlDIHyHyakeYaYnSAwd8bow==",
      "devOptional": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/chokidar": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-4.0.3.tgz",
      "integrity": "sha512-Qgzu8kfBvo+cA4962jnP1KkS6Dop5NS6g7R5LFYJr4b8Ub94PPQXUksCw9PvXoeXPRRddRNC5C1JQUR2SMGtnA==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "readdirp": "^4.0.1"
      },
      "engines": {
        "node": ">= 14.16.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/citty": {
      "version": "0.1.6",
      "resolved": "https://registry.npmjs.org/citty/-/citty-0.1.6.tgz",
      "integrity": "sha512-tskPPKEs8D2KPafUypv2gxwJP8h/OaJmC82QQGGDQcHvXX43xF2VDACcJVmZ0EuSxkpO9Kc4MlrA3q0+FG58AQ==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "consola": "^3.2.3"
      }
    },
    "node_modules/cluster-key-slot": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/cluster-key-slot/-/cluster-key-slot-1.1.2.tgz",
      "integrity": "sha512-RMr0FhtfXemyinomL4hrWcYJxmX6deFdCxpJzhDttxgO1+bcCnkk+9drydLVDmAMG7NE6aN/fl4F7ucU/90gAA==",
      "license": "Apache-2.0",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/commander": {
      "version": "2.20.3",
      "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
      "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
      "license": "MIT"
    },
    "node_modules/concat-stream": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/concat-stream/-/concat-stream-2.0.0.tgz",
      "integrity": "sha512-MWufYdFw53ccGjCA+Ol7XJYpAlW6/prSMzuPOTRnJGcGzuhLn4Scrz7qf6o8bROZ514ltazcIFJZevcfbo0x7A==",
      "engines": [
        "node >= 6.0"
      ],
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^3.0.2",
        "typedarray": "^0.0.6"
      }
    },
    "node_modules/concaveman": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/concaveman/-/concaveman-1.2.1.tgz",
      "integrity": "sha512-PwZYKaM/ckQSa8peP5JpVr7IMJ4Nn/MHIaWUjP4be+KoZ7Botgs8seAZGpmaOM+UZXawcdYRao/px9ycrCihHw==",
      "license": "ISC",
      "dependencies": {
        "point-in-polygon": "^1.1.0",
        "rbush": "^3.0.1",
        "robust-predicates": "^2.0.4",
        "tinyqueue": "^2.0.3"
      }
    },
    "node_modules/concaveman/node_modules/tinyqueue": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/tinyqueue/-/tinyqueue-2.0.3.tgz",
      "integrity": "sha512-ppJZNDuKGgxzkHihX8v9v9G5f+18gzaTfrukGrq6ueg0lmH4nqVnA2IPG0AEH3jKEk2GRJCUhDoqpoiw3PHLBA==",
      "license": "ISC"
    },
    "node_modules/confbox": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/confbox/-/confbox-0.2.2.tgz",
      "integrity": "sha512-1NB+BKqhtNipMsov4xI/NnhCKp9XG9NamYp5PVm9klAT0fsrNPjaFICsCFhNhwZJKNh7zB/3q8qXz0E9oaMNtQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/consola": {
      "version": "3.4.2",
      "resolved": "https://registry.npmjs.org/consola/-/consola-3.4.2.tgz",
      "integrity": "sha512-5IKcdX0nnYavi6G7TtOhwkYzyjfJlatbjMjuLSfE2kYT5pMDOilZ4OvMhi637CcDICTmz3wARPoyhqyX1Y+XvA==",
      "devOptional": true,
      "license": "MIT",
      "engines": {
        "node": "^14.18.0 || >=16.10.0"
      }
    },
    "node_modules/content-disposition": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.0.tgz",
      "integrity": "sha512-Au9nRL8VNUut/XSzbQA38+M78dzP4D+eqg3gfJHMIHHYa3bg067xj1KxMUWj+VULbiZMowKngFFbKczUrNJ1mg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-parser": {
      "version": "1.4.7",
      "resolved": "https://registry.npmjs.org/cookie-parser/-/cookie-parser-1.4.7.tgz",
      "integrity": "sha512-nGUvgXnotP3BsjiLX2ypbQnWoGUPIIfHQNZkkC668ntrzGWEZVW70HDEB1qnNGMicPje6EttlIgzo51YSwNQGw==",
      "license": "MIT",
      "dependencies": {
        "cookie": "0.7.2",
        "cookie-signature": "1.0.6"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/cookie-parser/node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ==",
      "license": "MIT"
    },
    "node_modules/cookie-signature": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
      "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
      "license": "MIT",
      "engines": {
        "node": ">=6.6.0"
      }
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/d3-array": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/d3-array/-/d3-array-1.2.4.tgz",
      "integrity": "sha512-KHW6M86R+FUPYGb3R5XiYjXPq7VzwxZ22buHhAEVG5ztoEcZZMLov530mmccaqA1GghZArjQV46fuc8kUqhhHw==",
      "license": "BSD-3-Clause"
    },
    "node_modules/d3-geo": {
      "version": "1.7.1",
      "resolved": "https://registry.npmjs.org/d3-geo/-/d3-geo-1.7.1.tgz",
      "integrity": "sha512-O4AempWAr+P5qbk2bC2FuN/sDW4z+dN2wDf9QV3bxQt4M5HfOEeXLgJ/UKQW0+o1Dj8BE+L5kiDbdWUMjsmQpw==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "d3-array": "1"
      }
    },
    "node_modules/d3-voronoi": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/d3-voronoi/-/d3-voronoi-1.1.2.tgz",
      "integrity": "sha512-RhGS1u2vavcO7ay7ZNAPo4xeDh/VYeGof3x5ZLJBQgYhLegxr3s5IykvWmJ94FTU6mcbtp4sloqZ54mP6R4Utw==",
      "license": "BSD-3-Clause"
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deepmerge-ts": {
      "version": "7.1.5",
      "resolved": "https://registry.npmjs.org/deepmerge-ts/-/deepmerge-ts-7.1.5.tgz",
      "integrity": "sha512-HOJkrhaYsweh+W+e74Yn7YStZOilkoPb6fycpwNLKzSPtruFs48nYis0zy5yJz1+ktUhHxoRDJ27RQAWLIJVJw==",
      "devOptional": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/defu": {
      "version": "6.1.4",
      "resolved": "https://registry.npmjs.org/defu/-/defu-6.1.4.tgz",
      "integrity": "sha512-mEQCMmwJu317oSz8CwdIOdwf3xMif1ttiM8LTufzc3g6kR+9Pe236twL8j3IYT1F7GfRgGcW6MWxzZjLIkuHIg==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destr": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/destr/-/destr-2.0.5.tgz",
      "integrity": "sha512-ugFTXCtDZunbzasqBxrK93Ik/DRYsO6S/fedkWEMKqt04xZ4csmnmwGDBAb07QWNaGMAmnTIemsYZCksjATwsA==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/dotenv": {
      "version": "17.2.3",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-17.2.3.tgz",
      "integrity": "sha512-JVUnt+DUIzu87TABbhPmNfVdBDt18BLOWjMUFJMSi/Qqg7NTYtabbvSNJGOJ7afbRuv9D/lngizHtP7QyLQ+9w==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/earcut": {
      "version": "2.2.4",
      "resolved": "https://registry.npmjs.org/earcut/-/earcut-2.2.4.tgz",
      "integrity": "sha512-/pjZsA1b4RPHbeWZQn66SWS8nZZWLQQ23oE3Eam7aroEFGEvwKAsJfZ9ytiEMycfzXWpca4FA9QIOehf7PocBQ==",
      "license": "ISC"
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/effect": {
      "version": "3.18.4",
      "resolved": "https://registry.npmjs.org/effect/-/effect-3.18.4.tgz",
      "integrity": "sha512-b1LXQJLe9D11wfnOKAk3PKxuqYshQ0Heez+y5pnkd3jLj1yx9QhM72zZ9uUrOQyNvrs2GZZd/3maL0ZV18YuDA==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "@standard-schema/spec": "^1.0.0",
        "fast-check": "^3.23.1"
      }
    },
    "node_modules/empathic": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/empathic/-/empathic-2.0.0.tgz",
      "integrity": "sha512-i6UzDscO/XfAcNYD75CfICkmfLedpyPDdozrLMmQc5ORaQcdMoc21OnlEylMIqI7U8eniKrPMxxtj8k0vhmJhA==",
      "devOptional": true,
      "license": "MIT",
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/events": {
      "version": "3.3.0",
      "resolved": "https://registry.npmjs.org/events/-/events-3.3.0.tgz",
      "integrity": "sha512-mQw+2fkQbALzQ7V0MY0IqdnXNOeTtP4r0lN9z7AAawCXgqea7bDii20AYrIBrFd/Hx0M2Ocz6S111CaFkUcb0Q==",
      "license": "MIT",
      "engines": {
        "node": ">=0.8.x"
      }
    },
    "node_modules/express": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/express/-/express-5.1.0.tgz",
      "integrity": "sha512-DT9ck5YIRU+8GYzzU5kT3eHGA5iL+1Zd0EutOmTE9Dtk+Tvuzd23VBU+ec7HPNSTxXYO55gPV/hq4pSBJDjFpA==",
      "license": "MIT",
      "dependencies": {
        "accepts": "^2.0.0",
        "body-parser": "^2.2.0",
        "content-disposition": "^1.0.0",
        "content-type": "^1.0.5",
        "cookie": "^0.7.1",
        "cookie-signature": "^1.2.1",
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "finalhandler": "^2.1.0",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "merge-descriptors": "^2.0.0",
        "mime-types": "^3.0.0",
        "on-finished": "^2.4.1",
        "once": "^1.4.0",
        "parseurl": "^1.3.3",
        "proxy-addr": "^2.0.7",
        "qs": "^6.14.0",
        "range-parser": "^1.2.1",
        "router": "^2.2.0",
        "send": "^1.1.0",
        "serve-static": "^2.2.0",
        "statuses": "^2.0.1",
        "type-is": "^2.0.1",
        "vary": "^1.1.2"
      },
      "engines": {
        "node": ">= 18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/exsolve": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/exsolve/-/exsolve-1.0.8.tgz",
      "integrity": "sha512-LmDxfWXwcTArk8fUEnOfSZpHOJ6zOMUJKOtFLFqJLoKJetuQG874Uc7/Kki7zFLzYybmZhp1M7+98pfMqeX8yA==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/fast-check": {
      "version": "3.23.2",
      "resolved": "https://registry.npmjs.org/fast-check/-/fast-check-3.23.2.tgz",
      "integrity": "sha512-h5+1OzzfCC3Ef7VbtKdcv7zsstUQwUDlYpUTvjeUsJAssPgLn7QzbboPtL5ro04Mq0rPOsMzl7q5hIbRs2wD1A==",
      "devOptional": true,
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/dubzzz"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fast-check"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "pure-rand": "^6.1.0"
      },
      "engines": {
        "node": ">=8.0.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "license": "MIT"
    },
    "node_modules/fast-xml-parser": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/fast-xml-parser/-/fast-xml-parser-5.3.2.tgz",
      "integrity": "sha512-n8v8b6p4Z1sMgqRmqLJm3awW4NX7NkaKPfb3uJIBTSH7Pdvufi3PQ3/lJLQrvxcMYl7JI2jnDO90siPEpD8JBA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/NaturalIntelligence"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "strnum": "^2.1.0"
      },
      "bin": {
        "fxparser": "src/cli/cli.js"
      }
    },
    "node_modules/finalhandler": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.0.tgz",
      "integrity": "sha512-/t88Ty3d5JWQbWYgaOGCCYfXRwV1+be02WqYYlL6h0lEiUAMPM8o8qKGO01YIkOHzka2up08wvgYD0mDiI+q3Q==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "on-finished": "^2.4.1",
        "parseurl": "^1.3.3",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.5",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
      "integrity": "sha512-8RipRLol37bNs2bhoV67fiTEvdTrbMUYcFTiy3+wuuOnUog2QBHCZWXDRijWQfAkhBj2Uf5UnVaiWwA5vdd82w==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/form-data/node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/form-data/node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz",
      "integrity": "sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/geojson-equality-ts": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/geojson-equality-ts/-/geojson-equality-ts-1.0.2.tgz",
      "integrity": "sha512-h3Ryq+0mCSN/7yLs0eDgrZhvc9af23o/QuC4aTiuuzP/MRCtd6mf5rLsLRY44jX0RPUfM8c4GqERQmlUxPGPoQ==",
      "license": "MIT",
      "dependencies": {
        "@types/geojson": "^7946.0.14"
      }
    },
    "node_modules/geojson-polygon-self-intersections": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/geojson-polygon-self-intersections/-/geojson-polygon-self-intersections-1.2.1.tgz",
      "integrity": "sha512-/QM1b5u2d172qQVO//9CGRa49jEmclKEsYOQmWP9ooEjj63tBM51m2805xsbxkzlEELQ2REgTf700gUhhlegxA==",
      "license": "MIT",
      "dependencies": {
        "rbush": "^2.0.1"
      }
    },
    "node_modules/geojson-polygon-self-intersections/node_modules/quickselect": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/quickselect/-/quickselect-1.1.1.tgz",
      "integrity": "sha512-qN0Gqdw4c4KGPsBOQafj6yj/PA6c/L63f6CaZ/DCF/xF4Esu3jVmKLUDYxghFx8Kb/O7y9tI7x2RjTSXwdK1iQ==",
      "license": "ISC"
    },
    "node_modules/geojson-polygon-self-intersections/node_modules/rbush": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/rbush/-/rbush-2.0.2.tgz",
      "integrity": "sha512-XBOuALcTm+O/H8G90b6pzu6nX6v2zCKiFG4BJho8a+bY6AER6t8uQUZdi5bomQc0AprCWhEGa7ncAbbRap0bRA==",
      "license": "MIT",
      "dependencies": {
        "quickselect": "^1.0.1"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/giget": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/giget/-/giget-2.0.0.tgz",
      "integrity": "sha512-L5bGsVkxJbJgdnwyuheIunkGatUF/zssUoxxjACCseZYAVbaqdh9Tsmmlkl8vYan09H7sbvKt4pS8GqKLBrEzA==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "citty": "^0.1.6",
        "consola": "^3.4.0",
        "defu": "^6.1.4",
        "node-fetch-native": "^1.6.6",
        "nypm": "^0.6.0",
        "pathe": "^2.0.3"
      },
      "bin": {
        "giget": "dist/cli.mjs"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/http-errors/node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/http-proxy-agent": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-7.0.2.tgz",
      "integrity": "sha512-T1gkAiYYDWYx3V5Bmyu7HcfcvL7mUrTWiM6yOfa3PIphViJ/gFPbvidQ+veqSOHci/PxBcDabeUNCzpOODJZig==",
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.7.0.tgz",
      "integrity": "sha512-cf6L2Ds3h57VVmkZe+Pn+5APsT7FpqJtEhhieDCvrE2MK5Qk9MyffgQyuxQTm6BChfeZNtcOLHp9IcWRVcIcBQ==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-promise": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz",
      "integrity": "sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==",
      "license": "MIT"
    },
    "node_modules/jiti": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-2.6.1.tgz",
      "integrity": "sha512-ekilCSN1jwRvIbgeg/57YFh8qQDNbwDb9xT/qu2DAHbFFZUicIl4ygVaAvzveMhMVr3LnpSKTNnwt8PoOfmKhQ==",
      "devOptional": true,
      "license": "MIT",
      "bin": {
        "jiti": "lib/jiti-cli.mjs"
      }
    },
    "node_modules/json2csv": {
      "version": "6.0.0-alpha.2",
      "resolved": "https://registry.npmjs.org/json2csv/-/json2csv-6.0.0-alpha.2.tgz",
      "integrity": "sha512-nJ3oP6QxN8z69IT1HmrJdfVxhU1kLTBVgMfRnNZc37YEY+jZ4nU27rBGxT4vaqM/KUCavLRhntmTuBFqZLBUcA==",
      "license": "MIT",
      "dependencies": {
        "@streamparser/json": "^0.0.6",
        "commander": "^6.2.0",
        "lodash.get": "^4.4.2"
      },
      "bin": {
        "json2csv": "bin/json2csv.js"
      },
      "engines": {
        "node": ">= 12",
        "npm": ">= 6.13.0"
      }
    },
    "node_modules/json2csv/node_modules/commander": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/commander/-/commander-6.2.1.tgz",
      "integrity": "sha512-U7VdrJFnJgo4xjrHpTzu0yrHPGImdsmD95ZlgYSEajAn2JKzDhDTPG9kBTefmObL2w/ngeZnilk+OV9CG3d7UA==",
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.3",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.3.tgz",
      "integrity": "sha512-MT/xP0CrubFRNLNKvxJ2BYfy53Zkm++5bX9dtuPbqAeQpTVe0MQTFhao8+Cp//EmJp244xt6Drw/GVEGCUj40g==",
      "license": "MIT",
      "dependencies": {
        "jws": "^4.0.1",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jsts": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/jsts/-/jsts-2.7.1.tgz",
      "integrity": "sha512-x2wSZHEBK20CY+Wy+BPE7MrFQHW6sIsdaGUMEqmGAio+3gFzQaBYPwLRonUfQf9Ak8pBieqj9tUofX1+WtAEIg==",
      "license": "(EDL-1.0 OR EPL-1.0)",
      "engines": {
        "node": ">= 12"
      }
    },
    "node_modules/jwa": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-2.0.1.tgz",
      "integrity": "sha512-hRF04fqJIP8Abbkq5NKGN0Bbr3JxlQ+qhZufXVr0DvujKy93ZCbXZMHDL4EOtodSbCWxOqR8MS1tXA5hwqCXDg==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/jws/-/jws-4.0.1.tgz",
      "integrity": "sha512-EKI/M/yqPncGUUh44xz0PxSidXFr/+r0pA70+gIYhjv+et7yxM+s29Y+VGDkovRofQem0fs7Uvf4+YmAdyRduA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^2.0.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/lodash.get": {
      "version": "4.4.2",
      "resolved": "https://registry.npmjs.org/lodash.get/-/lodash.get-4.4.2.tgz",
      "integrity": "sha512-z+Uw/vLuy6gQe8cfaFWD7p0wVv8fJl3mbzXh33RS+0oW2wvUqiRXiQ69gLWSLpgB5/6sU+r6BlQR0MBILadqTQ==",
      "deprecated": "This package is deprecated. Use the optional chaining (?.) operator instead.",
      "license": "MIT"
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz",
      "integrity": "sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz",
      "integrity": "sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/mime-db": {
      "version": "1.54.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz",
      "integrity": "sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-3.0.1.tgz",
      "integrity": "sha512-xRc4oEhT6eaBpU1XF7AjpOFD+xQmXNB5OVKwp4tqCuBpHLS/ZbBDrc07mYTDqVMg6PfxUjjNp85O6Cd2Z/5HWA==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "^1.54.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/mkdirp": {
      "version": "0.5.6",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
      "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.6"
      },
      "bin": {
        "mkdirp": "bin/cmd.js"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/multer": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/multer/-/multer-2.0.2.tgz",
      "integrity": "sha512-u7f2xaZ/UG8oLXHvtF/oWTRvT44p9ecwBBqTwgJVq0+4BW1g8OW01TyMEGWBHbyMOYVHXslaut7qEQ1meATXgw==",
      "license": "MIT",
      "dependencies": {
        "append-field": "^1.0.0",
        "busboy": "^1.6.0",
        "concat-stream": "^2.0.0",
        "mkdirp": "^0.5.6",
        "object-assign": "^4.1.1",
        "type-is": "^1.6.18",
        "xtend": "^4.0.2"
      },
      "engines": {
        "node": ">= 10.16.0"
      }
    },
    "node_modules/multer/node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/multer/node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/multer/node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/multer/node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "license": "MIT",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/negotiator": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz",
      "integrity": "sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-fetch-native": {
      "version": "1.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch-native/-/node-fetch-native-1.6.7.tgz",
      "integrity": "sha512-g9yhqoedzIUm0nTnTqAQvueMPVOuIY16bqgAJJC8XOOubYFNwz6IER9qs0Gq2Xd0+CecCKFjtdDTMA4u4xG06Q==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/nodemailer": {
      "version": "7.0.11",
      "resolved": "https://registry.npmjs.org/nodemailer/-/nodemailer-7.0.11.tgz",
      "integrity": "sha512-gnXhNRE0FNhD7wPSCGhdNh46Hs6nm+uTyg+Kq0cZukNQiYdnCsoQjodNP9BQVG9XrcK/v6/MgpAPBUFyzh9pvw==",
      "license": "MIT-0",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/nypm": {
      "version": "0.6.2",
      "resolved": "https://registry.npmjs.org/nypm/-/nypm-0.6.2.tgz",
      "integrity": "sha512-7eM+hpOtrKrBDCh7Ypu2lJ9Z7PNZBdi/8AT3AX8xoCj43BBVHD0hPSTEvMtkMpfs8FCqBGhxB+uToIQimA111g==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "citty": "^0.1.6",
        "consola": "^3.4.2",
        "pathe": "^2.0.3",
        "pkg-types": "^2.3.0",
        "tinyexec": "^1.0.1"
      },
      "bin": {
        "nypm": "dist/cli.mjs"
      },
      "engines": {
        "node": "^14.16.0 || >=16.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/ohash": {
      "version": "2.0.11",
      "resolved": "https://registry.npmjs.org/ohash/-/ohash-2.0.11.tgz",
      "integrity": "sha512-RdR9FQrFwNBNXAr4GixM8YaRZRJ5PUWbKYbE5eOsrwAjJW0q2REGcf79oYPsLyskQCZG1PLN+S/K1V00joZAoQ==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "8.3.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.3.0.tgz",
      "integrity": "sha512-7jdwVIRtsP8MYpdXSwOS0YdD0Du+qOoF/AEPIt88PcCFrZCzx41oxku1jD88hZBwbNUIEfpqvuhjFaMAqMTWnA==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/pathe": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-2.0.3.tgz",
      "integrity": "sha512-WUjGcAqP1gQacoQe+OBJsFA7Ld4DyXuUIjZ5cc75cLHvJ7dtNsTugphxIADwspS+AraAUePCKrSVtPLFj/F88w==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/perfect-debounce": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/perfect-debounce/-/perfect-debounce-1.0.0.tgz",
      "integrity": "sha512-xCy9V055GLEqoFaHoC1SoLIaLmWctgCUaBaWxDZ7/Zx4CTyX7cJQLJOok/orfjZAh9kEYpjJa4d0KcJmCbctZA==",
      "devOptional": true,
      "license": "MIT"
    },
    "node_modules/pkg-types": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/pkg-types/-/pkg-types-2.3.0.tgz",
      "integrity": "sha512-SIqCzDRg0s9npO5XQ3tNZioRY1uK06lA41ynBC1YmFTmnY6FjUjVt6s4LoADmwoig1qqD0oK8h1p/8mlMx8Oig==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "confbox": "^0.2.2",
        "exsolve": "^1.0.7",
        "pathe": "^2.0.3"
      }
    },
    "node_modules/point-in-polygon": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/point-in-polygon/-/point-in-polygon-1.1.0.tgz",
      "integrity": "sha512-3ojrFwjnnw8Q9242TzgXuTD+eKiutbzyslcq1ydfu82Db2y+Ogbmyrkpv0Hgj31qwT3lbS9+QAAO/pIQM35XRw==",
      "license": "MIT"
    },
    "node_modules/point-in-polygon-hao": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/point-in-polygon-hao/-/point-in-polygon-hao-1.2.4.tgz",
      "integrity": "sha512-x2pcvXeqhRHlNRdhLs/tgFapAbSSe86wa/eqmj1G6pWftbEs5aVRJhRGM6FYSUERKu0PjekJzMq0gsI2XyiclQ==",
      "license": "MIT",
      "dependencies": {
        "robust-predicates": "^3.0.2"
      }
    },
    "node_modules/point-in-polygon-hao/node_modules/robust-predicates": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/robust-predicates/-/robust-predicates-3.0.2.tgz",
      "integrity": "sha512-IXgzBWvWQwE6PrDI05OvmXUIruQTcoMDzRsOd5CDvHCVLcLHMTSYvOK5Cm46kWqlV3yAbuSpBZdJ5oP5OUoStg==",
      "license": "Unlicense"
    },
    "node_modules/polyclip-ts": {
      "version": "0.16.8",
      "resolved": "https://registry.npmjs.org/polyclip-ts/-/polyclip-ts-0.16.8.tgz",
      "integrity": "sha512-JPtKbDRuPEuAjuTdhR62Gph7Is2BS1Szx69CFOO3g71lpJDFo78k4tFyi+qFOMVPePEzdSKkpGU3NBXPHHjvKQ==",
      "license": "MIT",
      "dependencies": {
        "bignumber.js": "^9.1.0",
        "splaytree-ts": "^1.0.2"
      }
    },
    "node_modules/prisma": {
      "version": "6.19.0",
      "resolved": "https://registry.npmjs.org/prisma/-/prisma-6.19.0.tgz",
      "integrity": "sha512-F3eX7K+tWpkbhl3l4+VkFtrwJlLXbAM+f9jolgoUZbFcm1DgHZ4cq9AgVEgUym2au5Ad/TDLN8lg83D+M10ycw==",
      "devOptional": true,
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/config": "6.19.0",
        "@prisma/engines": "6.19.0"
      },
      "bin": {
        "prisma": "build/index.js"
      },
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/pure-rand": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/pure-rand/-/pure-rand-6.1.0.tgz",
      "integrity": "sha512-bVWawvoZoBYpp6yIoQtQXHZjmz35RSVHnUOTefl8Vcjr8snTPY1wnpSPMWekcFwbxI6gtmT7rSYPFvz71ldiOA==",
      "devOptional": true,
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/dubzzz"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/fast-check"
        }
      ],
      "license": "MIT"
    },
    "node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/quickselect": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/quickselect/-/quickselect-2.0.0.tgz",
      "integrity": "sha512-RKJ22hX8mHe3Y6wH/N3wCM6BWtjaxIyyUIkpHOvfFnxdI4yD4tBXEBKSbriGujF6jnSVkJrffuo6vxACiSSxIw==",
      "license": "ISC"
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.1.tgz",
      "integrity": "sha512-9G8cA+tuMS75+6G/TzW8OtLzmBDMo8p1JRxN5AZ+LAp8uxGA8V8GZm4GQ4/N5QNQEnLmg6SS7wyuSmbKepiKqA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.7.0",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/rbush": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/rbush/-/rbush-3.0.1.tgz",
      "integrity": "sha512-XRaVO0YecOpEuIvbhbpTrZgoiI6xBlz6hnlr6EHhd+0x9ase6EmeN+hdwwUaJvLcsFFQ8iWVF1GAK1yB0BWi0w==",
      "license": "MIT",
      "dependencies": {
        "quickselect": "^2.0.0"
      }
    },
    "node_modules/rc9": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/rc9/-/rc9-2.1.2.tgz",
      "integrity": "sha512-btXCnMmRIBINM2LDZoEmOogIZU7Qe7zn4BpomSKZ/ykbLObuBdvG+mFq11DL6fjH1DRwHhrlgtYWG96bJiC7Cg==",
      "devOptional": true,
      "license": "MIT",
      "dependencies": {
        "defu": "^6.1.4",
        "destr": "^2.0.3"
      }
    },
    "node_modules/readable-stream": {
      "version": "3.6.2",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
      "integrity": "sha512-9u/sniCrY3D5WdsERHzHE4G2YCXqoG5FTHUiCC4SIbr6XcLZBY05ya9EKjYek9O5xOAwjGq+1JdGBAS7Q9ScoA==",
      "license": "MIT",
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/readdirp": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-4.1.2.tgz",
      "integrity": "sha512-GDhwkLfywWL2s6vEjyhri+eXmfH6j1L7JE27WhqLeYzoh/A3DBaYGEj2H/HFZCn/kMfim73FXxEJTw06WtxQwg==",
      "devOptional": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14.18.0"
      },
      "funding": {
        "type": "individual",
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/redis": {
      "version": "5.10.0",
      "resolved": "https://registry.npmjs.org/redis/-/redis-5.10.0.tgz",
      "integrity": "sha512-0/Y+7IEiTgVGPrLFKy8oAEArSyEJkU0zvgV5xyi9NzNQ+SLZmyFbUsWIbgPcd4UdUh00opXGKlXJwMmsis5Byw==",
      "license": "MIT",
      "dependencies": {
        "@redis/bloom": "5.10.0",
        "@redis/client": "5.10.0",
        "@redis/json": "5.10.0",
        "@redis/search": "5.10.0",
        "@redis/time-series": "5.10.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/robust-predicates": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/robust-predicates/-/robust-predicates-2.0.4.tgz",
      "integrity": "sha512-l4NwboJM74Ilm4VKfbAtFeGq7aEjWL+5kVFcmgFA2MrdnQWx9iE/tUGvxY5HyMI7o/WpSIUFLbC5fbeaHgSCYg==",
      "license": "Unlicense"
    },
    "node_modules/router": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/router/-/router-2.2.0.tgz",
      "integrity": "sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "depd": "^2.0.0",
        "is-promise": "^4.0.0",
        "parseurl": "^1.3.3",
        "path-to-regexp": "^8.0.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.3",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.3.tgz",
      "integrity": "sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/send/-/send-1.2.0.tgz",
      "integrity": "sha512-uaW0WwXKpL9blXE2o0bRhoL2EGXIrZxQ2ZQ4mgcfoBxdFmQold+qWsD2jLrfZ0trjKL6vOw0j//eAwcALFjKSw==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.3.5",
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "etag": "^1.8.1",
        "fresh": "^2.0.0",
        "http-errors": "^2.0.0",
        "mime-types": "^3.0.1",
        "ms": "^2.1.3",
        "on-finished": "^2.4.1",
        "range-parser": "^1.2.1",
        "statuses": "^2.0.1"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/serve-static": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-2.2.0.tgz",
      "integrity": "sha512-61g9pCh0Vnh7IutZjtLGGpTA355+OPn2TyDv/6ivP2h/AdAVX9azsoxmg2/M6nZeQZNYBEwIcsne1mJd9oQItQ==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "^2.0.0",
        "escape-html": "^1.0.3",
        "parseurl": "^1.3.3",
        "send": "^1.2.0"
      },
      "engines": {
        "node": ">= 18"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/skmeans": {
      "version": "0.9.7",
      "resolved": "https://registry.npmjs.org/skmeans/-/skmeans-0.9.7.tgz",
      "integrity": "sha512-hNj1/oZ7ygsfmPZ7ZfN5MUBRoGg1gtpnImuJBgLO0ljQ67DtJuiQaiYdS4lUA6s0KCwnPhGivtC/WRwIZLkHyg==",
      "license": "MIT"
    },
    "node_modules/splaytree-ts": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/splaytree-ts/-/splaytree-ts-1.0.2.tgz",
      "integrity": "sha512-0kGecIZNIReCSiznK3uheYB8sbstLjCZLiwcQwbmLhgHJj2gz6OnSPkVzJQCMnmEz1BQ4gPK59ylhBoEWOhGNA==",
      "license": "BDS-3-Clause"
    },
    "node_modules/statuses": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
      "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/streamsearch": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-1.1.0.tgz",
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/strnum": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/strnum/-/strnum-2.1.1.tgz",
      "integrity": "sha512-7ZvoFTiCnGxBtDqJ//Cu6fWtZtc7Y3x+QOirG15wztbdngGSkht27o2pyGWrVy0b4WAy3jbKmnoK6g5VlVNUUw==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/NaturalIntelligence"
        }
      ],
      "license": "MIT"
    },
    "node_modules/sweepline-intersections": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/sweepline-intersections/-/sweepline-intersections-1.5.0.tgz",
      "integrity": "sha512-AoVmx72QHpKtItPu72TzFL+kcYjd67BPLDoR0LarIk+xyaRg+pDTMFXndIEvZf9xEKnJv6JdhgRMnocoG0D3AQ==",
      "license": "MIT",
      "dependencies": {
        "tinyqueue": "^2.0.0"
      }
    },
    "node_modules/sweepline-intersections/node_modules/tinyqueue": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/tinyqueue/-/tinyqueue-2.0.3.tgz",
      "integrity": "sha512-ppJZNDuKGgxzkHihX8v9v9G5f+18gzaTfrukGrq6ueg0lmH4nqVnA2IPG0AEH3jKEk2GRJCUhDoqpoiw3PHLBA==",
      "license": "ISC"
    },
    "node_modules/tinyexec": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/tinyexec/-/tinyexec-1.0.2.tgz",
      "integrity": "sha512-W/KYk+NFhkmsYpuHq5JykngiOCnxeVL8v8dFnqxSD8qEEdRfXk1SDM6JzNqcERbcGYj9tMrDQBYV9cjgnunFIg==",
      "devOptional": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/tinyqueue": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/tinyqueue/-/tinyqueue-3.0.0.tgz",
      "integrity": "sha512-gRa9gwYU3ECmQYv3lslts5hxuIa90veaEcxDYuu3QGOIAEM2mOZkVHp48ANJuu1CURtRdHKUBY5Lm1tHV+sD4g==",
      "license": "ISC"
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/topojson-client": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/topojson-client/-/topojson-client-3.1.0.tgz",
      "integrity": "sha512-605uxS6bcYxGXw9qi62XyrV6Q3xwbndjachmNxu8HWTtVPxZfEJN9fd/SZS1Q54Sn2y0TMyMxFj/cJINqGHrKw==",
      "license": "ISC",
      "dependencies": {
        "commander": "2"
      },
      "bin": {
        "topo2geo": "bin/topo2geo",
        "topomerge": "bin/topomerge",
        "topoquantize": "bin/topoquantize"
      }
    },
    "node_modules/topojson-server": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/topojson-server/-/topojson-server-3.0.1.tgz",
      "integrity": "sha512-/VS9j/ffKr2XAOjlZ9CgyyeLmgJ9dMwq6Y0YEON8O7p/tGGk+dCWnrE03zEdu7i4L7YsFZLEPZPzCvcB7lEEXw==",
      "license": "ISC",
      "dependencies": {
        "commander": "2"
      },
      "bin": {
        "geo2topo": "bin/geo2topo"
      }
    },
    "node_modules/ts-node": {
      "version": "10.9.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-is": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz",
      "integrity": "sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==",
      "license": "MIT",
      "dependencies": {
        "content-type": "^1.0.5",
        "media-typer": "^1.1.0",
        "mime-types": "^3.0.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typedarray": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/typedarray/-/typedarray-0.0.6.tgz",
      "integrity": "sha512-/aCDEGatGvZ2BIk+HmLf4ifCJFwvKFNb9/JeZPMulfgFracn9QFcAf5GO8B/mweUjSoblS5In0cWhqpfs/5PQA==",
      "license": "MIT"
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "devOptional": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "7.16.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.16.0.tgz",
      "integrity": "sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==",
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/uuid": {
      "version": "13.0.0",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-13.0.0.tgz",
      "integrity": "sha512-XQegIaBTVUjSHliKqcnFqYypAd4S+WCYt5NIeRs6w/UAry7z8Y9j5ZwRRL4kzq9U3sD6v+85er9FvkEaBpji2w==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "license": "MIT",
      "bin": {
        "uuid": "dist-node/bin/uuid"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/xtend": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.2.tgz",
      "integrity": "sha512-LKYU1iAXJXUgAXn9URjiu+MWhyUXHsvfp7mcuYm9dSUKK0/CjtrUwFAxD82/mCWbtLsGjFIad0wIsod4zrTAEQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4"
      }
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    }
  }
}

</code>

## segfault-backend\package.json
<code>
{
  "name": "segfault-backend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "ts-node src/index.ts",
    "build": "tsc",
    "start": "node dist/src/index.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@azure/storage-blob": "^12.29.1",
    "@azure/storage-queue": "^12.28.1",
    "@prisma/client": "^6.19.0",
    "@turf/turf": "^7.3.1",
    "@types/nodemailer": "^7.0.4",
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "json2csv": "^6.0.0-alpha.2",
    "jsonwebtoken": "^9.0.3",
    "multer": "^2.0.2",
    "nodemailer": "^7.0.11",
    "redis": "^5.10.0",
    "tinyqueue": "^3.0.0",
    "uuid": "^13.0.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.10",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.5",
    "@types/json2csv": "^5.0.7",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/multer": "^2.0.0",
    "@types/node": "^24.10.0",
    "@types/uuid": "^10.0.0",
    "prisma": "^6.19.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  },
  "type": "module"
}

</code>

## segfault-backend\tsconfig.json
<code>
{
  // Visit https://aka.ms/tsconfig to read more about this file
  "compilerOptions": {
    // File Layout
    // "rootDir": "./src",
    "outDir": "./dist",

    // Environment Settings
    // See also https://aka.ms/tsconfig/module
    "module": "esnext",
    "target": "esnext",
    "types": ["node"],
    // For nodejs:
    // "lib": ["esnext"],
    // "types": ["node"],
    // and npm install -D @types/node

    // Other Outputs
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,

    // Stricter Typechecking Options
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,

    // Style Options
    // "noImplicitReturns": true,
    // "noImplicitOverride": true,
    // "noUnusedLocals": true,
    // "noUnusedParameters": true,
    // "noFallthroughCasesInSwitch": true,
    // "noPropertyAccessFromIndexSignature": true,

    // Recommended Options
    "strict": true,
    "jsx": "react-jsx",
    "verbatimModuleSyntax": true,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true,
    "moduleResolution": "bundler"
  }
}

</code>

## segfault-backend\prisma\schema.prisma
<code>
generator client {
  provider = "prisma-client"
  binaryTargets = ["native", "windows", "darwin-arm64"]
  output   = "../src/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url  	    = env("DATABASE_URL")
}

// Primary user stuff
enum UserRole {
  USER
  ADMIN
  GUEST
  PIGS // Government officials (.gov.in emails)
}

model User {
  id        Int       @id @default(autoincrement())
  email     String    @unique
  emailVerified Boolean @default(false)
  password  String
  name      String?
  picture   String?
  createdAt DateTime  @default(now())

  issues    Issue[]
  comments Comment[]
  commentUpvotes CommentUpvote[]
  issueUpvotes IssueUpvote[]
  resolutionVotes IssueResolutionVote[]

  role     UserRole  @default(USER)
  isBanned Boolean   @default(false)
  banExpiresAt DateTime?
  banReason  String?

  credibility Int      @default(0)
  badges UserBadge[]

  notifications Notification[]
}

// Would this need an image?
model UserBadge {
  id        Int      @id @default(autoincrement())
  name      String
  awardedAt DateTime @default(now())

  userId    Int
  user      User     @relation(fields: [userId], references: [id])
}

// Support for guest- store this in local storage
model GuestToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  createdAt DateTime @default(now())

  issues    Issue[]
}

// Issue stuff

model Issue {
  id          Int          @id @default(autoincrement())
  title       String
  description String
  location    Unsupported("geometry(Point, 4326)")?
  status      IssueStatus  @default(PENDING)
  authorized   IssueAuthorized @default(FALSE)
  error       IssueError   @default(PENDING)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @default(now()) @updatedAt
  severity    Int?

  imageBlobId String?

  userId      Int
  user        User         @relation(fields: [userId], references: [id])
  comments    Comment[]

  guestTokenId Int?
  guestToken   GuestToken? @relation(fields: [guestTokenId], references: [id])

  upvotes     IssueUpvote[]
  resolutionVotes IssueResolutionVote[]

  issueType  IssueType

  @@index([issueType])
  @@index([userId])
  // PostGIS GIST index is created via raw SQL migration
}

enum IssueStatus {
  PENDING
  IN_PROGRESS
  RESOLVED
}

enum IssueAuthorized {
  TRUE
  FALSE
}

enum IssueError {
  NONE
  INVALID_LOCATION
  INAPPROPRIATE_CONTENT
  PENDING
}

model IssueUpvote {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())

  issueId   Int
  issue     Issue    @relation(fields: [issueId], references: [id])

  userId    Int
  user      User     @relation(fields: [userId], references: [id])

  @@unique([issueId, userId])
}

// Each vote for an issue
model IssueResolutionVote {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  isResolved Boolean

  issueId   Int
  issue     Issue @relation(fields: [issueId], references: [id])

  userId    Int
  user      User @relation(fields: [userId], references: [id])

  @@unique([issueId, userId])
}


enum IssueType {
  POTHOLE
  ROAD_DAMAGE
  STREETLIGHT_FAULT
  GARBAGE_UNCOLLECTED
  ILLEGAL_DUMPING
  DRAINAGE_BLOCKED
  SEWAGE_OVERFLOW
  WATER_SUPPLY_ISSUE
  LOW_WATER_PRESSURE
  OPEN_MANHOLE
  BROKEN_FOOTPATH
  ILLEGAL_ENCROACHMENT
  STRAY_CATTLE
  TREE_FALL
  TRAFFIC_LIGHT_FAULT
  MOSQUITO_BREEDING
  NOISE_COMPLAINT
  BUILDING_SAFETY
}



model Comment {
  id        Int      @id @default(autoincrement())
  content   String
  createdAt DateTime @default(now())

  issueId   Int
  issue     Issue    @relation(fields: [issueId], references: [id])

  userId    Int
  user      User     @relation(fields: [userId], references: [id])

  upvotes   CommentUpvote[]

  isFlagged Boolean @default(false)
  flaggedReason String?
  isSystemGenerated Boolean @default(false)
}

model CommentUpvote {
  id        Int      @id @default(autoincrement())

  commentId Int
  comment   Comment  @relation(fields: [commentId], references: [id])

  userId    Int
  user      User     @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())

  @@unique([commentId, userId])
}


model Notification {
  id        Int      @id @default(autoincrement())
  type      NotificationType @default(GENERAL)
  message   String
  createdAt DateTime @default(now())
  read      Boolean  @default(false)

  userId    Int?
  user      User?    @relation(fields: [userId], references: [id])
}

enum NotificationType {
  ISSUE_STATUS_UPDATE
  NEW_COMMENT
  GENERAL
  BAN_NOTICE
  REMOVAL_NOTICE
  UPVOTE_RECEIVED
}

// Road network graph for pathfinding
model GraphNode {
  id        String      @id @default(uuid())
  osmId     String      @unique // OSM node ID as string to avoid BigInt serialization issues
  latitude  Float
  longitude Float
  outgoing  GraphEdge[] @relation("StartNode")
  incoming  GraphEdge[] @relation("EndNode")

  @@index([latitude, longitude])
}

model GraphEdge {
  id          String    @id @default(uuid())
  startNodeId String
  endNodeId   String
  startNode   GraphNode @relation("StartNode", fields: [startNodeId], references: [id])
  endNode     GraphNode @relation("EndNode", fields: [endNodeId], references: [id])

  distance    Float     // In meters
  baseCost    Float     // Usually same as distance
  penalty     Float     @default(1.0) // Multiplier: 1.0 = normal, higher = avoid

  @@index([startNodeId])
  @@index([endNodeId])
}
</code>

## segfault-backend\prisma\migrations\migration_lock.toml
<code>
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"

</code>

## segfault-backend\prisma\migrations\20251118041118_init\migration.sql
<code>
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('USER', 'ADMIN', 'GUEST', 'PIGS');

-- CreateEnum
CREATE TYPE "IssueStatus" AS ENUM ('PENDING', 'IN_PROGRESS', 'RESOLVED');

-- CreateEnum
CREATE TYPE "IssueAuthorized" AS ENUM ('TRUE', 'FALSE');

-- CreateEnum
CREATE TYPE "IssueError" AS ENUM ('NONE', 'INVALID_LOCATION', 'INAPPROPRIATE_CONTENT', 'PENDING');

-- CreateEnum
CREATE TYPE "IssueType" AS ENUM ('POTHOLE', 'ROAD_DAMAGE', 'STREETLIGHT_FAULT', 'GARBAGE_UNCOLLECTED', 'ILLEGAL_DUMPING', 'DRAINAGE_BLOCKED', 'SEWAGE_OVERFLOW', 'WATER_SUPPLY_ISSUE', 'LOW_WATER_PRESSURE', 'OPEN_MANHOLE', 'BROKEN_FOOTPATH', 'ILLEGAL_ENCROACHMENT', 'STRAY_CATTLE', 'TREE_FALL', 'TRAFFIC_LIGHT_FAULT', 'MOSQUITO_BREEDING', 'NOISE_COMPLAINT', 'BUILDING_SAFETY');

-- CreateEnum
CREATE TYPE "NotificationType" AS ENUM ('ISSUE_STATUS_UPDATE', 'NEW_COMMENT', 'GENERAL', 'BAN_NOTICE', 'REMOVAL_NOTICE', 'UPVOTE_RECEIVED');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "role" "UserRole" NOT NULL DEFAULT 'USER',
    "isBanned" BOOLEAN NOT NULL DEFAULT false,
    "banExpiresAt" TIMESTAMP(3),
    "banReason" TEXT,
    "credibility" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "UserBadge" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "awardedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "userId" INTEGER NOT NULL,

    CONSTRAINT "UserBadge_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "GuestToken" (
    "id" SERIAL NOT NULL,
    "token" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "GuestToken_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Issue" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "latitude" DOUBLE PRECISION NOT NULL,
    "longitude" DOUBLE PRECISION NOT NULL,
    "status" "IssueStatus" NOT NULL DEFAULT 'PENDING',
    "authorized" "IssueAuthorized" NOT NULL DEFAULT 'FALSE',
    "error" "IssueError" NOT NULL DEFAULT 'PENDING',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "imageBlobId" TEXT,
    "userId" INTEGER NOT NULL,
    "guestTokenId" INTEGER,
    "issueType" "IssueType" NOT NULL,

    CONSTRAINT "Issue_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "IssueUpvote" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "issueId" INTEGER NOT NULL,
    "userId" INTEGER NOT NULL,

    CONSTRAINT "IssueUpvote_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "IssueResolutionVote" (
    "id" SERIAL NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "isResolved" BOOLEAN NOT NULL,
    "issueId" INTEGER NOT NULL,
    "userId" INTEGER NOT NULL,

    CONSTRAINT "IssueResolutionVote_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Comment" (
    "id" SERIAL NOT NULL,
    "content" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "issueId" INTEGER NOT NULL,
    "userId" INTEGER NOT NULL,
    "isFlagged" BOOLEAN NOT NULL DEFAULT false,
    "flaggedReason" TEXT,

    CONSTRAINT "Comment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "CommentUpvote" (
    "id" SERIAL NOT NULL,
    "commentId" INTEGER NOT NULL,
    "userId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "CommentUpvote_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Notification" (
    "id" SERIAL NOT NULL,
    "type" "NotificationType" NOT NULL DEFAULT 'GENERAL',
    "message" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "read" BOOLEAN NOT NULL DEFAULT false,
    "userId" INTEGER,

    CONSTRAINT "Notification_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "GuestToken_token_key" ON "GuestToken"("token");

-- CreateIndex
CREATE INDEX "Issue_issueType_idx" ON "Issue"("issueType");

-- CreateIndex
CREATE INDEX "Issue_userId_idx" ON "Issue"("userId");

-- CreateIndex
CREATE INDEX "Issue_latitude_longitude_idx" ON "Issue"("latitude", "longitude");

-- CreateIndex
CREATE UNIQUE INDEX "IssueUpvote_issueId_userId_key" ON "IssueUpvote"("issueId", "userId");

-- CreateIndex
CREATE UNIQUE INDEX "IssueResolutionVote_issueId_userId_key" ON "IssueResolutionVote"("issueId", "userId");

-- CreateIndex
CREATE UNIQUE INDEX "CommentUpvote_commentId_userId_key" ON "CommentUpvote"("commentId", "userId");

-- AddForeignKey
ALTER TABLE "UserBadge" ADD CONSTRAINT "UserBadge_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Issue" ADD CONSTRAINT "Issue_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Issue" ADD CONSTRAINT "Issue_guestTokenId_fkey" FOREIGN KEY ("guestTokenId") REFERENCES "GuestToken"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "IssueUpvote" ADD CONSTRAINT "IssueUpvote_issueId_fkey" FOREIGN KEY ("issueId") REFERENCES "Issue"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "IssueUpvote" ADD CONSTRAINT "IssueUpvote_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "IssueResolutionVote" ADD CONSTRAINT "IssueResolutionVote_issueId_fkey" FOREIGN KEY ("issueId") REFERENCES "Issue"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "IssueResolutionVote" ADD CONSTRAINT "IssueResolutionVote_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_issueId_fkey" FOREIGN KEY ("issueId") REFERENCES "Issue"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Comment" ADD CONSTRAINT "Comment_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CommentUpvote" ADD CONSTRAINT "CommentUpvote_commentId_fkey" FOREIGN KEY ("commentId") REFERENCES "Comment"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CommentUpvote" ADD CONSTRAINT "CommentUpvote_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Notification" ADD CONSTRAINT "Notification_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

</code>

## segfault-backend\prisma\migrations\20251207112012_add_graph_tables\migration.sql
<code>
-- CreateTable
CREATE TABLE "GraphNode" (
    "id" TEXT NOT NULL,
    "osmId" TEXT NOT NULL,
    "latitude" DOUBLE PRECISION NOT NULL,
    "longitude" DOUBLE PRECISION NOT NULL,

    CONSTRAINT "GraphNode_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "GraphEdge" (
    "id" TEXT NOT NULL,
    "startNodeId" TEXT NOT NULL,
    "endNodeId" TEXT NOT NULL,
    "distance" DOUBLE PRECISION NOT NULL,
    "baseCost" DOUBLE PRECISION NOT NULL,
    "penalty" DOUBLE PRECISION NOT NULL DEFAULT 1.0,

    CONSTRAINT "GraphEdge_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "GraphNode_osmId_key" ON "GraphNode"("osmId");

-- CreateIndex
CREATE INDEX "GraphNode_latitude_longitude_idx" ON "GraphNode"("latitude", "longitude");

-- CreateIndex
CREATE INDEX "GraphEdge_startNodeId_idx" ON "GraphEdge"("startNodeId");

-- CreateIndex
CREATE INDEX "GraphEdge_endNodeId_idx" ON "GraphEdge"("endNodeId");

-- AddForeignKey
ALTER TABLE "GraphEdge" ADD CONSTRAINT "GraphEdge_startNodeId_fkey" FOREIGN KEY ("startNodeId") REFERENCES "GraphNode"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "GraphEdge" ADD CONSTRAINT "GraphEdge_endNodeId_fkey" FOREIGN KEY ("endNodeId") REFERENCES "GraphNode"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

</code>

## segfault-backend\prisma\migrations\20251207122239_add_severity_and_system_comments\migration.sql
<code>
-- AlterTable
ALTER TABLE "Comment" ADD COLUMN     "isSystemGenerated" BOOLEAN NOT NULL DEFAULT false;

-- AlterTable
ALTER TABLE "Issue" ADD COLUMN     "severity" INTEGER;

</code>

## segfault-backend\prisma\migrations\20251207124829_add_issue_updated_at\migration.sql
<code>
-- AlterTable
ALTER TABLE "Issue" ADD COLUMN     "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;

</code>

## segfault-backend\scripts\createTestInteractions.ts
<code>
/**
 * Script to simulate user interactions: Upvotes, Comments, Comment Upvotes
 * Biased towards "rich-get-richer" (popular content gets more interactions)
 * Also awards points to test Badge system.
 * 
 * Run with: npx tsx scripts/createTestInteractions.ts
 */

import 'dotenv/config';
import { prisma } from '../src/data/prisma/prismaClient';
import {
    addIssueUpvote,
    addComment,
    addCommentUpvote,
    getCommentsForIssue,
    hasUserUpvotedIssue
} from '../src/data/issue';
import { awardPoints } from '../src/services/GamificationService';

const INTERACTION_COUNT = 500;

// Content for random comments
const COMMENT_TEMPLATES = [
    "This is really dangerous, please fix soon!",
    "I saw this yesterday too.",
    "Has anyone reported this to the local corporator?",
    "Upvoted for visibility.",
    "This has been here for months.",
    "Great initiative to report this.",
    "Status says pending but I saw workers there today.",
    "Can we get an update on this?",
    "This is blocking traffic badly.",
    "I tripped over this last week.",
    "Is this under PWD jurisdiction?",
    "Please prioritize this.",
    "Same situation in my colony.",
    "Thanks for reporting.",
    "Marking as urgent."
];

async function main() {
    console.log('Starting interaction simulation...');

    // 1. Fetch Users
    const users = await prisma.user.findMany({
        where: { email: { endsWith: '@gmail.com' } },
        take: 100
    });

    if (users.length === 0) {
        console.error('No test users found. Run createTestUsers.ts first.');
        return;
    }
    console.log(`Loaded ${users.length} users.`);

    // 2. Fetch Issues with stats for weighted selection
    let issues = await prisma.issue.findMany({
        select: {
            id: true,
            userId: true,
            _count: { select: { upvotes: true, comments: true } }
        }
    });

    if (issues.length === 0) {
        console.error('No issues found. Run createTestIssues.ts first.');
        return;
    }
    console.log(`Loaded ${issues.length} issues.`);

    // Helper: Select Issue Weighted
    const selectWeightedIssue = () => {
        const totalWeight = issues.reduce((sum, issue) => sum + (issue._count.upvotes + issue._count.comments + 1), 0);
        let r = Math.random() * totalWeight;
        for (const issue of issues) {
            const weight = issue._count.upvotes + issue._count.comments + 1;
            if (r < weight) return issue;
            r -= weight;
        }
        return issues[0];
    };

    let interactions = 0;
    console.log(`Starting loop for ${INTERACTION_COUNT} interactions...`);

    for (let i = 0; i < INTERACTION_COUNT; i++) {
        const issue = selectWeightedIssue();
        if (!issue) {
            console.error('Failed to select issue');
            continue;
        }

        const user = users[Math.floor(Math.random() * users.length)];
        if (!user) {
            console.error('Failed to select user');
            continue;
        }

        // Prevent acting on own issue (optional, but realistic)
        if (issue.userId === user.id) continue;

        const rand = Math.random();

        try {
            if (rand < 0.8) {
                // 80% - Upvote Issue
                const hasVoted = await hasUserUpvotedIssue(user.id, issue.id);
                if (!hasVoted) {
                    await addIssueUpvote(user.id, issue.id);
                    // Award points to Author
                    await awardPoints(issue.userId, 1);
                    // Award points to Voter? Script decision: Yes, for badge test
                    await awardPoints(user.id, 1);

                    // Update local count for weighting
                    issue._count.upvotes++;
                    interactions++;
                }
            } else if (rand < 0.95) {
                // 15% - Comment
                const template = COMMENT_TEMPLATES[Math.floor(Math.random() * COMMENT_TEMPLATES.length)];
                if (!template) continue;

                await addComment(user.id, issue.id, template);

                // Award points
                await awardPoints(user.id, 2); // Commenter
                await awardPoints(issue.userId, 2); // Author engagement

                issue._count.comments++;
                interactions++;
            } else {
                // 5% - Upvote Comment
                const comments = await getCommentsForIssue(issue.id);
                if (comments.length > 0) {
                    const comment = comments[Math.floor(Math.random() * comments.length)];
                    if (comment && comment.userId !== user.id) { // Don't upvote own
                        const existing = comment.upvotes.find(u => u.userId === user.id);
                        if (!existing) {
                            await addCommentUpvote(user.id, comment.id);
                            await awardPoints(comment.userId, 5); // Match controller logic
                            interactions++;
                        }
                    }
                }
            }

        } catch (err) {
            console.error(`Error in interaction ${i}:`, err);
        }

        if (interactions % 5 === 0 && interactions > 0) {
            console.log(`Interactions: ${interactions}/${INTERACTION_COUNT}`);
        }
    }

    console.log(`\nCompleted ${interactions} interactions.`);

    // Clear cache so map updates
    console.log('Clearing issue cache...');
    const { clearAllIssueCache } = await import('../src/services/IssueCacheService');
    await clearAllIssueCache();
    console.log('Issue cache cleared.');
}

main()
    .then(() => process.exit(0))
    .catch(e => {
        console.error('Fatal error in main:', e);
        process.exit(1);
    });

</code>

## segfault-backend\scripts\createTestIssues.ts
<code>
/**
 * Script to create fake clustered issues for test users
 * Run with: npx tsx scripts/createTestIssues.ts
 */

import 'dotenv/config';
import { loginWithEmail } from '../src/services/authService';
import { createAuthenticatedIssue } from '../src/data/issue';
import { IssueType } from '../src/generated/prisma/enums';
import jwt from 'jsonwebtoken';

// ... (names array unchanged)
const firstNames = [
    'Aarav', 'Vivaan', 'Aditya', 'Vihaan', 'Arjun', 'Sai', 'Reyansh', 'Ayaan', 'Krishna', 'Ishaan',
    'Shaurya', 'Atharva', 'Advik', 'Pranav', 'Advaith', 'Aaryan', 'Dhruv', 'Kabir', 'Ritvik', 'Darsh',
    'Ananya', 'Aadhya', 'Myra', 'Sara', 'Ira', 'Aanya', 'Pari', 'Diya', 'Navya', 'Kiara',
    'Saanvi', 'Anika', 'Prisha', 'Anvi', 'Riya', 'Aarohi', 'Siya', 'Meera', 'Kavya', 'Avni',
    'Rohan', 'Rahul', 'Amit', 'Vikram', 'Sanjay', 'Raj', 'Nikhil', 'Prateek', 'Akash', 'Deepak',
    'Pooja', 'Neha', 'Priya', 'Anjali', 'Shruti', 'Divya', 'Sneha', 'Nisha', 'Kritika', 'Tanvi',
    'Karan', 'Varun', 'Harsh', 'Yash', 'Aryan', 'Dev', 'Manish', 'Suresh', 'Ramesh', 'Gaurav',
    'Simran', 'Jyoti', 'Sakshi', 'Komal', 'Swati', 'Tanya', 'Ritu', 'Megha', 'Pallavi', 'Sonal',
    'Arun', 'Vijay', 'Manoj', 'Rakesh', 'Pankaj', 'Sumit', 'Mohit', 'Ravi', 'Ajay', 'Sandeep',
    'Shivani', 'Rani', 'Geeta', 'Sunita', 'Rekha', 'Asha', 'Lata', 'Seema', 'Usha', 'Vandana',
];

const surnames = [
    'Sharma', 'Verma', 'Gupta', 'Singh', 'Kumar', 'Patel', 'Reddy', 'Rao', 'Nair', 'Menon',
    'Iyer', 'Agarwal', 'Jain', 'Shah', 'Kapoor', 'Malhotra', 'Chopra', 'Mehra', 'Bhatia', 'Khanna',
    'Saxena', 'Sinha', 'Mishra', 'Pandey', 'Tiwari', 'Dubey', 'Shukla', 'Tripathi', 'Rastogi', 'Mathur',
    'Chauhan', 'Yadav', 'Thakur', 'Rajput', 'Rathore', 'Choudhary', 'Joshi', 'Kulkarni', 'Deshpande', 'Patil',
    'Kaur', 'Gandhi', 'Modi', 'Desai', 'Trivedi', 'Mehta', 'Parikh', 'Dave', 'Bhatt', 'Vyas',
    'Pillai', 'Kurup', 'Warrier', 'Das', 'Bose', 'Sen', 'Ghosh', 'Mukherjee', 'Banerjee', 'Chatterjee',
    'Roy', 'Dutta', 'Sarkar', 'Biswas', 'Mitra', 'Ray', 'Majumdar', 'Goswami', 'Nandi', 'Saha',
    'Hegde', 'Shetty', 'Gowda', 'Naidu', 'Varma', 'Chandra', 'Prasad', 'Murthy', 'Swamy', 'Sethi',
    'Arora', 'Tandon', 'Bajaj', 'Luthra', 'Anand', 'Suri', 'Sahni', 'Vohra', 'Grover', 'Bedi',
    'Oberoi', 'Madan', 'Ahuja', 'Dhawan', 'Kohli', 'Gill', 'Sodhi', 'Lamba', 'Walia', 'Narula',
];

const PASSWORD = 'Password@123';
const ISSUE_TYPES = Object.values(IssueType) as IssueType[];

// Delhi Bounding Box
const MIN_LAT = 28.60;
const MAX_LAT = 28.68;
const MIN_LNG = 77.18;
const MAX_LNG = 77.25;

interface Location {
    lat: number;
    lng: number;
}

const existingLocations: Location[] = [];
// ... (rest of the file)


function getRandomLocation(): Location {
    // 30% chance to pick a location near an existing issue (clustering)
    if (existingLocations.length > 0 && Math.random() < 0.3) {
        const base = existingLocations[Math.floor(Math.random() * existingLocations.length)]!;
        // Add small random offset (approx 100-500m)
        // 0.001 deg is roughly 111m
        const offsetLat = (Math.random() - 0.5) * 0.005;
        const offsetLng = (Math.random() - 0.5) * 0.005;

        return {
            lat: Math.max(MIN_LAT, Math.min(MAX_LAT, base.lat + offsetLat)),
            lng: Math.max(MIN_LNG, Math.min(MAX_LNG, base.lng + offsetLng))
        };
    }

    // Uniform random
    return {
        lat: MIN_LAT + Math.random() * (MAX_LAT - MIN_LAT),
        lng: MIN_LNG + Math.random() * (MAX_LNG - MIN_LNG)
    };
}

async function createIssues() {
    console.log('Starting to create clustered issues for 100 users...\n');
    let totalIssues = 0;
    let successCount = 0;
    let failCount = 0;

    const usedCombos = new Set<string>();

    // Optimized: Fetch users directly from DB
    const { prisma } = await import('../src/data/prisma/prismaClient');
    const users = await prisma.user.findMany({
        where: { email: { endsWith: '@gmail.com' } },
        take: 100
    });

    console.log(`Found ${users.length} users in database.`);

    let usersProcessed = 0;
    for (const user of users) {
        try {
            // 2. Create 2 issues
            for (let i = 0; i < 2; i++) {
                const loc = getRandomLocation();
                const type = ISSUE_TYPES[Math.floor(Math.random() * ISSUE_TYPES.length)]!;

                await createAuthenticatedIssue(
                    `Reported ${type.replace(/_/g, ' ').toLowerCase()}`,
                    "Test description lorem ipsum dolor sit amet, consectetur adipiscing elit.",
                    loc.lat,
                    loc.lng,
                    type,
                    user.id
                );

                existingLocations.push(loc);
                totalIssues++;
                successCount++;
            }
            usersProcessed++;
            process.stdout.write(`\rProcessed ${usersProcessed}/100 users, Created ${totalIssues} issues...`);

        } catch (err: any) {
            console.error(`\nError for user ${user.email}:`, err.message);
        }
    }

    console.log(`\n========================================`);
    console.log(`Processed: ${usersProcessed} users`);
    console.log(`Total Issues Created: ${totalIssues}`);
    console.log(`========================================`);
}

createIssues()
    .then(() => {
        console.log('\nDone!');
        process.exit(0);
    })
    .catch((err) => {
        console.error('Script failed:', err);
        process.exit(1);
    });
</code>

## segfault-backend\scripts\createTestUsers.ts
<code>
/**
 * Script to create 100 fake users via the registration API
 * Run with: npx tsx scripts/createTestUsers.ts
 */

import 'dotenv/config';
import { registerWithEmail } from '../src/services/authService';

// Lists of unique first names and surnames
const firstNames = [
    'Aarav', 'Vivaan', 'Aditya', 'Vihaan', 'Arjun', 'Sai', 'Reyansh', 'Ayaan', 'Krishna', 'Ishaan',
    'Shaurya', 'Atharva', 'Advik', 'Pranav', 'Advaith', 'Aaryan', 'Dhruv', 'Kabir', 'Ritvik', 'Darsh',
    'Ananya', 'Aadhya', 'Myra', 'Sara', 'Ira', 'Aanya', 'Pari', 'Diya', 'Navya', 'Kiara',
    'Saanvi', 'Anika', 'Prisha', 'Anvi', 'Riya', 'Aarohi', 'Siya', 'Meera', 'Kavya', 'Avni',
    'Rohan', 'Rahul', 'Amit', 'Vikram', 'Sanjay', 'Raj', 'Nikhil', 'Prateek', 'Akash', 'Deepak',
    'Pooja', 'Neha', 'Priya', 'Anjali', 'Shruti', 'Divya', 'Sneha', 'Nisha', 'Kritika', 'Tanvi',
    'Karan', 'Varun', 'Harsh', 'Yash', 'Aryan', 'Dev', 'Manish', 'Suresh', 'Ramesh', 'Gaurav',
    'Simran', 'Jyoti', 'Sakshi', 'Komal', 'Swati', 'Tanya', 'Ritu', 'Megha', 'Pallavi', 'Sonal',
    'Arun', 'Vijay', 'Manoj', 'Rakesh', 'Pankaj', 'Sumit', 'Mohit', 'Ravi', 'Ajay', 'Sandeep',
    'Shivani', 'Rani', 'Geeta', 'Sunita', 'Rekha', 'Asha', 'Lata', 'Seema', 'Usha', 'Vandana',
];

const surnames = [
    'Sharma', 'Verma', 'Gupta', 'Singh', 'Kumar', 'Patel', 'Reddy', 'Rao', 'Nair', 'Menon',
    'Iyer', 'Agarwal', 'Jain', 'Shah', 'Kapoor', 'Malhotra', 'Chopra', 'Mehra', 'Bhatia', 'Khanna',
    'Saxena', 'Sinha', 'Mishra', 'Pandey', 'Tiwari', 'Dubey', 'Shukla', 'Tripathi', 'Rastogi', 'Mathur',
    'Chauhan', 'Yadav', 'Thakur', 'Rajput', 'Rathore', 'Choudhary', 'Joshi', 'Kulkarni', 'Deshpande', 'Patil',
    'Kaur', 'Gandhi', 'Modi', 'Desai', 'Trivedi', 'Mehta', 'Parikh', 'Dave', 'Bhatt', 'Vyas',
    'Pillai', 'Kurup', 'Warrier', 'Das', 'Bose', 'Sen', 'Ghosh', 'Mukherjee', 'Banerjee', 'Chatterjee',
    'Roy', 'Dutta', 'Sarkar', 'Biswas', 'Mitra', 'Ray', 'Majumdar', 'Goswami', 'Nandi', 'Saha',
    'Hegde', 'Shetty', 'Gowda', 'Naidu', 'Varma', 'Chandra', 'Prasad', 'Murthy', 'Swamy', 'Sethi',
    'Arora', 'Tandon', 'Bajaj', 'Luthra', 'Anand', 'Suri', 'Sahni', 'Vohra', 'Grover', 'Bedi',
    'Oberoi', 'Madan', 'Ahuja', 'Dhawan', 'Kohli', 'Gill', 'Sodhi', 'Lamba', 'Walia', 'Narula',
];

const PASSWORD = 'Password@123';

async function createUsers() {
    console.log('Starting to create 100 test users...\n');

    const usedCombos = new Set<string>();
    let created = 0;
    let failed = 0;

    while (created < 100) {
        // Pick random first name and surname
        const firstName = firstNames[Math.floor(Math.random() * firstNames.length)]!;
        const surname = surnames[Math.floor(Math.random() * surnames.length)]!;
        const combo = `${firstName}.${surname}`;

        // Skip if already used
        if (usedCombos.has(combo.toLowerCase())) {
            continue;
        }
        usedCombos.add(combo.toLowerCase());

        const email = `${firstName.toLowerCase()}.${surname.toLowerCase()}@gmail.com`;
        const name = `${firstName} ${surname}`;

        try {
            await registerWithEmail(email, PASSWORD, name);
            created++;
            console.log(` Created user ${created}: ${name} (${email})`);
        } catch (err: any) {
            if (err.message?.includes('already exists')) {
                console.log(` User already exists: ${email}`);
            } else {
                failed++;
                console.error(` Failed to create ${email}:`, err.message);
            }
        }
    }

    console.log(`\n========================================`);
    console.log(`Created: ${created} users`);
    console.log(`Failed: ${failed} users`);
    console.log(`========================================`);
    console.log(`\nAll users have password: ${PASSWORD}`);
}

createUsers()
    .then(() => {
        console.log('\nDone!');
        process.exit(0);
    })
    .catch((err) => {
        console.error('Script failed:', err);
        process.exit(1);
    });

</code>

## segfault-backend\src\appconfig.ts
<code>
export const FRONTEND_URL = 'https://segfault-frontend.politeriver-a25e3b65.westeurope.azurecontainerapps.io';

export const GOOGLE_OAUTH = {
	CLIENT_ID: process.env.GOOGLE_CLIENT_ID ?? '1030819278738-1fnklv7adb14ktovidi3ate2rlbhbe53.apps.googleusercontent.com',
	CLIENT_SECRET: process.env.GOOGLE_CLIENT_SECRET ?? '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',
	REDIRECT_URI: 'https://segfault-backend.politeriver-a25e3b65.westeurope.azurecontainerapps.io/auth/callback',
};

export const JWT = {
	SECRET: process.env.JWT_SECRET ?? 'CHANGE_THIS_JWT_SECRET',
};

export default { FRONTEND_URL, GOOGLE_OAUTH, JWT };

</code>

## segfault-backend\src\index.ts
<code>
import "dotenv/config";
import express from "express";
import cors from "cors";
import cookieParser from "cookie-parser";
import authRoutes from "./api/routes/authRoutes";
import issueRoutes from "./api/routes/issueRoutes";
import commentRoutes from "./api/routes/commentRoutes";
import notificationRoutes from "./api/routes/notificationRoutes";
import routeRoutes from "./api/routes/routeRoutes";
import analyticsRoutes from "./api/routes/analyticsRoutes";
import userRoutes from "./api/routes/userRoutes";
import adminRoutes from "./api/routes/adminRoutes";
import { FRONTEND_URL } from "./appconfig";


// TODO check this
process.on('uncaughtException', (err) => {
    console.error('Uncaught Exception:', err);
});
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});
process.on('exit', (code) => {
    console.log(`Process exiting with code: ${code}`);
});
// --

const app = express();
const port = 3000;

app.use(cors({
    origin: true,
    credentials: true
}));
app.use(cookieParser());
app.use(express.json());

app.get("/", (_req, res) => {
    res.send("Public Issues Tracker API");
});

app.use("/auth", authRoutes);
app.use("/issues", issueRoutes);
app.use("/", commentRoutes);
app.use("/notifications", notificationRoutes);
app.use("/api/route", routeRoutes);
app.use("/api/analytics", analyticsRoutes);
app.use("/api/user", userRoutes);
app.use("/admin", adminRoutes);

app.listen(port, "0.0.0.0", () => {
    console.log(`Server running at http://0.0.0.0:${port}`);

    // Prevent process from exiting by keeping event loop active
    setInterval(() => { }, 1 << 30);
});

</code>

## segfault-backend\src\api\controllers\adminController.ts
<code>
import type { Request, Response } from "express";
import { prisma } from "../../data/prisma/prismaClient";
import { IssueAuthorized, IssueError, IssueStatus } from "../../generated/prisma/enums";

// Get issues pending moderation (AI errors, unauthorized, or pending severity)
export async function getModerationQueue(_req: Request, res: Response) {
    try {
        const issues = await prisma.issue.findMany({
            where: {
                OR: [
                    { error: { not: IssueError.NONE } },
                    { authorized: IssueAuthorized.FALSE },
                    { severity: { equals: null } },
                ],
            },
            orderBy: { createdAt: "desc" },
            include: {
                user: { select: { id: true, name: true, email: true } },
            },
            take: 100,
        });

        const formatted = issues.map((issue) => ({
            id: String(issue.id),
            title: issue.title,
            description: issue.description,
            type: issue.issueType,
            status: issue.status,
            error: issue.error,
            authorized: issue.authorized,
            severity: issue.severity,
            imageBlobId: issue.imageBlobId,
            createdAt: issue.createdAt.toISOString(),
            reporter: {
                id: String(issue.user.id),
                name: issue.user.name || "Unknown",
                email: issue.user.email,
            },
        }));

        return res.json(formatted);
    } catch (err) {
        console.error("Error fetching moderation queue:", err);
        return res.status(500).json({ error: "Failed to fetch moderation queue" });
    }
}

// Approve or Reject an issue
export async function resolveModeration(req: Request, res: Response) {
    try {
        const issueId = parseInt(req.params.id || "");
        const { action } = req.body;

        if (isNaN(issueId)) {
            return res.status(400).json({ error: "Invalid issue ID" });
        }

        if (action !== "APPROVE" && action !== "REJECT") {
            return res.status(400).json({ error: "Invalid action. Use APPROVE or REJECT." });
        }

        const issue = await prisma.issue.findUnique({ where: { id: issueId } });
        if (!issue) {
            return res.status(404).json({ error: "Issue not found" });
        }

        if (action === "APPROVE") {
            await prisma.issue.update({
                where: { id: issueId },
                data: {
                    authorized: IssueAuthorized.TRUE,
                    error: IssueError.NONE,
                    status: IssueStatus.PENDING,
                },
            });
            return res.json({ success: true, message: "Issue approved." });
        } else {
            // REJECT: delete the issue
            await prisma.issue.delete({ where: { id: issueId } });
            return res.json({ success: true, message: "Issue rejected and deleted." });
        }
    } catch (err) {
        console.error("Error resolving moderation:", err);
        return res.status(500).json({ error: "Failed to resolve moderation" });
    }
}

// Get all users (paginated)
export async function getUsers(req: Request, res: Response) {
    try {
        const page = parseInt(req.query.page as string) || 1;
        const pageSize = 50;
        const skip = (page - 1) * pageSize;

        const [users, total] = await prisma.$transaction([
            prisma.user.findMany({
                skip,
                take: pageSize,
                orderBy: { id: "asc" },
                select: {
                    id: true,
                    name: true,
                    email: true,
                    role: true,
                    isBanned: true,
                    createdAt: true,
                },
            }),
            prisma.user.count(),
        ]);

        const formatted = users.map((u) => ({
            id: String(u.id),
            name: u.name || "No Name",
            email: u.email,
            role: u.role,
            isBanned: u.isBanned,
            createdAt: u.createdAt.toISOString(),
        }));

        return res.json({ users: formatted, total, page, pageSize });
    } catch (err) {
        console.error("Error fetching users:", err);
        return res.status(500).json({ error: "Failed to fetch users" });
    }
}

// Ban a user
export async function banUser(req: Request, res: Response) {
    try {
        const userId = parseInt(req.params.id || "");
        const { reason } = req.body;

        if (isNaN(userId)) {
            return res.status(400).json({ error: "Invalid user ID" });
        }

        const user = await prisma.user.findUnique({ where: { id: userId } });
        if (!user) {
            return res.status(404).json({ error: "User not found" });
        }

        await prisma.user.update({
            where: { id: userId },
            data: {
                isBanned: true,
                banReason: reason || "Banned by admin",
            },
        });

        return res.json({ success: true, message: "User banned." });
    } catch (err) {
        console.error("Error banning user:", err);
        return res.status(500).json({ error: "Failed to ban user" });
    }
}

export default { getModerationQueue, resolveModeration, getUsers, banUser };

</code>

## segfault-backend\src\api\controllers\analyticsController.ts
<code>
import type { Request, Response } from "express";
import { prisma } from "../../data/prisma/prismaClient";
import { IssueStatus } from "../../generated/prisma/enums";
import { Parser } from "json2csv";

interface TrendDataPoint {
    date: string;
    reported: number;
    resolved: number;
}

function getDateRangeFilter(timeRange: string): Date {
    const now = new Date();
    switch (timeRange) {
        case "7d":
            return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        case "30d":
            return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        case "90d":
            return new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
        default:
            return new Date(0);
    }
}

function fillDateGaps(data: Map<string, { reported: number; resolved: number }>, startDate: Date, endDate: Date): TrendDataPoint[] {
    const result: TrendDataPoint[] = [];
    const current = new Date(startDate);
    current.setHours(0, 0, 0, 0);

    while (current <= endDate) {
        const dateStr = current.toISOString().split("T")[0] || "";
        const existing = data.get(dateStr) || { reported: 0, resolved: 0 };
        result.push({
            date: dateStr || "",
            reported: existing.reported,
            resolved: existing.resolved,
        });
        current.setDate(current.getDate() + 1);
    }

    return result;
}

export async function getSummary(req: Request, res: Response) {
    try {
        const timeRange = (req.query.timeRange as string) || "30d";
        const startDate = getDateRangeFilter(timeRange);
        const userId = req.user?.id;
        const isGuest = !userId || req.user?.role === "GUEST";

        let personalImpact = null;

        if (!isGuest && userId) {
            const userIssues = await prisma.issue.findMany({
                where: { userId, createdAt: { gte: startDate } },
                select: { status: true },
            });

            const issuesReported = userIssues.length;
            const issuesResolved = userIssues.filter((i) => i.status === IssueStatus.RESOLVED).length;

            personalImpact = {
                issuesReported,
                issuesResolved,
                resolutionRate: issuesReported > 0 ? Math.round((issuesResolved / issuesReported) * 100) : 0,
            };
        }

        const activeIssues = await prisma.issue.count({
            where: {
                status: { not: IssueStatus.RESOLVED },
                createdAt: { gte: startDate },
            },
        });
        console.log(`[Analytics] TimeRange: ${timeRange}, StartDate: ${startDate.toISOString()}`);
        console.log(`[Analytics] Active Issues Found: ${activeIssues}`);

        const resolvedIssues = await prisma.issue.findMany({
            where: {
                status: IssueStatus.RESOLVED,
                createdAt: { gte: startDate },
            },
            select: { createdAt: true, updatedAt: true },
        });

        let avgResolutionTimeHours = 0;
        if (resolvedIssues.length > 0) {
            const totalHours = resolvedIssues.reduce((sum, issue) => {
                const diff = issue.updatedAt.getTime() - issue.createdAt.getTime();
                return sum + diff / (1000 * 60 * 60);
            }, 0);
            avgResolutionTimeHours = Math.round(totalHours / resolvedIssues.length);
        }

        const issuesWithNegativeVotes = await prisma.issue.count({
            where: {
                status: IssueStatus.IN_PROGRESS,
                createdAt: { gte: startDate },
                resolutionVotes: {
                    some: { isResolved: false },
                },
            },
        });

        const totalResolved = resolvedIssues.length + issuesWithNegativeVotes;
        const reopenRate = totalResolved > 0 ? Math.round((issuesWithNegativeVotes / totalResolved) * 100) : 0;

        const allIssues = await prisma.issue.findMany({
            where: { createdAt: { gte: startDate } },
            select: { createdAt: true, status: true },
        });

        const trendMap = new Map<string, { reported: number; resolved: number }>();

        for (const issue of allIssues) {
            const dateStr = issue.createdAt.toISOString().split("T")[0] || "";
            const existing = trendMap.get(dateStr) || { reported: 0, resolved: 0 };
            existing.reported++;
            if (issue.status === IssueStatus.RESOLVED) {
                existing.resolved++;
            }
            trendMap.set(dateStr || "", existing);
        }

        const trend = fillDateGaps(trendMap, startDate, new Date());

        return res.json({
            personalImpact,
            communityHealth: {
                avgResolutionTimeHours,
                reopenRate,
                totalActiveIssues: activeIssues,
            },
            trend,
        });
    } catch (err) {
        console.error("Error getting analytics summary:", err);
        return res.status(500).json({ error: "Failed to get analytics" });
    }
}

export async function getHeatmap(req: Request, res: Response) {
    try {
        const minLat = parseFloat(req.query.minLat as string);
        const maxLat = parseFloat(req.query.maxLat as string);
        const minLng = parseFloat(req.query.minLng as string);
        const maxLng = parseFloat(req.query.maxLng as string);

        if ([minLat, maxLat, minLng, maxLng].some(isNaN)) {
            return res.status(400).json({ error: "Invalid bounds parameters" });
        }

        // Use PostGIS query to get issues with coordinates
        const issues = await prisma.$queryRaw<Array<{
            latitude: number;
            longitude: number;
            severity: number | null;
            createdAt: Date;
            upvote_count: bigint;
            comment_count: bigint;
        }>>`
            SELECT 
                ST_Y(i.location) as latitude,
                ST_X(i.location) as longitude,
                i.severity,
                i."createdAt",
                COALESCE(uv.upvote_count, 0) as upvote_count,
                COALESCE(cm.comment_count, 0) as comment_count
            FROM "Issue" i
            LEFT JOIN (
                SELECT "issueId", COUNT(*) as upvote_count 
                FROM "IssueUpvote" 
                GROUP BY "issueId"
            ) uv ON i.id = uv."issueId"
            LEFT JOIN (
                SELECT "issueId", COUNT(*) as comment_count 
                FROM "Comment" 
                GROUP BY "issueId"
            ) cm ON i.id = cm."issueId"
            WHERE ST_Within(
                i.location,
                ST_MakeEnvelope(${minLng}, ${minLat}, ${maxLng}, ${maxLat}, 4326)
            )
            AND i.status != 'RESOLVED'::"IssueStatus"
            AND i.location IS NOT NULL
        `;

        const heatmapData = issues.map((issue) => {
            const hoursSinceCreation = (Date.now() - issue.createdAt.getTime()) / (1000 * 60 * 60);
            const urgencyScore = Math.min(100, hoursSinceCreation * 0.5 + Number(issue.upvote_count) * 2 + Number(issue.comment_count));
            const severity = issue.severity || 3;
            const weight = severity * 0.3 + (urgencyScore / 100) * 0.7;

            return {
                lat: issue.latitude,
                lng: issue.longitude,
                weight: Math.min(1, weight),
            };
        });

        return res.json(heatmapData);
    } catch (err) {
        console.error("Error getting heatmap data:", err);
        return res.status(500).json({ error: "Failed to get heatmap data" });
    }
}

export async function exportData(req: Request, res: Response) {
    try {
        const format = (req.query.format as string) || "csv";
        const userId = req.user?.id;

        if (!userId) {
            return res.status(401).json({ error: "Authentication required" });
        }

        // Use PostGIS query to get user's issues with coordinates
        const issues = await prisma.$queryRaw<Array<{
            id: number;
            title: string;
            description: string;
            issueType: string;
            status: string;
            latitude: number;
            longitude: number;
            createdAt: Date;
            updatedAt: Date;
            severity: number | null;
        }>>`
            SELECT 
                i.id, i.title, i.description, i."issueType", i.status,
                ST_Y(i.location) as latitude,
                ST_X(i.location) as longitude,
                i."createdAt", i."updatedAt", i.severity
            FROM "Issue" i
            WHERE i."userId" = ${userId}
            AND i.location IS NOT NULL
            ORDER BY i."createdAt" DESC
        `;

        const exportData = issues.map((issue) => ({
            id: issue.id,
            title: issue.title,
            description: issue.description,
            type: issue.issueType,
            status: issue.status,
            latitude: issue.latitude,
            longitude: issue.longitude,
            severity: issue.severity || "N/A",
            reportedAt: issue.createdAt.toISOString(),
            lastUpdated: issue.updatedAt.toISOString(),
        }));

        if (format === "json") {
            res.setHeader("Content-Type", "application/json");
            res.setHeader("Content-Disposition", "attachment; filename=my-civic-report.json");
            return res.json(exportData);
        }

        const parser = new Parser({
            fields: ["id", "title", "description", "type", "status", "latitude", "longitude", "severity", "reportedAt", "lastUpdated"],
        });
        const csv = parser.parse(exportData);

        res.setHeader("Content-Type", "text/csv");
        res.setHeader("Content-Disposition", "attachment; filename=my-civic-report.csv");
        return res.send(csv);
    } catch (err) {
        console.error("Error exporting data:", err);
        return res.status(500).json({ error: "Failed to export data" });
    }
}

export default { getSummary, getHeatmap, exportData };

</code>

## segfault-backend\src\api\controllers\authController.ts
<code>
import type { Request, Response } from "express";
import { loginWithGoogle, generateGuestSession, registerWithEmail, loginWithEmail, verify2FACode } from "../../services/authService";
import { FRONTEND_URL } from "../../appconfig";

export async function handleGoogleCallback(req: Request, res: Response) {
    try {
        const { code } = req.query;
        if (!code || typeof code !== 'string') {
            return res.redirect(`${FRONTEND_URL}/login?error=missing_code`);
        }

        const token = await loginWithGoogle(code);

        const sevenDaysMs = 1000 * 60 * 60 * 24 * 7;
        res.cookie('session', token, { httpOnly: true, maxAge: sevenDaysMs, sameSite: 'lax' });

        // Pass token to frontend for localStorage storage
        return res.redirect(`${FRONTEND_URL}/auth/google/callback?token=${encodeURIComponent(token)}`);
    } catch (err: any) {
        console.error('Google OAuth callback failed', err);
        return res.redirect(`${FRONTEND_URL}/login?error=${encodeURIComponent(err?.message ?? 'login_failed')}`);
    }
}

export async function handleGoogleLogin(req: Request, res: Response) {
    try {
        const { code } = req.body ?? {};
        if (!code) {
            return res.status(400).json({ error: 'Missing authorization code' });
        }

        const token = await loginWithGoogle(code);

        const sevenDaysMs = 1000 * 60 * 60 * 24 * 7;
        res.cookie('session', token, { httpOnly: true, maxAge: sevenDaysMs, sameSite: 'lax' });

        return res.status(200).json({ ok: true });
    } catch (err: any) {
        console.error('Google login failed', err);
        return res.status(500).json({ error: err?.message ?? 'Login failed' });
    }
}

export async function handleGuestLogin(_req: Request, res: Response) {
    try {
        const { token, guestTokenId } = await generateGuestSession();

        const oneDayMs = 1000 * 60 * 60 * 24;
        res.cookie('session', token, { httpOnly: true, maxAge: oneDayMs, sameSite: 'lax' });

        return res.status(200).json({ ok: true, guestTokenId, token });
    } catch (err: any) {
        console.error('Guest login failed', err);
        return res.status(500).json({ error: err?.message ?? 'Guest login failed' });
    }
}

export async function handleRegister(req: Request, res: Response) {
    try {
        const { email, password, name } = req.body ?? {};

        if (!email || typeof email !== 'string') {
            return res.status(400).json({ error: 'Email is required' });
        }

        if (!password || typeof password !== 'string' || password.length < 6) {
            return res.status(400).json({ error: 'Password must be at least 6 characters' });
        }

        const result = await registerWithEmail(email.trim().toLowerCase(), password, name ?? null);

        if (typeof result === 'object' && 'require2fa' in result) {
            return res.status(200).json(result);
        }

        const token = result as string;
        const sevenDaysMs = 1000 * 60 * 60 * 24 * 7;
        res.cookie('session', token, { httpOnly: true, maxAge: sevenDaysMs, sameSite: 'lax' });

        return res.status(201).json({ ok: true, token });
    } catch (err: any) {
        console.error('Registration failed', err);
        return res.status(400).json({ error: err?.message ?? 'Registration failed' });
    }
}

export async function handleLogin(req: Request, res: Response) {
    try {
        const { email, password } = req.body ?? {};

        if (!email || typeof email !== 'string') {
            return res.status(400).json({ error: 'Email is required' });
        }

        if (!password || typeof password !== 'string') {
            return res.status(400).json({ error: 'Password is required' });
        }

        const result = await loginWithEmail(email.trim().toLowerCase(), password);

        if (typeof result === 'object' && 'require2fa' in result) {
            return res.status(200).json(result);
        }

        const token = result as string;
        const sevenDaysMs = 1000 * 60 * 60 * 24 * 7;
        res.cookie('session', token, { httpOnly: true, maxAge: sevenDaysMs, sameSite: 'lax' });

        return res.status(200).json({ ok: true, token });
    } catch (err: any) {
        console.error('Login failed', err);
        return res.status(401).json({ error: err?.message ?? 'Login failed' });
    }
}

export async function handleVerify2FA(req: Request, res: Response) {
    try {
        const { userId, code } = req.body;
        if (!userId || !code) {
            return res.status(400).json({ error: "User ID and code are required" });
        }

        const token = await verify2FACode(parseInt(userId), code);

        const sevenDaysMs = 1000 * 60 * 60 * 24 * 7;
        res.cookie('session', token, { httpOnly: true, maxAge: sevenDaysMs, sameSite: 'lax' });

        return res.status(200).json({ ok: true, token });
    } catch (err: any) {
        console.error('2FA verification failed', err);
        return res.status(400).json({ error: err?.message ?? "Verification failed" });
    }
}

// ... existing imports

export async function changePassword(req: Request, res: Response) {
    try {
        if (!req.user) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const { oldPassword, newPassword } = req.body;

        if (!oldPassword || !newPassword) {
            return res.status(400).json({ error: "Old and new passwords are required" });
        }

        if (newPassword.length < 6) {
            return res.status(400).json({ error: "New password must be at least 6 characters" });
        }

        const success = await import("../../services/authService").then(m => m.changeUserPassword(req.user!.id, oldPassword, newPassword));

        if (!success) {
            return res.status(401).json({ error: "Invalid old password" });
        }

        return res.json({ success: true });
    } catch (err: any) {
        console.error("Change password failed", err);
        return res.status(500).json({ error: err?.message ?? "Failed to change password" });
    }
}

export default { handleGoogleCallback, handleGoogleLogin, handleGuestLogin, handleRegister, handleLogin, changePassword, handleVerify2FA };

</code>

## segfault-backend\src\api\controllers\commentController.ts
<code>
import type { Request, Response } from "express";
import * as turf from "@turf/turf";
import {
    addComment,
    getCommentsForIssue,
    deleteComment,
    flagComment,
    addCommentUpvote,
    removeCommentUpvote,
} from "../../data/issue";
import { prisma } from "../../data/prisma/prismaClient";
import { awardPoints } from "../../services/GamificationService";

export async function getComments(req: Request, res: Response) {
    try {
        const id = req.params.id;
        if (!id) {
            return res.status(400).json({ error: "Issue ID is required" });
        }
        const issueId = parseInt(id);

        if (isNaN(issueId)) {
            return res.status(400).json({ error: "Invalid issue ID" });
        }

        const comments = await getCommentsForIssue(issueId);

        const formatted = comments.map((comment) => ({
            id: String(comment.id),
            content: comment.content,
            createdAt: comment.createdAt.toISOString(),
            author: {
                id: String(comment.user.id),
                name: comment.user.name || "Anonymous",
                credibility: comment.user.credibility,
                badges: comment.user.badges.map((b) => b.name),
            },
            upvoteCount: comment.upvotes.length,
            hasUpvoted: req.user ? comment.upvotes.some((u) => u.userId === req.user!.id) : false,
            isFlagged: comment.isFlagged,
        }));

        return res.json(formatted);
    } catch (err) {
        console.error("Error fetching comments:", err);
        return res.status(500).json({ error: "Failed to fetch comments" });
    }
}

export async function createComment(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.status(401).json({ error: "Authenticated user required to comment" });
        }

        const id = req.params.id;
        if (!id) {
            return res.status(400).json({ error: "Issue ID is required" });
        }
        const issueId = parseInt(id);
        const { content } = req.body;

        if (isNaN(issueId)) {
            return res.status(400).json({ error: "Invalid issue ID" });
        }

        if (!content || typeof content !== "string" || content.trim().length === 0) {
            return res.status(400).json({ error: "Comment content is required" });
        }

        const issueCoords = await prisma.$queryRaw<Array<{ latitude: number; longitude: number }>>`
            SELECT
                ST_Y(i.location) as latitude,
                ST_X(i.location) as longitude
            FROM "Issue" i
            WHERE i.id = ${issueId}
            AND i.location IS NOT NULL
            LIMIT 1
        `;

        const issue = issueCoords[0];
        if (!issue) return res.status(404).json({ error: "Issue not found" });

        // Geofencing check - users must be within 5km of the issue
        const { userLat, userLng } = req.body;
        if (userLat === undefined || userLng === undefined) {
            return res.status(400).json({ error: "Location required to comment. Please enable location access." });
        }
        const userPoint = turf.point([userLng, userLat]);
        const issuePoint = turf.point([issue.longitude, issue.latitude]);
        const distance = turf.distance(userPoint, issuePoint, { units: "kilometers" });
        if (distance > 5) {
            return res.status(403).json({ error: "You must be within 5km of the issue to comment." });
        }

        const comment = await addComment(req.user.id, issueId, content.trim());

        return res.status(201).json({
            id: String(comment.id),
            content: comment.content,
            createdAt: comment.createdAt.toISOString(),
            author: {
                id: String(req.user.id),
                name: "You",
            },
            upvoteCount: 0,
            hasUpvoted: false,
        });
    } catch (err) {
        console.error("Error creating comment:", err);
        return res.status(500).json({ error: "Failed to create comment" });
    }
}

export async function removeComment(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const id = req.params.id;
        if (!id) {
            return res.status(400).json({ error: "Comment ID is required" });
        }
        const commentId = parseInt(id);

        if (isNaN(commentId)) {
            return res.status(400).json({ error: "Invalid comment ID" });
        }

        const comment = await prisma.comment.findUnique({ where: { id: commentId } });
        if (!comment) {
            return res.status(404).json({ error: "Comment not found" });
        }

        if (comment.userId !== req.user.id && req.user.role !== "ADMIN") {
            return res.status(403).json({ error: "Not authorized to delete this comment" });
        }

        await deleteComment(commentId);

        return res.json({ success: true });
    } catch (err) {
        console.error("Error deleting comment:", err);
        return res.status(500).json({ error: "Failed to delete comment" });
    }
}

export async function upvoteComment(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.status(401).json({ error: "Authenticated user required to upvote" });
        }

        const id = req.params.id;
        if (!id) {
            return res.status(400).json({ error: "Comment ID is required" });
        }
        const commentId = parseInt(id);

        if (isNaN(commentId)) {
            return res.status(400).json({ error: "Invalid comment ID" });
        }

        const comment = await prisma.comment.findUnique({ where: { id: commentId } });
        if (!comment) {
            return res.status(404).json({ error: "Comment not found" });
        }

        if (comment.userId === req.user.id) {
            return res.status(400).json({ error: "Cannot upvote your own comment" });
        }

        const existing = await prisma.commentUpvote.findFirst({
            where: { commentId, userId: req.user.id },
        });

        if (existing) {
            await removeCommentUpvote(req.user.id, commentId);
        } else {
            await addCommentUpvote(req.user.id, commentId);
            awardPoints(comment.userId, 5).catch((err) =>
                console.error("Failed to award points:", err)
            );
        }

        const upvoteCount = await prisma.commentUpvote.count({ where: { commentId } });

        return res.json({ upvoteCount, hasUpvoted: !existing });
    } catch (err) {
        console.error("Error upvoting comment:", err);
        return res.status(500).json({ error: "Failed to upvote comment" });
    }
}

export async function reportComment(req: Request, res: Response) {
    try {
        if (!req.user) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const id = req.params.id;
        if (!id) {
            return res.status(400).json({ error: "Comment ID is required" });
        }
        const commentId = parseInt(id);
        const { reason } = req.body;

        if (isNaN(commentId)) {
            return res.status(400).json({ error: "Invalid comment ID" });
        }

        const comment = await prisma.comment.findUnique({ where: { id: commentId } });
        if (!comment) {
            return res.status(404).json({ error: "Comment not found" });
        }

        await flagComment(commentId, reason || null);

        return res.json({ success: true });
    } catch (err) {
        console.error("Error flagging comment:", err);
        return res.status(500).json({ error: "Failed to flag comment" });
    }
}

export default { getComments, createComment, removeComment, upvoteComment, reportComment };

</code>

## segfault-backend\src\api\controllers\issueController.ts
<code>
import type { Request, Response } from "express";
// Fix: import Prisma namespace from @prisma/client to avoid local path resolution issues
import { Prisma } from "@prisma/client";
import * as turf from "@turf/turf";
import { getIssuesInBounds as getCachedIssuesInBounds } from "../../services/IssueCacheService";
import {
    createAuthenticatedIssue,
    createGuestIssue,
    getIssueById,
    getIssuesByLocationBox,
    addIssueUpvote,
    removeIssueUpvote,
    getIssueUpvoteCount,
    hasUserUpvotedIssue,
} from "../../data/issue";
import { prisma } from "../../data/prisma/prismaClient";
import { IssueStatus, IssueType } from "../../generated/prisma/enums";
import { recalculatePenalties } from "../../services/PenaltyService";
import { sendToModerationQueue } from "../../services/QueueService";
import { uploadToBlob } from "../../services/BlobStorageService";

const ISSUE_TYPE_INFO: Record<string, { name: string; department: string }> = {
    POTHOLE: { name: "Pothole", department: "Public Works Department" },
    ROAD_DAMAGE: { name: "Road Damage", department: "Public Works Department" },
    STREETLIGHT_FAULT: { name: "Streetlight Fault", department: "Electrical Department" },
    GARBAGE_UNCOLLECTED: { name: "Garbage Uncollected", department: "Sanitation Department" },
    ILLEGAL_DUMPING: { name: "Illegal Dumping", department: "Sanitation Department" },
    DRAINAGE_BLOCKED: { name: "Drainage Blocked", department: "Water Department" },
    SEWAGE_OVERFLOW: { name: "Sewage Overflow", department: "Water Department" },
    WATER_SUPPLY_ISSUE: { name: "Water Supply Issue", department: "Water Department" },
    LOW_WATER_PRESSURE: { name: "Low Water Pressure", department: "Water Department" },
    OPEN_MANHOLE: { name: "Open Manhole", department: "Public Works Department" },
    BROKEN_FOOTPATH: { name: "Broken Footpath", department: "Public Works Department" },
    ILLEGAL_ENCROACHMENT: { name: "Illegal Encroachment", department: "Municipal Corporation" },
    STRAY_CATTLE: { name: "Stray Cattle", department: "Animal Control" },
    TREE_FALL: { name: "Tree Fall", department: "Parks Department" },
    TRAFFIC_LIGHT_FAULT: { name: "Traffic Light Fault", department: "Traffic Department" },
    MOSQUITO_BREEDING: { name: "Mosquito Breeding", department: "Health Department" },
    NOISE_COMPLAINT: { name: "Noise Complaint", department: "Municipal Corporation" },
    BUILDING_SAFETY: { name: "Building Safety", department: "Building Department" },
};

export async function getIssues(req: Request, res: Response) {
    try {
        const { type, status, showResolved } = req.query;

        // Build dynamic WHERE clause parts (validated enum values only)
        const conditions: string[] = ['i.location IS NOT NULL'];
        
        if (type && typeof type === "string") {
            conditions.push(`i."issueType" = '${type}'::"IssueType"`);
        }

        if (status && typeof status === "string") {
            conditions.push(`i.status = '${status}'::"IssueStatus"`);
        } else if (showResolved !== "true") {
            conditions.push(`i.status != 'RESOLVED'::"IssueStatus"`);
        }

        const whereClause = conditions.length ? conditions.join(' AND ') : 'TRUE';

        // Build full SQL string and execute with $queryRawUnsafe to avoid Prisma raw fragment issues
        const sql = `
            SELECT 
                i.id, i.title, i."issueType", i.status, i.description,
                ST_Y(i.location) AS latitude,
                ST_X(i.location) AS longitude,
                i."createdAt", i."userId", i."guestTokenId",
                u.name AS user_name,
                COALESCE(uv.upvote_count, 0) AS upvote_count,
                COALESCE(cm.comment_count, 0) AS comment_count
            FROM "Issue" i
            LEFT JOIN "User" u ON i."userId" = u.id
            LEFT JOIN (
                SELECT "issueId", COUNT(*) AS upvote_count 
                FROM "IssueUpvote" 
                GROUP BY "issueId"
            ) uv ON i.id = uv."issueId"
            LEFT JOIN (
                SELECT "issueId", COUNT(*) AS comment_count 
                FROM "Comment" 
                GROUP BY "issueId"
            ) cm ON i.id = cm."issueId"
            WHERE ${whereClause}
            ORDER BY i."createdAt" DESC
            LIMIT 100
        `;

        const issues = await prisma.$queryRawUnsafe(sql) as Array<{
            id: number;
            title: string;
            issueType: string;
            status: string;
            description: string;
            latitude: number;
            longitude: number;
            createdAt: Date;
            userId: number;
            guestTokenId: number | null;
            user_name: string | null;
            upvote_count: number;
            comment_count: number;
        }>;

        const formatted = issues.map((issue) => ({
            id: String(issue.id),
            title: issue.title,
            type: issue.issueType,
            status: issue.status,
            description: issue.description,
            location: `${issue.latitude}, ${issue.longitude}`,
            lat: issue.latitude,
            lng: issue.longitude,
            voteCount: Number(issue.upvote_count),
            commentCount: Number(issue.comment_count),
            reportedAt: issue.createdAt.toISOString(),
            reporterId: issue.guestTokenId ? undefined : String(issue.userId),
        }));

        return res.json(formatted);
    } catch (err) {
        console.error("Error fetching issues:", err);
        return res.status(500).json({ error: "Failed to fetch issues" });
    }
}

export async function getIssueTypes(_req: Request, res: Response) {
    try {
        const types = Object.entries(ISSUE_TYPE_INFO).map(([id, info]) => ({
            id,
            name: info.name,
            department: info.department,
            description: `Report ${info.name.toLowerCase()} issues`,
        }));

        return res.json(types);
    } catch (err) {
        console.error("Error fetching issue types:", err);
        return res.status(500).json({ error: "Failed to fetch issue types" });
    }
}

export async function getIssue(req: Request, res: Response) {
    try {
        const id = req.params.id;
        if (!id) {
            return res.status(400).json({ error: "Issue ID is required" });
        }
        const issueId = parseInt(id);

        if (isNaN(issueId)) {
            return res.status(400).json({ error: "Invalid issue ID" });
        }

        const issue = await getIssueById(issueId);
        if (!issue) {
            return res.status(404).json({ error: "Issue not found" });
        }

        let hasVoted = false;
        if (req.user && req.user.id !== -1) {
            hasVoted = await hasUserUpvotedIssue(req.user.id, issueId);
        }

        const formatted = {
            id: String(issue.id),
            title: issue.title,
            type: issue.issueType,
            status: issue.status,
            description: issue.description,
            location: `${issue.latitude}, ${issue.longitude}`,
            lat: Number(issue.latitude),
            lng: Number(issue.longitude),
            voteCount: Number(issue._count.upvotes),
            commentCount: Number(issue._count.comments),
            hasVoted,
            reportedAt: issue.createdAt.toISOString(),
            reporter: issue.guestTokenId || !issue.user
                ? { name: "Anonymous", isGuest: true }
                : { id: String(issue.user.id), name: issue.user.name, email: issue.user.email },
        };


        return res.json(formatted);
    } catch (err) {
        console.error("Error fetching issue:", err);
        return res.status(500).json({ error: "Failed to fetch issue" });
    }
}

export async function createIssue(req: Request, res: Response) {
    try {
        if (!req.user) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const { type, description, lat, lng, isAnonymous } = req.body;

        if (!type || !description) {
            return res.status(400).json({ error: "Type and description are required" });
        }

        const issueType = type as IssueType;
        if (!Object.values(IssueType).includes(issueType)) {
            return res.status(400).json({ error: "Invalid issue type" });
        }

        const latitude = typeof lat === 'number' ? lat : parseFloat(String(lat));
        const longitude = typeof lng === 'number' ? lng : parseFloat(String(lng));

        if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
            return res.status(400).json({ error: "Valid lat and lng are required" });
        }

        if (latitude < -90 || latitude > 90 || longitude < -180 || longitude > 180) {
            return res.status(400).json({ error: "lat/lng out of range" });
        }

        const title = `${ISSUE_TYPE_INFO[issueType]?.name || type} Report`;

        // Get uploaded file from multer memory storage (if any)
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const uploadedFile = (req as any).file as { buffer: Buffer; originalname: string } | undefined;

        // Upload to Azure Blob Storage if file exists
        let blobUrl: string | null = null;
        let imageBlobId: string | undefined;

        if (uploadedFile) {
            const uploadResult = await uploadToBlob(uploadedFile.buffer, uploadedFile.originalname);
            if (uploadResult) {
                blobUrl = uploadResult.blobUrl;
                imageBlobId = uploadResult.blobName;
            }
        }

        let issue;
        if (req.user.role === "GUEST" && req.user.guestTokenId) {
            issue = await createGuestIssue(title, description, latitude, longitude, issueType, req.user.guestTokenId, imageBlobId);
        } else {
            issue = await createAuthenticatedIssue(title, description, latitude, longitude, issueType, req.user.id, imageBlobId);
        }

        if (!issue) {
            console.error("Issue creation returned null/undefined");
            return res.status(500).json({ error: "Failed to create issue" });
        }

        recalculatePenalties().catch((err) =>
            console.error("Failed to recalculate penalties:", err)
        );

        // Always send to moderation queue - Azure Function will authorize the issue
        sendToModerationQueue({
            issueId: issue.id,
            blobUrl: blobUrl || "",
            latitude,
            longitude,
            issueType,
        }).catch((err) => console.error("Failed to queue moderation:", err));

        return res.status(201).json({
            id: String(issue.id),
            title: issue.title,
            type: issue.issueType,
            status: issue.status,
            description: issue.description,
            location: `${issue.latitude}, ${issue.longitude}`,
            imageBlobId: issue.imageBlobId,
            reportedAt: issue.createdAt.toISOString(),
        });
    } catch (err) {
        console.error("Error creating issue:", err);
        return res.status(500).json({ error: "Failed to create issue" });
    }
}

export async function voteOnIssue(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.status(401).json({ error: "Authenticated user required to vote" });
        }

        const id = req.params.id;
        if (!id) {
            return res.status(400).json({ error: "Issue ID is required" });
        }
        const issueId = parseInt(id);

        if (isNaN(issueId)) {
            return res.status(400).json({ error: "Invalid issue ID" });
        }

        const issue = await getIssueById(issueId);
        if (!issue) {
            return res.status(404).json({ error: "Issue not found" });
        }

        // PostGIS-based geofencing check - users must be within 5km of the issue
        const { userLat, userLng } = req.body;
        if (userLat === undefined || userLng === undefined) {
            return res.status(400).json({ error: "Location required to vote. Please enable location access." });
        }

        // Use PostGIS to check distance instead of turf.js
        const distanceCheck = await prisma.$queryRaw<{ distance_meters: number }[]>`
            SELECT ST_Distance(
                ST_SetSRID(ST_MakePoint(${issue.longitude}, ${issue.latitude}), 4326)::geography,
                ST_SetSRID(ST_MakePoint(${userLng}, ${userLat}), 4326)::geography
            ) as distance_meters
        `;

        const distance = distanceCheck[0]?.distance_meters || Infinity;
        if (distance > 5000) { // 5km in meters
            return res.status(403).json({ error: "You must be within 5km of the issue to vote." });
        }

        const hasVoted = await hasUserUpvotedIssue(req.user.id, issueId);

        if (hasVoted) {
            await removeIssueUpvote(req.user.id, issueId);
        } else {
            await addIssueUpvote(req.user.id, issueId);
        }

        const voteCount = await getIssueUpvoteCount(issueId);

        return res.json({ voteCount, hasVoted: !hasVoted });
    } catch (err) {
        console.error("Error voting on issue:", err);
        return res.status(500).json({ error: "Failed to vote on issue" });
    }
}

export async function getIssuesInBounds(req: Request, res: Response) {
    try {
        // Parse query parameters - they arrive as strings
        const minLat = parseFloat(req.query.minLat as string);
        const maxLat = parseFloat(req.query.maxLat as string);
        const minLng = parseFloat(req.query.minLng as string);
        const maxLng = parseFloat(req.query.maxLng as string);

        // Validate required parameters
        if (isNaN(minLat) || isNaN(maxLat) || isNaN(minLng) || isNaN(maxLng)) {
            return res.status(400).json({
                error: "Invalid bounds. Required: minLat, maxLat, minLng, maxLng as valid numbers",
            });
        }

        // Use the cache service for fast loading
        const showResolved = req.query.showResolved === 'true';
        const cachedIssues = await getCachedIssuesInBounds(minLat, maxLat, minLng, maxLng, showResolved);

        // Calculate urgency score and format response
        const now = new Date();
        const issueType = req.query.type as string | undefined;
        const statusOpen = req.query.statusOpen === 'true';
        const statusInProgress = req.query.statusInProgress === 'true';
        const urgencyFilter = req.query.urgency as string | undefined;

        console.log(`[MapDebug] Filters: Type=${issueType}, Open=${statusOpen}, InProgress=${statusInProgress}, Urgency=${urgencyFilter}, ShowResolved=${showResolved}`);
        console.log(`[MapDebug] Raw issues from cache/DB: ${cachedIssues.length}`);

        let formatted = cachedIssues.map((issue) => {
            // Calculate hours since creation
            const hoursSinceCreation = (now.getTime() - new Date(issue.createdAt).getTime()) / (1000 * 60 * 60);

            // Urgency formula: (hoursSinceCreation * 0.5) + (upvotes * 2), capped at 100
            const rawUrgency = hoursSinceCreation * 0.5 + issue.voteCount * 2;
            const urgencyScore = Math.min(100, Math.round(rawUrgency));

            return {
                id: String(issue.id),
                title: issue.title,
                type: issue.issueType,
                status: issue.status,
                lat: issue.latitude,
                lng: issue.longitude,
                voteCount: issue.voteCount,
                commentCount: issue.commentCount,
                urgencyScore,
                reportedAt: issue.createdAt,
            };
        });

        // Apply filters
        formatted = formatted.filter(issue => {
            // Type filter
            if (issueType && issue.type !== issueType) return false;

            // Status filter
            // Note: issue.status is from DB enum (OPEN, IN_PROGRESS, RESOLVED, REJECTED)
            // statusOpen covers OPEN (and PENDING if exists)
            // statusInProgress covers IN_PROGRESS
            // showResolved covers RESOLVED (handled partly in cache fetching but good to double check)

            let statusMatch = false;
            // logic: if NO status filters are active (logic suggests we default to showing something, but UI defaults to Open+InProgress selected)
            // If the UI passes these as flags, we check if the issue status matches an ACTIVE flag.

            if (issue.status === 'RESOLVED') {
                if (showResolved) statusMatch = true;
            } else if (issue.status === 'IN_PROGRESS') {
                if (statusInProgress) statusMatch = true;
            } else if (issue.status === 'OPEN' || issue.status === 'PENDING') { // Assuming PENDING might exist in enum or just OPEN
                if (statusOpen) statusMatch = true;
            } else {
                // For other statuses (e.g. REJECTED), default to showing if nothing else matches? 
                // Or maybe strict filtering. Let's assume strict based on checkboxes.
                // If the issue is REJECTED, and we don't have a checkbox for it, it might hide?
                // Let's assume statusOpen covers 'OPEN'
                if (statusOpen) statusMatch = true; // Fallback for basic OPEN
            }

            if (!statusMatch) return false;

            // Urgency filter
            if (urgencyFilter) {
                if (urgencyFilter === 'CRITICAL' && issue.urgencyScore < 80) return false;
                if (urgencyFilter === 'HIGH' && issue.urgencyScore < 60) return false;
                if (urgencyFilter === 'MEDIUM' && issue.urgencyScore < 40) return false;
                if (urgencyFilter === 'LOW' && issue.urgencyScore >= 40) return false; // Low implies strictly low? Map usually filters inclusive?
                // Let's assume inclusive logic or simple thresholds
            }

            return true;
        });

        console.log(`[MapDebug] Returning ${formatted.length} issues after filtering`);

        return res.json(formatted);
    } catch (err) {
        console.error("Error fetching map issues:", err);
        return res.status(500).json({ error: "Failed to fetch map issues" });
    }
}

export async function updateIssueStatus(req: Request, res: Response) {
    try {
        if (!req.user) {
            return res.status(401).json({ error: "Authentication required" });
        }

        if (req.user.role !== "ADMIN") {
            return res.status(403).json({ error: "Admin access required" });
        }

        const issueId = parseInt(req.params.id || "");
        if (isNaN(issueId)) {
            return res.status(400).json({ error: "Invalid issue ID" });
        }

        const { status } = req.body;
        if (!status || !Object.values(IssueStatus).includes(status)) {
            return res.status(400).json({ error: "Invalid status value" });
        }

        const issue = await prisma.issue.findUnique({
            where: { id: issueId },
            select: { userId: true, status: true },
        });

        if (!issue) {
            return res.status(404).json({ error: "Issue not found" });
        }

        const prevStatus = issue.status;

        const updated = await prisma.issue.update({
            where: { id: issueId },
            data: { status: status as IssueStatus },
        });

        if (status === IssueStatus.RESOLVED && prevStatus !== IssueStatus.RESOLVED) {
            const { awardPoints } = await import("../../services/GamificationService");
            awardPoints(issue.userId, 20).catch((err) =>
                console.error("Failed to award points for resolution:", err)
            );
        }

        return res.json({
            id: String(updated.id),
            status: updated.status,
            message: "Status updated successfully",
        });
    } catch (err) {
        console.error("Error updating issue status:", err);
        return res.status(500).json({ error: "Failed to update status" });
    }
}

export default { getIssues, getIssueTypes, getIssue, createIssue, voteOnIssue, getIssuesInBounds, updateIssueStatus };

</code>

## segfault-backend\src\api\controllers\notificationController.ts
<code>
import type { Request, Response } from "express";
import { getUserNotifications, markNotificationAsRead, markAllNotificationsAsRead } from "../../data/notification";

export async function getNotifications(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.json([]);
        }

        const notifications = await getUserNotifications(req.user.id);

        const formatted = notifications.map((notif) => ({
            id: String(notif.id),
            type: notif.type,
            message: notif.message,
            read: notif.read,
            createdAt: notif.createdAt.toISOString(),
        }));

        return res.json(formatted);
    } catch (err) {
        console.error("Error fetching notifications:", err);
        return res.status(500).json({ error: "Failed to fetch notifications" });
    }
}

export async function markAsRead(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const id = req.params.id;
        if (!id) {
            return res.status(400).json({ error: "Notification ID is required" });
        }
        const notificationId = parseInt(id);

        if (isNaN(notificationId)) {
            return res.status(400).json({ error: "Invalid notification ID" });
        }

        await markNotificationAsRead(notificationId);

        return res.json({ success: true });
    } catch (err) {
        console.error("Error marking notification as read:", err);
        return res.status(500).json({ error: "Failed to mark notification as read" });
    }
}

export async function markAllAsRead(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.status(401).json({ error: "Authentication required" });
        }

        await markAllNotificationsAsRead(req.user.id);

        return res.json({ success: true });
    } catch (err) {
        console.error("Error marking all notifications as read:", err);
        return res.status(500).json({ error: "Failed to mark notifications as read" });
    }
}

export default { getNotifications, markAsRead, markAllAsRead };

</code>

## segfault-backend\src\api\controllers\resolutionController.ts
<code>
import type { Request, Response } from "express";
import { prisma } from "../../data/prisma/prismaClient";
import { IssueStatus } from "../../generated/prisma/enums";
import { awardPoints } from "../../services/GamificationService";

const AUTO_REVERT_THRESHOLD = -5;

export async function castResolutionVote(req: Request, res: Response) {
    try {
        if (!req.user) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const issueId = parseInt(req.params.id || "");
        if (isNaN(issueId)) {
            return res.status(400).json({ error: "Invalid issue ID" });
        }

        const { isVerified } = req.body;
        if (typeof isVerified !== "boolean") {
            return res.status(400).json({ error: "isVerified must be a boolean" });
        }

        const issue = await prisma.issue.findUnique({
            where: { id: issueId },
        });

        if (!issue) {
            return res.status(404).json({ error: "Issue not found" });
        }

        if (issue.status !== IssueStatus.RESOLVED) {
            return res.status(400).json({ error: "Can only vote on resolved issues" });
        }

        const existingVote = await prisma.issueResolutionVote.findUnique({
            where: {
                issueId_userId: {
                    issueId,
                    userId: req.user.id,
                },
            },
        });

        if (existingVote) {
            await prisma.issueResolutionVote.update({
                where: { id: existingVote.id },
                data: { isResolved: isVerified },
            });
        } else {
            await prisma.issueResolutionVote.create({
                data: {
                    issueId,
                    userId: req.user.id,
                    isResolved: isVerified,
                },
            });

            if (isVerified) {
                awardPoints(req.user.id, 10).catch((err) =>
                    console.error("Failed to award resolution vote points:", err)
                );
            }
        }

        const netScore = await calculateNetScore(issueId);

        if (netScore <= AUTO_REVERT_THRESHOLD) {
            await revertIssue(issueId, req.user.id);
            return res.json({
                message: "Vote recorded. Issue reopened by community consensus.",
                netScore,
                reverted: true,
            });
        }

        return res.json({
            message: "Vote recorded",
            netScore,
            reverted: false,
        });
    } catch (err) {
        console.error("Error casting resolution vote:", err);
        return res.status(500).json({ error: "Failed to record vote" });
    }
}

async function calculateNetScore(issueId: number): Promise<number> {
    const votes = await prisma.issueResolutionVote.findMany({
        where: { issueId },
        select: { isResolved: true },
    });

    let score = 0;
    for (const vote of votes) {
        score += vote.isResolved ? 1 : -1;
    }
    return score;
}

async function revertIssue(issueId: number, triggeredByUserId: number): Promise<void> {
    await prisma.issue.update({
        where: { id: issueId },
        data: { status: IssueStatus.IN_PROGRESS },
    });

    await prisma.comment.create({
        data: {
            content: "Issue reopened by community consensus. Multiple users reported the fix was insufficient.",
            issueId,
            userId: triggeredByUserId,
            isSystemGenerated: true,
        },
    });

    await prisma.issueResolutionVote.deleteMany({
        where: { issueId },
    });
}

export async function getResolutionVotes(req: Request, res: Response) {
    try {
        const issueId = parseInt(req.params.id || "");
        if (isNaN(issueId)) {
            return res.status(400).json({ error: "Invalid issue ID" });
        }

        const votes = await prisma.issueResolutionVote.findMany({
            where: { issueId },
            select: { isResolved: true },
        });

        const verified = votes.filter((v) => v.isResolved).length;
        const notFixed = votes.filter((v) => !v.isResolved).length;

        let userVote = null;
        if (req.user) {
            const vote = await prisma.issueResolutionVote.findUnique({
                where: {
                    issueId_userId: {
                        issueId,
                        userId: req.user.id,
                    },
                },
            });
            userVote = vote ? vote.isResolved : null;
        }

        return res.json({
            verified,
            notFixed,
            netScore: verified - notFixed,
            userVote,
        });
    } catch (err) {
        console.error("Error getting resolution votes:", err);
        return res.status(500).json({ error: "Failed to get votes" });
    }
}

export default { castResolutionVote, getResolutionVotes };

</code>

## segfault-backend\src\api\controllers\routeController.ts
<code>
import type { Request, Response } from "express";
import { findPath } from "../../services/PathfindingService";

interface RouteRequestBody {
    start: { lat: number; lng: number };
    end: { lat: number; lng: number };
}

/**
 * POST /api/route
 * Find optimal path between two points, avoiding high-penalty areas
 */
export async function calculateRoute(req: Request, res: Response) {
    try {
        const { start, end } = req.body as RouteRequestBody;

        // Validate request
        if (!start || !end) {
            return res.status(400).json({ error: "start and end coordinates required" });
        }

        if (typeof start.lat !== "number" || typeof start.lng !== "number") {
            return res.status(400).json({ error: "Invalid start coordinates" });
        }

        if (typeof end.lat !== "number" || typeof end.lng !== "number") {
            return res.status(400).json({ error: "Invalid end coordinates" });
        }

        // Find path using A* algorithm
        const result = await findPath(start.lat, start.lng, end.lat, end.lng);

        if (!result) {
            return res.status(404).json({
                error: "No route found",
                message: "Could not find a path between the specified points. The area may not have road data loaded.",
            });
        }

        return res.json({
            path: result.path,
            totalDistance: Math.round(result.totalDistance), // in meters
            estimatedTime: Math.round(result.estimatedTime), // in minutes
        });
    } catch (err) {
        console.error("Error calculating route:", err);
        return res.status(500).json({ error: "Failed to calculate route" });
    }
}

export default { calculateRoute };

</code>

## segfault-backend\src\api\controllers\userController.ts
<code>
import type { Request, Response } from "express";
import { prisma } from "../../data/prisma/prismaClient";

// Helper to get formatted profile
export async function getMe(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            include: {
                badges: true,
                _count: {
                    select: {
                        issues: true,
                        comments: true,
                        issueUpvotes: true, // Upvotes given
                        commentUpvotes: true, // Upvotes given
                    }
                }
            }
        });

        if (!user) {
            return res.status(404).json({ error: "User not found" });
        }

        // Calculate some extra stats if needed
        // For now return what we have
        return res.json({
            id: String(user.id),
            name: user.name,
            email: user.email,
            picture: user.picture,
            role: user.role,
            credibility: user.credibility,
            badges: user.badges.map(b => ({
                id: b.id,
                name: b.name,
                awardedAt: b.awardedAt
            })),
            stats: {
                issuesReported: user._count.issues,
                commentsPosted: user._count.comments,
                points: user.credibility // assuming credibility is points
            }
        });
    } catch (err) {
        console.error("Error getting user profile:", err);
        return res.status(500).json({ error: "Failed to get profile" });
    }
}

export async function getMyIssues(req: Request, res: Response) {
    try {
        const userId = req.user?.id;
        if (!userId) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const issues = await prisma.$queryRaw<Array<{
            id: number;
            title: string;
            issueType: string;
            status: string;
            latitude: number;
            longitude: number;
            createdAt: Date;
            upvote_count: bigint;
            comment_count: bigint;
        }>>`
            SELECT 
                i.id, i.title, i."issueType", i.status,
                ST_Y(i.location) as latitude,
                ST_X(i.location) as longitude,
                i."createdAt",
                COALESCE(uv.upvote_count, 0) as upvote_count,
                COALESCE(cm.comment_count, 0) as comment_count
            FROM "Issue" i
            LEFT JOIN (
                SELECT "issueId", COUNT(*) as upvote_count 
                FROM "IssueUpvote" 
                GROUP BY "issueId"
            ) uv ON i.id = uv."issueId"
            LEFT JOIN (
                SELECT "issueId", COUNT(*) as comment_count 
                FROM "Comment" 
                GROUP BY "issueId"
            ) cm ON i.id = cm."issueId"
            WHERE i."userId" = ${userId}
            AND i.location IS NOT NULL
            ORDER BY i."createdAt" DESC
        `;

        const formatted = issues.map((issue) => ({
            id: String(issue.id),
            title: issue.title,
            type: issue.issueType,
            status: issue.status,
            location: `${issue.latitude}, ${issue.longitude}`,
            lat: issue.latitude,
            lng: issue.longitude,
            voteCount: Number(issue.upvote_count),
            commentCount: Number(issue.comment_count),
            reportedAt: issue.createdAt.toISOString(),
        }));

        return res.json(formatted);
    } catch (err) {
        console.error("Error fetching user issues:", err);
        return res.status(500).json({ error: "Failed to fetch issues" });
    }
}

export async function getMyComments(req: Request, res: Response) {
    try {
        if (!req.user || req.user.id === -1) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const comments = await prisma.comment.findMany({
            where: { userId: req.user.id },
            orderBy: { createdAt: 'desc' },
            include: {
                issue: {
                    select: {
                        id: true,
                        title: true
                    }
                },
                upvotes: true
            }
        });

        const formatted = comments.map(comment => ({
            id: String(comment.id),
            content: comment.content,
            createdAt: comment.createdAt.toISOString(),
            issueId: String(comment.issueId),
            issueTitle: comment.issue.title,
            upvoteCount: comment.upvotes.length
        }));

        return res.json(formatted);

    } catch (err) {
        console.error("Error fetching user comments:", err);
        return res.status(500).json({ error: "Failed to fetch comments" });
    }
}

export default { getMe, getMyIssues, getMyComments };

</code>

## segfault-backend\src\api\middleware\auth.ts
<code>
import type { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";
import { JWT } from "../../appconfig";
import { prisma } from "../../data/prisma/prismaClient";

export interface AuthUser {
    id: number;
    role: "USER" | "ADMIN" | "GUEST";
    email?: string;
    guestTokenId?: number;
}

declare global {
    namespace Express {
        interface Request {
            user?: AuthUser;
        }
    }
}

export async function authMiddleware(req: Request, res: Response, next: NextFunction) {
    try {
        const token = req.cookies?.session || req.headers.authorization?.replace("Bearer ", "");

        if (!token) {
            return res.status(401).json({ error: "Authentication required" });
        }

        const decoded = jwt.verify(token, JWT.SECRET) as { sub?: string; id?: number; userId?: number; role?: string; guestTokenId?: number };

        if (decoded.guestTokenId) {
            const guestToken = await prisma.guestToken.findUnique({ where: { id: decoded.guestTokenId } });
            if (!guestToken) {
                return res.status(401).json({ error: "Invalid guest session" });
            }
            req.user = {
                id: -1,
                role: "GUEST",
                guestTokenId: decoded.guestTokenId,
            };
        } else {
            const userId = decoded.userId || decoded.id || (decoded.sub ? parseInt(decoded.sub) : undefined);
            if (!userId) {
                return res.status(401).json({ error: "Invalid token" });
            }

            const user = await prisma.user.findUnique({ where: { id: userId } });
            if (!user) {
                return res.status(401).json({ error: "User not found" });
            }

            req.user = {
                id: user.id,
                role: user.role as "USER" | "ADMIN",
                email: user.email,
            };
        }

        next();
    } catch (err) {
        return res.status(401).json({ error: "Invalid or expired token" });
    }
}

export async function optionalAuth(req: Request, _res: Response, next: NextFunction) {
    try {
        const token = req.cookies?.session || req.headers.authorization?.replace("Bearer ", "");

        if (!token) {
            return next();
        }

        const decoded = jwt.verify(token, JWT.SECRET) as { sub?: string; id?: number; userId?: number; role?: string; guestTokenId?: number };

        if (decoded.guestTokenId) {
            req.user = {
                id: -1,
                role: "GUEST",
                guestTokenId: decoded.guestTokenId,
            };
        } else {
            const userId = decoded.userId || decoded.id || (decoded.sub ? parseInt(decoded.sub) : undefined);
            if (userId) {
                const user = await prisma.user.findUnique({ where: { id: userId } });
                if (user) {
                    req.user = {
                        id: user.id,
                        role: user.role as "USER" | "ADMIN",
                        email: user.email,
                    };
                }
            }
        }

        next();
    } catch {
        next();
    }
}

export default { authMiddleware, optionalAuth };

</code>

## segfault-backend\src\api\middlewares\authMiddleware.ts
<code>
import type { Request, Response, NextFunction } from 'express';
import { redisClient } from '../../data/redisClient';

export async function requireAuth(req: Request, res: Response, next: NextFunction) {
    try {
        let token: string | undefined;

        // Check cookie first
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const anyReq = req as any;
        if (anyReq.cookies && anyReq.cookies.session) {
            token = anyReq.cookies.session;
        }

        // Fallback to Authorization header
        if (!token) {
            const auth = req.headers.authorization;
            if (auth && auth.startsWith('Bearer ')) {
                token = auth.slice(7);
            }
        }

        if (!token) {
            return res.status(401).json({ error: 'Unauthorized' });
        }

        const data = await redisClient.get(`session:${token}`);
        if (!data) {
            return res.status(401).json({ error: 'Session expired or invalid' });
        }

        let parsed: any = null;
        try {
            parsed = JSON.parse(data);
        } catch (e) {
            parsed = null;
        }

        if (!parsed) {
            return res.status(401).json({ error: 'Invalid session payload' });
        }

        // attach user info
        (req as any).user = parsed;

        return next();
    } catch (err) {
        return res.status(500).json({ error: 'Auth check failed' });
    }
}

export default requireAuth;

</code>

## segfault-backend\src\api\routes\adminRoutes.ts
<code>
import { Router } from "express";
import { getModerationQueue, resolveModeration, getUsers, banUser } from "../controllers/adminController";
import authMiddleware from "../middlewares/authMiddleware";

const router = Router();

// Admin role check middleware
const isAdmin = (req: any, res: any, next: any) => {
    if (!req.user || req.user.role !== "ADMIN") {
        return res.status(403).json({ error: "Admin access required" });
    }
    next();
};

// All routes require auth + admin
router.use(authMiddleware);
router.use(isAdmin);

// Moderation
router.get("/moderation", getModerationQueue);
router.post("/moderation/:id/resolve", resolveModeration);

// User management
router.get("/users", getUsers);
router.post("/users/:id/ban", banUser);

export default router;

</code>

## segfault-backend\src\api\routes\analyticsRoutes.ts
<code>
import express from "express";
import { getSummary, getHeatmap, exportData } from "../controllers/analyticsController";
import { authMiddleware, optionalAuth } from "../middleware/auth";

const router = express.Router();

router.get("/summary", optionalAuth, getSummary);
router.get("/heatmap", getHeatmap);
router.get("/export", authMiddleware, exportData);

export default router;

</code>

## segfault-backend\src\api\routes\authRoutes.ts
<code>
import express from 'express';
import { handleGoogleCallback, handleGoogleLogin, handleGuestLogin, handleRegister, handleLogin, changePassword, handleVerify2FA } from '../controllers/authController';
import { authMiddleware } from '../middleware/auth';

const router = express.Router();

router.get('/callback', handleGoogleCallback);
router.post('/google', handleGoogleLogin);
router.post('/guest', handleGuestLogin);
router.post('/register', handleRegister);
router.post('/login', handleLogin);
router.post('/verify-2fa', handleVerify2FA);
router.post('/change-password', authMiddleware, changePassword);

export default router;

</code>

## segfault-backend\src\api\routes\commentRoutes.ts
<code>
import express from "express";
import { getComments, createComment, removeComment, upvoteComment, reportComment } from "../controllers/commentController";
import { authMiddleware, optionalAuth } from "../middleware/auth";

const router = express.Router();

router.get("/issues/:id/comments", optionalAuth, getComments);
router.post("/issues/:id/comments", authMiddleware, createComment);
router.delete("/comments/:id", authMiddleware, removeComment);
router.post("/comments/:id/upvote", authMiddleware, upvoteComment);
router.post("/comments/:id/flag", authMiddleware, reportComment);

export default router;

</code>

## segfault-backend\src\api\routes\issueRoutes.ts
<code>
import express from "express";
import multer from "multer";
import path from "path";
import { getIssues, getIssueTypes, getIssue, createIssue, voteOnIssue, getIssuesInBounds, updateIssueStatus } from "../controllers/issueController";
import { castResolutionVote, getResolutionVotes } from "../controllers/resolutionController";
import { authMiddleware, optionalAuth } from "../middleware/auth";

const router = express.Router();

// Use memory storage for Azure Blob upload (buffer available in req.file.buffer)
const storage = multer.memoryStorage();

const upload = multer({
    storage,
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
        const allowedTypes = /jpeg|jpg|png|gif|webp/;
        const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
        const mimetype = allowedTypes.test(file.mimetype);
        if (extname && mimetype) {
            cb(null, true);
        } else {
            cb(new Error("Only image files are allowed"));
        }
    },
});

router.get("/", optionalAuth, getIssues);
router.get("/types", getIssueTypes);
router.get("/map", optionalAuth, getIssuesInBounds);
router.get("/:id", optionalAuth, getIssue);
router.post("/report", authMiddleware, upload.single("file"), createIssue);
router.post("/:id/vote", authMiddleware, voteOnIssue);
router.patch("/:id/status", authMiddleware, updateIssueStatus);
router.get("/:id/verify", optionalAuth, getResolutionVotes);
router.post("/:id/verify", authMiddleware, castResolutionVote);

export default router;

</code>

## segfault-backend\src\api\routes\notificationRoutes.ts
<code>
import express from "express";
import { getNotifications, markAsRead, markAllAsRead } from "../controllers/notificationController";
import { authMiddleware } from "../middleware/auth";

const router = express.Router();

router.get("/", authMiddleware, getNotifications);
router.patch("/:id/read", authMiddleware, markAsRead);
router.patch("/read-all", authMiddleware, markAllAsRead);

export default router;

</code>

## segfault-backend\src\api\routes\routeRoutes.ts
<code>
import express from "express";
import { calculateRoute } from "../controllers/routeController";
import { optionalAuth } from "../middleware/auth";

const router = express.Router();

// POST /api/route - Find optimal path between two points
router.post("/", optionalAuth, calculateRoute);

export default router;

</code>

## segfault-backend\src\api\routes\userRoutes.ts
<code>
import express from 'express';
import { getMe, getMyIssues, getMyComments } from '../controllers/userController';
import { authMiddleware } from '../middleware/auth';

const router = express.Router();

router.get('/me', authMiddleware, getMe);
router.get('/me/issues', authMiddleware, getMyIssues);
router.get('/me/comments', authMiddleware, getMyComments);

export default router;

</code>

## segfault-backend\src\data\issue.ts
<code>
// Database access for issue related operations
import { prisma } from "./prisma/prismaClient";
import { IssueStatus, IssueType, IssueAuthorized, IssueError } from "../generated/prisma/enums";

// Issue Creation and Management
export async function createAuthenticatedIssue(
	title: string,
	description: string,
	latitude: number,
	longitude: number,
	issueType: IssueType,
	userId: number,
	imageBlobId?: string,
) {
	if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
		throw new Error("Invalid latitude/longitude");
	}

	// Use SQL to insert with PostGIS geometry
	const result = await prisma.$queryRaw<{ id: number }[]>`
		INSERT INTO "Issue" (title, description, latitude, longitude, location, "issueType", "userId", "imageBlobId", authorized, error, "createdAt")
		VALUES (${title}, ${description}, ${latitude}, ${longitude}, ST_SetSRID(ST_MakePoint(${longitude}, ${latitude}), 4326), ${issueType}::"IssueType", ${userId}, ${imageBlobId}, 'FALSE'::"IssueAuthorized", 'PENDING'::"IssueError", NOW())
		RETURNING id
	`;

	const issueId = result[0]?.id;
	if (!issueId) throw new Error("Failed to create issue");

	// Fetch the created issue for return
	return getIssueById(issueId);
}

export async function createGuestIssue(
	title: string,
	description: string,
	latitude: number,
	longitude: number,
	issueType: IssueType,
	guestTokenId: number,
	imageBlobId?: string,
) {
	if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
		throw new Error("Invalid latitude/longitude");
	}

	const result = await prisma.$queryRaw<{ id: number }[]>`
		INSERT INTO "Issue" (title, description, latitude, longitude, location, "issueType", "guestTokenId", "userId", "imageBlobId", authorized, error, "createdAt")
		VALUES (${title}, ${description}, ${latitude}, ${longitude}, ST_SetSRID(ST_MakePoint(${longitude}, ${latitude}), 4326), ${issueType}::"IssueType", ${guestTokenId}, -1, ${imageBlobId}, 'FALSE'::"IssueAuthorized", 'PENDING'::"IssueError", NOW())
		RETURNING id
	`;

	const issueId = result[0]?.id;
	if (!issueId) throw new Error("Failed to create issue");

	return getIssueById(issueId);
}

export async function updateIssueImage(issueId: number, imageBlobId: string) {
	const issue = await prisma.issue.update({ where: { id: issueId }, data: { imageBlobId } });
	return issue;
}

export async function updateIssueStatus(issueId: number, status: IssueStatus) {
	const issue = await prisma.issue.update({ where: { id: issueId }, data: { status } });
	return issue;
}

export async function authorizeIssue(issueId: number) {
	const issue = await prisma.issue.update({ where: { id: issueId }, data: { authorized: IssueAuthorized.TRUE } });
	return issue;
}

export async function flagIssueError(issueId: number, error: IssueError) {
	const issue = await prisma.issue.update({ where: { id: issueId }, data: { error } });
	return issue;
}

export async function deleteIssue(issueId: number) {
	const existing = await prisma.issue.findUnique({ where: { id: issueId } });
	if (!existing) return null;

	// collect related comment ids so we can delete comment upvotes first
	const comments = await prisma.comment.findMany({ where: { issueId }, select: { id: true } });
	const commentIds = comments.map((c) => c.id);

	await prisma.$transaction([
		prisma.commentUpvote.deleteMany({ where: { commentId: { in: commentIds } } }),
		prisma.comment.deleteMany({ where: { issueId } }),
		prisma.issueUpvote.deleteMany({ where: { issueId } }),
		prisma.issueResolutionVote.deleteMany({ where: { issueId } }),
		prisma.issue.delete({ where: { id: issueId } }),
	]);

	return existing;
}

// Issue Retrieval (Filtering and Map)
export async function getIssueById(issueId: number) {
	// Use raw SQL to extract lat/lng from PostGIS geometry
	const issues = await prisma.$queryRaw<Array<{
		id: number;
		title: string;
		description: string;
		latitude: number;
		longitude: number;
		status: string;
		authorized: string;
		error: string;
		createdAt: Date;
		updatedAt: Date;
		imageBlobId: string | null;
		severity: number | null;
		userId: number;
		guestTokenId: number | null;
		issueType: string;
		user_id: number | null;
		user_name: string | null;
		user_email: string | null;
		upvote_count: number;
		comment_count: number;
	}>>`
		SELECT 
			i.id, i.title, i.description,
			ST_Y(i.location) as latitude,
			ST_X(i.location) as longitude,
			i.status, i.authorized, i.error, i."createdAt", i."updatedAt",
			i."imageBlobId", i.severity, i."userId", i."guestTokenId", i."issueType",
			u.id as user_id, u.name as user_name, u.email as user_email,
			COALESCE(upvote_count, 0) as upvote_count,
			COALESCE(comment_count, 0) as comment_count
		FROM "Issue" i
		LEFT JOIN "User" u ON i."userId" = u.id
		LEFT JOIN (
			SELECT "issueId", COUNT(*) as upvote_count 
			FROM "IssueUpvote" 
			GROUP BY "issueId"
		) uv ON i.id = uv."issueId"
		LEFT JOIN (
			SELECT "issueId", COUNT(*) as comment_count 
			FROM "Comment" 
			GROUP BY "issueId"
		) cm ON i.id = cm."issueId"
		WHERE i.id = ${issueId}
	`;

	const issue = issues[0];
	if (!issue) return null;

	// Format to match expected return type
	return {
		...issue,
		_count: {
			upvotes: issue.upvote_count,
			comments: issue.comment_count,
		},
		user: issue.user_id ? {
			id: issue.user_id,
			name: issue.user_name,
			email: issue.user_email,
		} : null,
		guestToken: issue.guestTokenId ? { id: issue.guestTokenId, token: "hidden" } : null,
	};
}

// Updated location-based search using PostGIS
export async function getIssuesByLocationBox(
	minLat: number,
	maxLat: number,
	minLng: number,
	maxLng: number,
	filters?: { type?: IssueType; status?: IssueStatus }
) {
	let typeFilter = '';
	let statusFilter = '';
	
	if (filters?.type) {
		typeFilter = `AND i."issueType" = ${filters.type}::"IssueType"`;
	}
	
	if (filters?.status) {
		statusFilter = `AND i.status = ${filters.status}::"IssueStatus"`;
	}

	const issues = await prisma.$queryRaw<Array<{
		id: number;
		title: string;
		description: string;
		latitude: number;
		longitude: number;
		status: string;
		issueType: string;
		createdAt: Date;
		upvote_count: number;
		comment_count: number;
	}>>`
		SELECT 
			i.id, i.title, i.description,
			ST_Y(i.location) as latitude,
			ST_X(i.location) as longitude,
			i.status, i."issueType", i."createdAt",
			COALESCE(upvote_count, 0) as upvote_count,
			COALESCE(comment_count, 0) as comment_count
		FROM "Issue" i
		LEFT JOIN (
			SELECT "issueId", COUNT(*) as upvote_count 
			FROM "IssueUpvote" 
			GROUP BY "issueId"
		) uv ON i.id = uv."issueId"
		LEFT JOIN (
			SELECT "issueId", COUNT(*) as comment_count 
			FROM "Comment" 
			GROUP BY "issueId"
		) cm ON i.id = cm."issueId"
		WHERE ST_Within(
			i.location,
			ST_MakeEnvelope(${minLng}, ${minLat}, ${maxLng}, ${maxLat}, 4326)
		)
		${typeFilter}
		${statusFilter}
		ORDER BY i."createdAt" DESC
	`;

	return issues.map(issue => ({
		...issue,
		_count: {
			upvotes: issue.upvote_count,
			comments: issue.comment_count,
		}
	}));
}

// Add new function for distance-based queries (e.g., "issues within 5km")
export async function getIssuesWithinDistance(
	centerLat: number,
	centerLng: number,
	distanceMeters: number,
	filters?: { type?: IssueType; status?: IssueStatus }
) {
	let typeFilter = '';
	let statusFilter = '';
	
	if (filters?.type) {
		typeFilter = `AND i."issueType" = ${filters.type}::"IssueType"`;
	}
	
	if (filters?.status) {
		statusFilter = `AND i.status = ${filters.status}::"IssueStatus"`;
	}

	const issues = await prisma.$queryRaw<Array<{
		id: number;
		title: string;
		description: string;
		latitude: number;
		longitude: number;
		distance_meters: number;
		status: string;
		issueType: string;
		createdAt: Date;
	}>>`
		SELECT 
			i.id, i.title, i.description,
			ST_Y(i.location) as latitude,
			ST_X(i.location) as longitude,
			ST_Distance(
				i.location::geography,
				ST_SetSRID(ST_MakePoint(${centerLng}, ${centerLat}), 4326)::geography
			) as distance_meters,
			i.status, i."issueType", i."createdAt"
		FROM "Issue" i
		WHERE ST_DWithin(
			i.location::geography,
			ST_SetSRID(ST_MakePoint(${centerLng}, ${centerLat}), 4326)::geography,
			${distanceMeters}
		)
		${typeFilter}
		${statusFilter}
		ORDER BY distance_meters ASC
	`;

	return issues;
}

// Issue Interaction (Upvotes and Resolution)
export async function addIssueUpvote(userId: number, issueId: number) {
	const upvote = await prisma.issueUpvote.create({ data: { userId, issueId } });
	return upvote;
}

export async function removeIssueUpvote(userId: number, issueId: number) {
	const res = await prisma.issueUpvote.deleteMany({ where: { userId, issueId } });
	return res.count > 0;
}

export async function getIssueUpvoteCount(issueId: number) {
	const count = await prisma.issueUpvote.count({ where: { issueId } });
	return count;
}

export async function hasUserUpvotedIssue(userId: number, issueId: number) {
	const count = await prisma.issueUpvote.count({ where: { userId, issueId } });
	return count > 0;
}

export async function submitResolutionVote(userId: number, issueId: number, isResolved: boolean) {
	const vote = await prisma.issueResolutionVote.upsert({
		where: { issueId_userId: { issueId, userId } },
		create: { issueId, userId, isResolved },
		update: { isResolved },
	});

	return vote;
}

export async function getResolutionVoteTally(issueId: number) {
	const [trueCount, falseCount] = await prisma.$transaction([
		prisma.issueResolutionVote.count({ where: { issueId, isResolved: true } }),
		prisma.issueResolutionVote.count({ where: { issueId, isResolved: false } }),
	]);

	return { trueCount, falseCount };
}

// Comments
export async function addComment(userId: number, issueId: number, content: string) {
	const comment = await prisma.comment.create({ data: { userId, issueId, content } });
	return comment;
}

export async function getCommentsForIssue(issueId: number) {
	const comments = await prisma.comment.findMany({
		where: { issueId },
		orderBy: { createdAt: 'asc' },
		include: {
			user: {
				select: {
					id: true,
					name: true,
					credibility: true,
					badges: { select: { name: true }, orderBy: { awardedAt: 'asc' } },
				},
			},
			upvotes: { select: { id: true, userId: true } },
		},
	});

	return comments;
}

export async function deleteComment(commentId: number) {
	const existing = await prisma.comment.findUnique({ where: { id: commentId } });
	if (!existing) return null;

	await prisma.$transaction([
		prisma.commentUpvote.deleteMany({ where: { commentId } }),
		prisma.comment.delete({ where: { id: commentId } }),
	]);

	return existing;
}

export async function flagComment(commentId: number, reason: string | null) {
	const comment = await prisma.comment.update({ where: { id: commentId }, data: { isFlagged: true, flaggedReason: reason ?? null } });
	return comment;
}

export async function addCommentUpvote(userId: number, commentId: number) {
	const upvote = await prisma.commentUpvote.create({ data: { userId, commentId } });
	return upvote;
}

export async function removeCommentUpvote(userId: number, commentId: number) {
	const res = await prisma.commentUpvote.deleteMany({ where: { userId, commentId } });
	return res.count > 0;
}

export async function getIssuesByUser(userId: number) {
	const issues = await prisma.$queryRaw<Array<{
		id: number;
		title: string;
		description: string;
		latitude: number;
		longitude: number;
		status: string;
		issueType: string;
		createdAt: Date;
		imageBlobId: string | null;
	}>>`
		SELECT 
			i.id, i.title, i.description,
			ST_Y(i.location) as latitude,
			ST_X(i.location) as longitude,
			i.status, i."issueType", i."createdAt", i."imageBlobId"
		FROM "Issue" i
		WHERE i."userId" = ${userId}
		AND i.location IS NOT NULL
		ORDER BY i."createdAt" DESC
	`;
	return issues;
}

export async function getIssuesByStatus(status: IssueStatus) {
	const issues = await prisma.$queryRaw<Array<{
		id: number;
		title: string;
		description: string;
		latitude: number;
		longitude: number;
		status: string;
		issueType: string;
		createdAt: Date;
		imageBlobId: string | null;
	}>>`
		SELECT 
			i.id, i.title, i.description,
			ST_Y(i.location) as latitude,
			ST_X(i.location) as longitude,
			i.status, i."issueType", i."createdAt", i."imageBlobId"
		FROM "Issue" i
		WHERE i.status = ${status}::"IssueStatus"
		AND i.location IS NOT NULL
		ORDER BY i."createdAt" DESC
	`;
	return issues;
}

export async function getIssuesByGuestToken(guestTokenId: number) {
	const issues = await prisma.$queryRaw<Array<{
		id: number;
		title: string;
		description: string;
		latitude: number;
		longitude: number;
		status: string;
		issueType: string;
		createdAt: Date;
		imageBlobId: string | null;
	}>>`
		SELECT 
			i.id, i.title, i.description,
			ST_Y(i.location) as latitude,
			ST_X(i.location) as longitude,
			i.status, i."issueType", i."createdAt", i."imageBlobId"
		FROM "Issue" i
		WHERE i."guestTokenId" = ${guestTokenId}
		AND i.location IS NOT NULL
		ORDER BY i."createdAt" DESC
	`;
	return issues;
}

export default {
	createAuthenticatedIssue,
	createGuestIssue,
	updateIssueImage,
	updateIssueStatus,
	authorizeIssue,
	flagIssueError,
	deleteIssue,
	getIssueById,
	getIssuesByLocationBox,
	getIssuesWithinDistance,
	getIssuesByStatus,
	getIssuesByUser,
	getIssuesByGuestToken,
	addIssueUpvote,
	removeIssueUpvote,
	getIssueUpvoteCount,
	hasUserUpvotedIssue,
	submitResolutionVote,
	getResolutionVoteTally,
	addComment,
	getCommentsForIssue,
	deleteComment,
	flagComment,
	addCommentUpvote,
	removeCommentUpvote,
};
</code>

## segfault-backend\src\data\notification.ts
<code>
// Notification DB helpers
import { prisma } from "./prisma/prismaClient";
import { NotificationType } from "../generated/prisma/enums";

export async function createNotification(userId: number, type: NotificationType, message: string) {
  const notif = await prisma.notification.create({ data: { userId, type, message } });
  return notif;
}

export async function getUserNotifications(userId: number) {
  const notifs = await prisma.notification.findMany({ where: { userId }, orderBy: { createdAt: 'desc' } });
  return notifs;
}

// Accept one or many notification ids to mark as read
export async function markNotificationAsRead(notificationIds: number[] | number) {
  const ids = Array.isArray(notificationIds) ? notificationIds : [notificationIds];
  const res = await prisma.notification.updateMany({ where: { id: { in: ids } }, data: { read: true } });
  return res.count;
}

export async function markAllNotificationsAsRead(userId: number) {
  const res = await prisma.notification.updateMany({ where: { userId, read: false }, data: { read: true } });
  return res.count;
}

export default {
  createNotification,
  getUserNotifications,
  markNotificationAsRead,
  markAllNotificationsAsRead,
};

</code>

## segfault-backend\src\data\redisClient.ts
<code>
/**
 * Azure Redis Cache Client
 * Uses REDIS_HOSTNAME and REDIS_ACCESS_KEY environment variables
 */

import { createClient } from "redis";

const redisHostname = process.env.REDIS_HOSTNAME || "";
const redisPassword = process.env.REDIS_ACCESS_KEY || "";
const redisPort = 6380; // Azure Redis SSL port

type RedisClient = ReturnType<typeof createClient>;
let client: RedisClient | null = null;
let connectionPromise: Promise<RedisClient> | null = null;
let isConnecting = false;

async function getClient(): Promise<RedisClient | null> {
	if (!redisHostname || !redisPassword) {
		console.warn("Azure Redis Cache not configured. Using no-op fallback.");
		return null;
	}

	if (client?.isOpen) {
		return client;
	}

	// Return existing connection promise if connecting
	if (isConnecting && connectionPromise) {
		return connectionPromise;
	}

	isConnecting = true;
	connectionPromise = (async () => {
		try {
			client = createClient({
				url: `rediss://:${encodeURIComponent(redisPassword)}@${redisHostname}:${redisPort}`,
				socket: {
					tls: true,
					rejectUnauthorized: false, // Azure Redis uses self-signed certs
					connectTimeout: 10000,
				},
			});

			client.on("error", (err) => {
				console.error("Redis Client Error:", err);
			});

			client.on("connect", () => {
				console.log("Redis: Connected to Azure Redis Cache");
			});

			await client.connect();
			return client;
		} catch (error) {
			console.error("Failed to connect to Redis:", error);
			client = null;
			throw error;
		} finally {
			isConnecting = false;
		}
	})();

	return connectionPromise;
}

// Wrapper class that matches the FakeRedisClient API
class AzureRedisClient {
	// Basic string operations
	async get(key: string): Promise<string | null> {
		const c = await getClient();
		if (!c) return null;
		try {
			return await c.get(key);
		} catch (error) {
			console.error("Redis GET error:", error);
			return null;
		}
	}

	async set(key: string, value: string, mode?: string | null, durationSeconds?: number | null): Promise<"OK"> {
		const c = await getClient();
		if (!c) return "OK";
		try {
			if (mode === "EX" && typeof durationSeconds === "number" && durationSeconds > 0) {
				await c.setEx(key, durationSeconds, value);
			} else {
				await c.set(key, value);
			}
			return "OK";
		} catch (error) {
			console.error("Redis SET error:", error);
			return "OK";
		}
	}

	async setex(key: string, seconds: number, value: string): Promise<"OK"> {
		return this.set(key, value, "EX", seconds);
	}

	async del(...keys: string[]): Promise<number> {
		const c = await getClient();
		if (!c || keys.length === 0) return 0;
		try {
			return await c.del(keys);
		} catch (error) {
			console.error("Redis DEL error:", error);
			return 0;
		}
	}

	async mget(...keys: string[]): Promise<(string | null)[]> {
		const c = await getClient();
		if (!c) return keys.map(() => null);
		try {
			return await c.mGet(keys);
		} catch (error) {
			console.error("Redis MGET error:", error);
			return keys.map(() => null);
		}
	}

	/**
	 * Pipelined SETEX for many keys in a single Redis round-trip.
	 * Uses MULTI/EXEC under the hood.
	 */
	async setexMany(entries: Array<{ key: string; seconds: number; value: string }>): Promise<void> {
		const c = await getClient();
		if (!c || entries.length === 0) return;
		try {
			const multi = c.multi();
			for (const entry of entries) {
				if (!entry?.key) continue;
				if (!Number.isFinite(entry.seconds) || entry.seconds <= 0) continue;
				multi.setEx(entry.key, entry.seconds, entry.value);
			}
			await multi.exec();
		} catch (error) {
			console.error("Redis SETEX MANY error:", error);
		}
	}

	async exists(...keys: string[]): Promise<number> {
		const c = await getClient();
		if (!c) return 0;
		try {
			return await c.exists(keys);
		} catch (error) {
			console.error("Redis EXISTS error:", error);
			return 0;
		}
	}

	async keys(pattern: string): Promise<string[]> {
		const c = await getClient();
		if (!c) return [];
		try {
			return await c.keys(pattern);
		} catch (error) {
			console.error("Redis KEYS error:", error);
			return [];
		}
	}

	async ttl(key: string): Promise<number> {
		const c = await getClient();
		if (!c) return -1;
		try {
			return await c.ttl(key);
		} catch (error) {
			console.error("Redis TTL error:", error);
			return -1;
		}
	}

	async expire(key: string, seconds: number): Promise<number> {
		const c = await getClient();
		if (!c) return 0;
		try {
			return (await c.expire(key, seconds)) ? 1 : 0;
		} catch (error) {
			console.error("Redis EXPIRE error:", error);
			return 0;
		}
	}

	// Hash operations
	async hset(key: string, field: string, value: string): Promise<number> {
		const c = await getClient();
		if (!c) return 0;
		try {
			return await c.hSet(key, field, value);
		} catch (error) {
			console.error("Redis HSET error:", error);
			return 0;
		}
	}

	async hget(key: string, field: string): Promise<string | null> {
		const c = await getClient();
		if (!c) return null;
		try {
			const result = await c.hGet(key, field);
			return result ?? null;
		} catch (error) {
			console.error("Redis HGET error:", error);
			return null;
		}
	}

	async hgetall(key: string): Promise<Record<string, string>> {
		const c = await getClient();
		if (!c) return {};
		try {
			return await c.hGetAll(key);
		} catch (error) {
			console.error("Redis HGETALL error:", error);
			return {};
		}
	}

	async hdel(key: string, ...fields: string[]): Promise<number> {
		const c = await getClient();
		if (!c) return 0;
		try {
			return await c.hDel(key, fields);
		} catch (error) {
			console.error("Redis HDEL error:", error);
			return 0;
		}
	}

	async flushAll(): Promise<"OK"> {
		const c = await getClient();
		if (!c) return "OK";
		try {
			await c.flushAll();
			return "OK";
		} catch (error) {
			console.error("Redis FLUSHALL error:", error);
			return "OK";
		}
	}
}

export const redisClient = new AzureRedisClient();

export default redisClient;

</code>

## segfault-backend\src\data\user.ts
<code>
// Database access for user related operations
import { prisma } from "./prisma/prismaClient";
import { UserRole } from "../generated/prisma/enums";
// import type { User } from "./src/generated/prisma/client";

// Pass in the hashed password. Must define a role. Dont use this for a guest- skip login entirely
export async function createNewUser(email: string, password: string, name: string | null, role: UserRole, picture: string | null = null) {
	const user = await prisma.user.create({
		data: {
			email,
			password,
			name,
			role,
			picture,
		},
	});

	return user;
}

export async function getUserById(id: number) {
	const user = await prisma.user.findUnique({
		where: { id },
	});

	return user;
}

export async function getUserByEmail(email: string) {
	const user = await prisma.user.findUnique({
		where: { email },
	});

	return user;
}

export async function updateUserProfile(
	userId: number,
	data: { name?: string | null; email?: string },
) {
	const upsert = await prisma.user.update({
		where: { id: userId },
		data: {
			...(data.name !== undefined ? { name: data.name } : {}),
			...(data.email !== undefined ? { email: data.email } : {}),
		},
	});

	return upsert;
}

export async function updateUserPassword(userId: number, newHashedPassword: string) {
	const user = await prisma.user.update({
		where: { id: userId },
		data: { password: newHashedPassword },
	});

	return user;
}

export async function deleteUser(userId: number) {
	const existingUser = await prisma.user.findUnique({ where: { id: userId } });
	if (!existingUser) return null;

	await prisma.$transaction([
		prisma.commentUpvote.deleteMany({ where: { userId } }),
		prisma.issueUpvote.deleteMany({ where: { userId } }),
		prisma.issueResolutionVote.deleteMany({ where: { userId } }),
		prisma.comment.deleteMany({ where: { userId } }),
		prisma.userBadge.deleteMany({ where: { userId } }),
		prisma.notification.deleteMany({ where: { userId } }),
		prisma.issue.deleteMany({ where: { userId } }),
		prisma.user.delete({ where: { id: userId } }),
	]);

	return existingUser;
}

export async function banUser(userId: number, reason: string | null, expiresAt: Date | null) {
	const user = await prisma.user.update({
		where: { id: userId },
		data: {
			isBanned: true,
			banReason: reason ?? null,
			banExpiresAt: expiresAt ?? null,
		},
	});

	return user;
}

export async function unbanUser(userId: number) {
	const user = await prisma.user.update({
		where: { id: userId },
		data: {
			isBanned: false,
			banReason: null,
			banExpiresAt: null,
		},
	});

	return user;
}

export async function updateUserCredibility(userId: number, delta: number) {
	const user = await prisma.user.update({
		where: { id: userId },
		data: {
			credibility: { increment: delta },
		},
	});

	return user;
}

export async function getAllUsers(page = 1, pageSize = 50) {
	const take = pageSize;
	const skip = (page - 1) * pageSize;

	const [users, total] = await prisma.$transaction([
		prisma.user.findMany({ skip, take, orderBy: { id: 'asc' } }),
		prisma.user.count(),
	]);

	return { users, total, page, pageSize };
}

// gets ALL users
export async function getAllUsersUnsafe() {
	const users = await prisma.user.findMany({ orderBy: { id: 'asc' } });
	return users;
}

export async function getBannedUsers(page = 1, pageSize = 50) {
	const take = pageSize;
	const skip = (page - 1) * pageSize;

	const [users, total] = await prisma.$transaction([
		prisma.user.findMany({ where: { isBanned: true }, skip, take, orderBy: { id: 'asc' } }),
		prisma.user.count({ where: { isBanned: true } }),
	]);

	return { users, total, page, pageSize };
}

export async function getBannedUsersUnsafe() {
	const users = await prisma.user.findMany({ where: { isBanned: true }, orderBy: { id: 'asc' } });
	return users;
}

export async function awardBadgeToUser(userId: number, name: string) {
	const badge = await prisma.userBadge.create({ data: { userId, name } });
	return badge;
}

export async function removeBadgeFromUser(badgeId: number) {
	const existing = await prisma.userBadge.findUnique({ where: { id: badgeId } });
	if (!existing) return null;

	const deleted = await prisma.userBadge.delete({ where: { id: badgeId } });
	return deleted;
}

export async function getBadgesForUser(userId: number) {
	const badges = await prisma.userBadge.findMany({ where: { userId }, orderBy: { awardedAt: 'desc' } });
	return badges;
}

export async function createGuestToken(token: string) {
	const guest = await prisma.guestToken.create({ data: { token } });
	return guest;
}

export async function getGuestTokenByToken(token: string) {
	const guest = await prisma.guestToken.findUnique({ where: { token } });
	return guest;
}

export async function deleteGuestToken(token: string) {
	const existing = await prisma.guestToken.findUnique({ where: { token } });
	if (!existing) return null;

	const deleted = await prisma.guestToken.delete({ where: { token } });
	return deleted;
}

export async function getNotificationsForUser(userId: number) {
	const notifications = await prisma.notification.findMany({ where: { userId }, orderBy: { createdAt: 'desc' } });
	return notifications;
}

export async function setNotificationRead(notificationId: number, read: boolean) {
	const notif = await prisma.notification.update({ where: { id: notificationId }, data: { read } });
	return notif;
}

export default {
	createNewUser,
	getUserById,
	getUserByEmail,
	updateUserProfile,
	updateUserPassword,
	deleteUser,
	banUser,
	unbanUser,
	updateUserCredibility,
	getAllUsers,
	getAllUsersUnsafe,
	getBannedUsers,
	getBannedUsersUnsafe,
	awardBadgeToUser,
	removeBadgeFromUser,
	getBadgesForUser,
	createGuestToken,
	getGuestTokenByToken,
	deleteGuestToken,
	getNotificationsForUser,
	setNotificationRead,
};
</code>

## segfault-backend\src\data\prisma\prismaClient.ts
<code>
import { PrismaClient } from "../../generated/prisma/client"

const globalForPrisma = global as unknown as { prisma: PrismaClient | undefined };

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
    log: ['warn', 'error'],
});

globalForPrisma.prisma = prisma;
</code>

## segfault-backend\src\data\prisma\schema.prisma
<code>
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 *  Under no circumstances should you import this file directly! 
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "./prismaNamespace"


const config: runtime.GetPrismaClientConfig = {
  "generator": {
    "name": "client",
    "provider": {
      "fromEnvVar": null,
      "value": "prisma-client"
    },
    "output": {
      "value": "/Users/aryannath/Important/Semester 7/Design Practices in CS/Issue Tracker/project-2-segfault2/segfault-backend/src/data/src/generated/prisma",
      "fromEnvVar": null
    },
    "config": {
      "engineType": "library"
    },
    "binaryTargets": [
      {
        "fromEnvVar": null,
        "value": "darwin-arm64",
        "native": true
      }
    ],
    "previewFeatures": [],
    "sourceFilePath": "/Users/aryannath/Important/Semester 7/Design Practices in CS/Issue Tracker/project-2-segfault2/segfault-backend/src/data/prisma/schema.prisma",
    "isCustomOutput": true
  },
  "relativePath": "../../../prisma",
  "clientVersion": "6.19.0",
  "engineVersion": "2ba551f319ab1df4bc874a89965d8b3641056773",
  "datasourceNames": [
    "db"
  ],
  "activeProvider": "postgresql",
  "postinstall": false,
  "inlineDatasources": {
    "db": {
      "url": {
        "fromEnvVar": "DATABASE_URL",
        "value": null
      }
    }
  },
  "inlineSchema": "generator client {\n  provider = \"prisma-client\"\n  output   = \"../src/generated/prisma\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// Primary user stuff\nenum UserRole {\n  USER\n  ADMIN\n  GUEST\n  PIGS\n}\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  password  String\n  name      String?\n  createdAt DateTime @default(now())\n\n  issues          Issue[]\n  comments        Comment[]\n  commentUpvotes  CommentUpvote[]\n  issueUpvotes    IssueUpvote[]\n  resolutionVotes IssueResolutionVote[]\n\n  role         UserRole  @default(USER)\n  isBanned     Boolean   @default(false)\n  banExpiresAt DateTime?\n  banReason    String?\n\n  credibility Int         @default(0)\n  badges      UserBadge[]\n\n  notifications Notification[]\n}\n\n// Would this need an image?\nmodel UserBadge {\n  id        Int      @id @default(autoincrement())\n  name      String\n  awardedAt DateTime @default(now())\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n}\n\n// Support for guest- store this in local storage\nmodel GuestToken {\n  id        Int      @id @default(autoincrement())\n  token     String   @unique\n  createdAt DateTime @default(now())\n\n  issues Issue[]\n}\n\n// Issue stuff\n\nmodel Issue {\n  id          Int             @id @default(autoincrement())\n  title       String\n  description String\n  location    Unsupported(\"geometry(Point, 4326)\")?\n  status      IssueStatus     @default(PENDING)\n  authorized  IssueAuthorized @default(FALSE)\n  error       IssueError      @default(PENDING)\n  createdAt   DateTime        @default(now())\n\n  imageBlobId String?\n  severity    Int?\n\n  userId   Int\n  user     User      @relation(fields: [userId], references: [id])\n  comments Comment[]\n\n  guestTokenId Int?\n  guestToken   GuestToken? @relation(fields: [guestTokenId], references: [id])\n\n  upvotes         IssueUpvote[]\n  resolutionVotes IssueResolutionVote[]\n\n  issueType IssueType\n\n  @@index([issueType])\n  @@index([userId])\n}\n\nenum IssueStatus {\n  PENDING\n  IN_PROGRESS\n  RESOLVED\n}\n\nenum IssueAuthorized {\n  TRUE\n  FALSE\n}\n\nenum IssueError {\n  NONE\n  INVALID_LOCATION\n  INAPPROPRIATE_CONTENT\n  PENDING\n}\n\nmodel IssueUpvote {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  @@unique([issueId, userId])\n}\n\n// Each vote for an issue\nmodel IssueResolutionVote {\n  id         Int      @id @default(autoincrement())\n  createdAt  DateTime @default(now())\n  isResolved Boolean\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  @@unique([issueId, userId])\n}\n\nenum IssueType {\n  POTHOLE\n  ROAD_DAMAGE\n  STREETLIGHT_FAULT\n  GARBAGE_UNCOLLECTED\n  ILLEGAL_DUMPING\n  DRAINAGE_BLOCKED\n  SEWAGE_OVERFLOW\n  WATER_SUPPLY_ISSUE\n  LOW_WATER_PRESSURE\n  OPEN_MANHOLE\n  BROKEN_FOOTPATH\n  ILLEGAL_ENCROACHMENT\n  STRAY_CATTLE\n  TREE_FALL\n  TRAFFIC_LIGHT_FAULT\n  MOSQUITO_BREEDING\n  NOISE_COMPLAINT\n  BUILDING_SAFETY\n}\n\nmodel Comment {\n  id        Int      @id @default(autoincrement())\n  content   String\n  createdAt DateTime @default(now())\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  upvotes CommentUpvote[]\n\n  isFlagged     Boolean @default(false)\n  flaggedReason String?\n}\n\nmodel CommentUpvote {\n  id Int @id @default(autoincrement())\n\n  commentId Int\n  comment   Comment @relation(fields: [commentId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  createdAt DateTime @default(now())\n\n  @@unique([commentId, userId])\n}\n\nmodel Notification {\n  id        Int              @id @default(autoincrement())\n  type      NotificationType @default(GENERAL)\n  message   String\n  createdAt DateTime         @default(now())\n  read      Boolean          @default(false)\n\n  userId Int?\n  user   User? @relation(fields: [userId], references: [id])\n}\n\nenum NotificationType {\n  ISSUE_STATUS_UPDATE\n  NEW_COMMENT\n  GENERAL\n  BAN_NOTICE\n  REMOVAL_NOTICE\n  UPVOTE_RECEIVED\n}\n",
  "inlineSchemaHash": "7f800df0f4b5a862647fb689994066a38cb1ca15ad09378ab6ee911131c57f80",
  "copyEngine": true,
  "runtimeDataModel": {
    "models": {},
    "enums": {},
    "types": {}
  },
  "dirname": ""
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"password\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issues\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"commentUpvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"CommentUpvote\",\"nativeType\":null,\"relationName\":\"CommentUpvoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueUpvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueUpvote\",\"nativeType\":null,\"relationName\":\"IssueUpvoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"resolutionVotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueResolutionVote\",\"nativeType\":null,\"relationName\":\"IssueResolutionVoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"role\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"UserRole\",\"nativeType\":null,\"default\":\"USER\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isBanned\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"banExpiresAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"banReason\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"credibility\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":0,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"badges\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"UserBadge\",\"nativeType\":null,\"relationName\":\"UserToUserBadge\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notifications\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Notification\",\"nativeType\":null,\"relationName\":\"NotificationToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"UserBadge\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"awardedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"UserToUserBadge\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"GuestToken\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"token\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issues\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"GuestTokenToIssue\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Issue\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueStatus\",\"nativeType\":null,\"default\":\"PENDING\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"authorized\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueAuthorized\",\"nativeType\":null,\"default\":\"FALSE\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"error\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueError\",\"nativeType\":null,\"default\":\"PENDING\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"imageBlobId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToIssue\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"guestTokenId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"guestToken\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"GuestToken\",\"nativeType\":null,\"relationName\":\"GuestTokenToIssue\",\"relationFromFields\":[\"guestTokenId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"upvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueUpvote\",\"nativeType\":null,\"relationName\":\"IssueToIssueUpvote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"resolutionVotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueResolutionVote\",\"nativeType\":null,\"relationName\":\"IssueToIssueResolutionVote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueType\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueType\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"IssueUpvote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToIssueUpvote\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueUpvoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"issueId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"issueId\",\"userId\"]}],\"isGenerated\":false},\"IssueResolutionVote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isResolved\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToIssueResolutionVote\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueResolutionVoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"issueId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"issueId\",\"userId\"]}],\"isGenerated\":false},\"Comment\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"CommentToIssue\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"CommentToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"upvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"CommentUpvote\",\"nativeType\":null,\"relationName\":\"CommentToCommentUpvote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isFlagged\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"flaggedReason\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"CommentUpvote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"commentId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToCommentUpvote\",\"relationFromFields\":[\"commentId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"CommentUpvoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"commentId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"commentId\",\"userId\"]}],\"isGenerated\":false},\"Notification\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"type\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"NotificationType\",\"nativeType\":null,\"default\":\"GENERAL\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"message\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"read\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"NotificationToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{\"UserRole\":{\"values\":[{\"name\":\"USER\",\"dbName\":null},{\"name\":\"ADMIN\",\"dbName\":null},{\"name\":\"GUEST\",\"dbName\":null},{\"name\":\"PIGS\",\"dbName\":null}],\"dbName\":null},\"IssueStatus\":{\"values\":[{\"name\":\"PENDING\",\"dbName\":null},{\"name\":\"IN_PROGRESS\",\"dbName\":null},{\"name\":\"RESOLVED\",\"dbName\":null}],\"dbName\":null},\"IssueAuthorized\":{\"values\":[{\"name\":\"TRUE\",\"dbName\":null},{\"name\":\"FALSE\",\"dbName\":null}],\"dbName\":null},\"IssueError\":{\"values\":[{\"name\":\"NONE\",\"dbName\":null},{\"name\":\"INVALID_LOCATION\",\"dbName\":null},{\"name\":\"INAPPROPRIATE_CONTENT\",\"dbName\":null},{\"name\":\"PENDING\",\"dbName\":null}],\"dbName\":null},\"IssueType\":{\"values\":[{\"name\":\"POTHOLE\",\"dbName\":null},{\"name\":\"ROAD_DAMAGE\",\"dbName\":null},{\"name\":\"STREETLIGHT_FAULT\",\"dbName\":null},{\"name\":\"GARBAGE_UNCOLLECTED\",\"dbName\":null},{\"name\":\"ILLEGAL_DUMPING\",\"dbName\":null},{\"name\":\"DRAINAGE_BLOCKED\",\"dbName\":null},{\"name\":\"SEWAGE_OVERFLOW\",\"dbName\":null},{\"name\":\"WATER_SUPPLY_ISSUE\",\"dbName\":null},{\"name\":\"LOW_WATER_PRESSURE\",\"dbName\":null},{\"name\":\"OPEN_MANHOLE\",\"dbName\":null},{\"name\":\"BROKEN_FOOTPATH\",\"dbName\":null},{\"name\":\"ILLEGAL_ENCROACHMENT\",\"dbName\":null},{\"name\":\"STRAY_CATTLE\",\"dbName\":null},{\"name\":\"TREE_FALL\",\"dbName\":null},{\"name\":\"TRAFFIC_LIGHT_FAULT\",\"dbName\":null},{\"name\":\"MOSQUITO_BREEDING\",\"dbName\":null},{\"name\":\"NOISE_COMPLAINT\",\"dbName\":null},{\"name\":\"BUILDING_SAFETY\",\"dbName\":null}],\"dbName\":null},\"NotificationType\":{\"values\":[{\"name\":\"ISSUE_STATUS_UPDATE\",\"dbName\":null},{\"name\":\"NEW_COMMENT\",\"dbName\":null},{\"name\":\"GENERAL\",\"dbName\":null},{\"name\":\"BAN_NOTICE\",\"dbName\":null},{\"name\":\"REMOVAL_NOTICE\",\"dbName\":null},{\"name\":\"UPVOTE_RECEIVED\",\"dbName\":null}],\"dbName\":null}},\"types\":{}}")
config.engineWasm = undefined
config.compilerWasm = undefined




export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never

export interface PrismaClientConstructor {
    /**
   * ## Prisma Client
   * 
   * Type-safe database client for TypeScript
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  new <
    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    LogOpts extends LogOptions<Options> = LogOptions<Options>,
    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
  >(options?: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */

export interface PrismaClient<
  in LogOpts extends Prisma.LogLevel = never,
  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = Prisma.PrismaClientOptions['omit'],
  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): runtime.Types.Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>


  $extends: runtime.Types.Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.guestToken`: Exposes CRUD operations for the **GuestToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuestTokens
    * const guestTokens = await prisma.guestToken.findMany()
    * ```
    */
  get guestToken(): Prisma.GuestTokenDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issue`: Exposes CRUD operations for the **Issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
  get issue(): Prisma.IssueDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issueUpvote`: Exposes CRUD operations for the **IssueUpvote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueUpvotes
    * const issueUpvotes = await prisma.issueUpvote.findMany()
    * ```
    */
  get issueUpvote(): Prisma.IssueUpvoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issueResolutionVote`: Exposes CRUD operations for the **IssueResolutionVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueResolutionVotes
    * const issueResolutionVotes = await prisma.issueResolutionVote.findMany()
    * ```
    */
  get issueResolutionVote(): Prisma.IssueResolutionVoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.commentUpvote`: Exposes CRUD operations for the **CommentUpvote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentUpvotes
    * const commentUpvotes = await prisma.commentUpvote.findMany()
    * ```
    */
  get commentUpvote(): Prisma.CommentUpvoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, { omit: OmitOpts }>;
}

export function getPrismaClientClass(dirname: string): PrismaClientConstructor {
  config.dirname = dirname
  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}
</code>

## segfault-backend\src\data\src\generated\prisma\client.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.
 * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.
 * 
 *  You can import this file directly.
 */

import * as process from 'node:process'
import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
globalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))

import * as runtime from "@prisma/client/runtime/library"
import * as $Enums from "./enums"
import * as $Class from "./internal/class"
import * as Prisma from "./internal/prismaNamespace"

export * as $Enums from './enums'
export * from "./enums"
/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export const PrismaClient = $Class.getPrismaClientClass(__dirname)
export type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions["omit"] = Prisma.PrismaClientOptions["omit"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>
export { Prisma }


// file annotations for bundling tools to include these files
path.join(__dirname, "libquery_engine-darwin-arm64.dylib.node")
path.join(process.cwd(), "src/data/src/generated/prisma/libquery_engine-darwin-arm64.dylib.node")

/**
 * Model User
 * 
 */
export type User = Prisma.UserModel
/**
 * Model UserBadge
 * 
 */
export type UserBadge = Prisma.UserBadgeModel
/**
 * Model GuestToken
 * 
 */
export type GuestToken = Prisma.GuestTokenModel
/**
 * Model Issue
 * 
 */
export type Issue = Prisma.IssueModel
/**
 * Model IssueUpvote
 * 
 */
export type IssueUpvote = Prisma.IssueUpvoteModel
/**
 * Model IssueResolutionVote
 * 
 */
export type IssueResolutionVote = Prisma.IssueResolutionVoteModel
/**
 * Model Comment
 * 
 */
export type Comment = Prisma.CommentModel
/**
 * Model CommentUpvote
 * 
 */
export type CommentUpvote = Prisma.CommentUpvoteModel
/**
 * Model Notification
 * 
 */
export type Notification = Prisma.NotificationModel

</code>

## segfault-backend\src\data\src\generated\prisma\internal\class.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 *  Under no circumstances should you import this file directly! 
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "./prismaNamespace"


const config: runtime.GetPrismaClientConfig = {
  "generator": {
    "name": "client",
    "provider": {
      "fromEnvVar": null,
      "value": "prisma-client"
    },
    "output": {
      "value": "/Users/aryannath/Important/Semester 7/Design Practices in CS/Issue Tracker/project-2-segfault2/segfault-backend/src/data/src/generated/prisma",
      "fromEnvVar": null
    },
    "config": {
      "engineType": "library"
    },
    "binaryTargets": [
      {
        "fromEnvVar": null,
        "value": "darwin-arm64",
        "native": true
      }
    ],
    "previewFeatures": [],
    "sourceFilePath": "/Users/aryannath/Important/Semester 7/Design Practices in CS/Issue Tracker/project-2-segfault2/segfault-backend/src/data/prisma/schema.prisma",
    "isCustomOutput": true
  },
  "relativePath": "../../../prisma",
  "clientVersion": "6.19.0",
  "engineVersion": "2ba551f319ab1df4bc874a89965d8b3641056773",
  "datasourceNames": [
    "db"
  ],
  "activeProvider": "postgresql",
  "postinstall": false,
  "inlineDatasources": {
    "db": {
      "url": {
        "fromEnvVar": "DATABASE_URL",
        "value": null
      }
    }
  },
  "inlineSchema": "generator client {\n  provider = \"prisma-client\"\n  output   = \"../src/generated/prisma\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// Primary user stuff\nenum UserRole {\n  USER\n  ADMIN\n  GUEST\n  PIGS\n}\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  password  String\n  name      String?\n  createdAt DateTime @default(now())\n\n  issues          Issue[]\n  comments        Comment[]\n  commentUpvotes  CommentUpvote[]\n  issueUpvotes    IssueUpvote[]\n  resolutionVotes IssueResolutionVote[]\n\n  role         UserRole  @default(USER)\n  isBanned     Boolean   @default(false)\n  banExpiresAt DateTime?\n  banReason    String?\n\n  credibility Int         @default(0)\n  badges      UserBadge[]\n\n  notifications Notification[]\n}\n\n// Would this need an image?\nmodel UserBadge {\n  id        Int      @id @default(autoincrement())\n  name      String\n  awardedAt DateTime @default(now())\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n}\n\n// Support for guest- store this in local storage\nmodel GuestToken {\n  id        Int      @id @default(autoincrement())\n  token     String   @unique\n  createdAt DateTime @default(now())\n\n  issues Issue[]\n}\n\n// Issue stuff\n\nmodel Issue {\n  id          Int             @id @default(autoincrement())\n  title       String\n  description String\n  latitude    Float\n  longitude   Float\n  status      IssueStatus     @default(PENDING)\n  authorized  IssueAuthorized @default(FALSE)\n  error       IssueError      @default(PENDING)\n  createdAt   DateTime        @default(now())\n\n  imageBlobId String?\n\n  userId   Int\n  user     User      @relation(fields: [userId], references: [id])\n  comments Comment[]\n\n  guestTokenId Int?\n  guestToken   GuestToken? @relation(fields: [guestTokenId], references: [id])\n\n  upvotes         IssueUpvote[]\n  resolutionVotes IssueResolutionVote[]\n\n  issueType IssueType\n\n  @@index([issueType])\n  @@index([userId])\n  @@index([latitude, longitude])\n}\n\nenum IssueStatus {\n  PENDING\n  IN_PROGRESS\n  RESOLVED\n}\n\nenum IssueAuthorized {\n  TRUE\n  FALSE\n}\n\nenum IssueError {\n  NONE\n  INVALID_LOCATION\n  INAPPROPRIATE_CONTENT\n  PENDING\n}\n\nmodel IssueUpvote {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  @@unique([issueId, userId])\n}\n\n// Each vote for an issue\nmodel IssueResolutionVote {\n  id         Int      @id @default(autoincrement())\n  createdAt  DateTime @default(now())\n  isResolved Boolean\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  @@unique([issueId, userId])\n}\n\nenum IssueType {\n  POTHOLE\n  ROAD_DAMAGE\n  STREETLIGHT_FAULT\n  GARBAGE_UNCOLLECTED\n  ILLEGAL_DUMPING\n  DRAINAGE_BLOCKED\n  SEWAGE_OVERFLOW\n  WATER_SUPPLY_ISSUE\n  LOW_WATER_PRESSURE\n  OPEN_MANHOLE\n  BROKEN_FOOTPATH\n  ILLEGAL_ENCROACHMENT\n  STRAY_CATTLE\n  TREE_FALL\n  TRAFFIC_LIGHT_FAULT\n  MOSQUITO_BREEDING\n  NOISE_COMPLAINT\n  BUILDING_SAFETY\n}\n\nmodel Comment {\n  id        Int      @id @default(autoincrement())\n  content   String\n  createdAt DateTime @default(now())\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  upvotes CommentUpvote[]\n\n  isFlagged     Boolean @default(false)\n  flaggedReason String?\n}\n\nmodel CommentUpvote {\n  id Int @id @default(autoincrement())\n\n  commentId Int\n  comment   Comment @relation(fields: [commentId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  createdAt DateTime @default(now())\n\n  @@unique([commentId, userId])\n}\n\nmodel Notification {\n  id        Int              @id @default(autoincrement())\n  type      NotificationType @default(GENERAL)\n  message   String\n  createdAt DateTime         @default(now())\n  read      Boolean          @default(false)\n\n  userId Int?\n  user   User? @relation(fields: [userId], references: [id])\n}\n\nenum NotificationType {\n  ISSUE_STATUS_UPDATE\n  NEW_COMMENT\n  GENERAL\n  BAN_NOTICE\n  REMOVAL_NOTICE\n  UPVOTE_RECEIVED\n}\n",
  "inlineSchemaHash": "7f800df0f4b5a862647fb689994066a38cb1ca15ad09378ab6ee911131c57f80",
  "copyEngine": true,
  "runtimeDataModel": {
    "models": {},
    "enums": {},
    "types": {}
  },
  "dirname": ""
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"password\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issues\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"commentUpvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"CommentUpvote\",\"nativeType\":null,\"relationName\":\"CommentUpvoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueUpvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueUpvote\",\"nativeType\":null,\"relationName\":\"IssueUpvoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"resolutionVotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueResolutionVote\",\"nativeType\":null,\"relationName\":\"IssueResolutionVoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"role\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"UserRole\",\"nativeType\":null,\"default\":\"USER\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isBanned\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"banExpiresAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"banReason\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"credibility\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":0,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"badges\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"UserBadge\",\"nativeType\":null,\"relationName\":\"UserToUserBadge\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notifications\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Notification\",\"nativeType\":null,\"relationName\":\"NotificationToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"UserBadge\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"awardedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"UserToUserBadge\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"GuestToken\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"token\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issues\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"GuestTokenToIssue\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Issue\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"latitude\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"longitude\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueStatus\",\"nativeType\":null,\"default\":\"PENDING\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"authorized\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueAuthorized\",\"nativeType\":null,\"default\":\"FALSE\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"error\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueError\",\"nativeType\":null,\"default\":\"PENDING\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"imageBlobId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToIssue\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"guestTokenId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"guestToken\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"GuestToken\",\"nativeType\":null,\"relationName\":\"GuestTokenToIssue\",\"relationFromFields\":[\"guestTokenId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"upvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueUpvote\",\"nativeType\":null,\"relationName\":\"IssueToIssueUpvote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"resolutionVotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueResolutionVote\",\"nativeType\":null,\"relationName\":\"IssueToIssueResolutionVote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueType\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueType\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"IssueUpvote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToIssueUpvote\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueUpvoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"issueId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"issueId\",\"userId\"]}],\"isGenerated\":false},\"IssueResolutionVote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isResolved\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToIssueResolutionVote\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueResolutionVoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"issueId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"issueId\",\"userId\"]}],\"isGenerated\":false},\"Comment\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"CommentToIssue\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"CommentToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"upvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"CommentUpvote\",\"nativeType\":null,\"relationName\":\"CommentToCommentUpvote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isFlagged\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"flaggedReason\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"CommentUpvote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"commentId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToCommentUpvote\",\"relationFromFields\":[\"commentId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"CommentUpvoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"commentId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"commentId\",\"userId\"]}],\"isGenerated\":false},\"Notification\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"type\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"NotificationType\",\"nativeType\":null,\"default\":\"GENERAL\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"message\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"read\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"NotificationToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{\"UserRole\":{\"values\":[{\"name\":\"USER\",\"dbName\":null},{\"name\":\"ADMIN\",\"dbName\":null},{\"name\":\"GUEST\",\"dbName\":null},{\"name\":\"PIGS\",\"dbName\":null}],\"dbName\":null},\"IssueStatus\":{\"values\":[{\"name\":\"PENDING\",\"dbName\":null},{\"name\":\"IN_PROGRESS\",\"dbName\":null},{\"name\":\"RESOLVED\",\"dbName\":null}],\"dbName\":null},\"IssueAuthorized\":{\"values\":[{\"name\":\"TRUE\",\"dbName\":null},{\"name\":\"FALSE\",\"dbName\":null}],\"dbName\":null},\"IssueError\":{\"values\":[{\"name\":\"NONE\",\"dbName\":null},{\"name\":\"INVALID_LOCATION\",\"dbName\":null},{\"name\":\"INAPPROPRIATE_CONTENT\",\"dbName\":null},{\"name\":\"PENDING\",\"dbName\":null}],\"dbName\":null},\"IssueType\":{\"values\":[{\"name\":\"POTHOLE\",\"dbName\":null},{\"name\":\"ROAD_DAMAGE\",\"dbName\":null},{\"name\":\"STREETLIGHT_FAULT\",\"dbName\":null},{\"name\":\"GARBAGE_UNCOLLECTED\",\"dbName\":null},{\"name\":\"ILLEGAL_DUMPING\",\"dbName\":null},{\"name\":\"DRAINAGE_BLOCKED\",\"dbName\":null},{\"name\":\"SEWAGE_OVERFLOW\",\"dbName\":null},{\"name\":\"WATER_SUPPLY_ISSUE\",\"dbName\":null},{\"name\":\"LOW_WATER_PRESSURE\",\"dbName\":null},{\"name\":\"OPEN_MANHOLE\",\"dbName\":null},{\"name\":\"BROKEN_FOOTPATH\",\"dbName\":null},{\"name\":\"ILLEGAL_ENCROACHMENT\",\"dbName\":null},{\"name\":\"STRAY_CATTLE\",\"dbName\":null},{\"name\":\"TREE_FALL\",\"dbName\":null},{\"name\":\"TRAFFIC_LIGHT_FAULT\",\"dbName\":null},{\"name\":\"MOSQUITO_BREEDING\",\"dbName\":null},{\"name\":\"NOISE_COMPLAINT\",\"dbName\":null},{\"name\":\"BUILDING_SAFETY\",\"dbName\":null}],\"dbName\":null},\"NotificationType\":{\"values\":[{\"name\":\"ISSUE_STATUS_UPDATE\",\"dbName\":null},{\"name\":\"NEW_COMMENT\",\"dbName\":null},{\"name\":\"GENERAL\",\"dbName\":null},{\"name\":\"BAN_NOTICE\",\"dbName\":null},{\"name\":\"REMOVAL_NOTICE\",\"dbName\":null},{\"name\":\"UPVOTE_RECEIVED\",\"dbName\":null}],\"dbName\":null}},\"types\":{}}")
config.engineWasm = undefined
config.compilerWasm = undefined




export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never

export interface PrismaClientConstructor {
    /**
   * ## Prisma Client
   * 
   * Type-safe database client for TypeScript
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  new <
    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    LogOpts extends LogOptions<Options> = LogOptions<Options>,
    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
  >(options?: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */

export interface PrismaClient<
  in LogOpts extends Prisma.LogLevel = never,
  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = Prisma.PrismaClientOptions['omit'],
  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): runtime.Types.Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>


  $extends: runtime.Types.Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.guestToken`: Exposes CRUD operations for the **GuestToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuestTokens
    * const guestTokens = await prisma.guestToken.findMany()
    * ```
    */
  get guestToken(): Prisma.GuestTokenDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issue`: Exposes CRUD operations for the **Issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
  get issue(): Prisma.IssueDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issueUpvote`: Exposes CRUD operations for the **IssueUpvote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueUpvotes
    * const issueUpvotes = await prisma.issueUpvote.findMany()
    * ```
    */
  get issueUpvote(): Prisma.IssueUpvoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issueResolutionVote`: Exposes CRUD operations for the **IssueResolutionVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueResolutionVotes
    * const issueResolutionVotes = await prisma.issueResolutionVote.findMany()
    * ```
    */
  get issueResolutionVote(): Prisma.IssueResolutionVoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.commentUpvote`: Exposes CRUD operations for the **CommentUpvote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentUpvotes
    * const commentUpvotes = await prisma.commentUpvote.findMany()
    * ```
    */
  get commentUpvote(): Prisma.CommentUpvoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, { omit: OmitOpts }>;
}

export function getPrismaClientClass(dirname: string): PrismaClientConstructor {
  config.dirname = dirname
  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}

</code>

## segfault-backend\src\generated\prisma\browser.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file should be your main import to use Prisma-related types and utilities in a browser. 
 * Use it to get access to models, enums, and input types.
 * 
 * This file does not contain a `PrismaClient` class, nor several other helpers that are intended as server-side only.
 * See `client.ts` for the standard, server-side entry point.
 *
 *  You can import this file directly.
 */

import * as Prisma from './internal/prismaNamespaceBrowser'
export { Prisma }
export * as $Enums from './enums'
export * from './enums';
/**
 * Model User
 * 
 */
export type User = Prisma.UserModel
/**
 * Model UserBadge
 * 
 */
export type UserBadge = Prisma.UserBadgeModel
/**
 * Model GuestToken
 * 
 */
export type GuestToken = Prisma.GuestTokenModel
/**
 * Model Issue
 * 
 */
export type Issue = Prisma.IssueModel
/**
 * Model IssueUpvote
 * 
 */
export type IssueUpvote = Prisma.IssueUpvoteModel
/**
 * Model IssueResolutionVote
 * 
 */
export type IssueResolutionVote = Prisma.IssueResolutionVoteModel
/**
 * Model Comment
 * 
 */
export type Comment = Prisma.CommentModel
/**
 * Model CommentUpvote
 * 
 */
export type CommentUpvote = Prisma.CommentUpvoteModel
/**
 * Model Notification
 * 
 */
export type Notification = Prisma.NotificationModel
/**
 * Model GraphNode
 * 
 */
export type GraphNode = Prisma.GraphNodeModel
/**
 * Model GraphEdge
 * 
 */
export type GraphEdge = Prisma.GraphEdgeModel

</code>

## segfault-backend\src\generated\prisma\client.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.
 * If you're looking for something you can import in the client-side of your application, please refer to the `browser.ts` file instead.
 * 
 *  You can import this file directly.
 */

import * as process from 'node:process'
import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
globalThis['__dirname'] = path.dirname(fileURLToPath(import.meta.url))

import * as runtime from "@prisma/client/runtime/library"
import * as $Enums from "./enums"
import * as $Class from "./internal/class"
import * as Prisma from "./internal/prismaNamespace"

export * as $Enums from './enums'
export * from "./enums"
/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export const PrismaClient = $Class.getPrismaClientClass(__dirname)
export type PrismaClient<LogOpts extends Prisma.LogLevel = never, OmitOpts extends Prisma.PrismaClientOptions["omit"] = Prisma.PrismaClientOptions["omit"], ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = $Class.PrismaClient<LogOpts, OmitOpts, ExtArgs>
export { Prisma }


// file annotations for bundling tools to include these files
path.join(__dirname, "query_engine-windows.dll.node")
path.join(process.cwd(), "src/generated/prisma/query_engine-windows.dll.node")

// file annotations for bundling tools to include these files
path.join(__dirname, "libquery_engine-darwin-arm64.dylib.node")
path.join(process.cwd(), "src/generated/prisma/libquery_engine-darwin-arm64.dylib.node")

/**
 * Model User
 * 
 */
export type User = Prisma.UserModel
/**
 * Model UserBadge
 * 
 */
export type UserBadge = Prisma.UserBadgeModel
/**
 * Model GuestToken
 * 
 */
export type GuestToken = Prisma.GuestTokenModel
/**
 * Model Issue
 * 
 */
export type Issue = Prisma.IssueModel
/**
 * Model IssueUpvote
 * 
 */
export type IssueUpvote = Prisma.IssueUpvoteModel
/**
 * Model IssueResolutionVote
 * 
 */
export type IssueResolutionVote = Prisma.IssueResolutionVoteModel
/**
 * Model Comment
 * 
 */
export type Comment = Prisma.CommentModel
/**
 * Model CommentUpvote
 * 
 */
export type CommentUpvote = Prisma.CommentUpvoteModel
/**
 * Model Notification
 * 
 */
export type Notification = Prisma.NotificationModel
/**
 * Model GraphNode
 * 
 */
export type GraphNode = Prisma.GraphNodeModel
/**
 * Model GraphEdge
 * 
 */
export type GraphEdge = Prisma.GraphEdgeModel

</code>

## segfault-backend\src\generated\prisma\commonInputTypes.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports various common sort, input & filter types that are not directly linked to a particular model.
 *
 *  You can import this file directly.
 */

import type * as runtime from "@prisma/client/runtime/library"
import * as $Enums from "./enums"
import type * as Prisma from "./internal/prismaNamespace"


export type IntFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntFilter<$PrismaModel> | number
}

export type StringFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel>
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  mode?: Prisma.QueryMode
  not?: Prisma.NestedStringFilter<$PrismaModel> | string
}

export type BoolFilter<$PrismaModel = never> = {
  equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>
  not?: Prisma.NestedBoolFilter<$PrismaModel> | boolean
}

export type StringNullableFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  mode?: Prisma.QueryMode
  not?: Prisma.NestedStringNullableFilter<$PrismaModel> | string | null
}

export type DateTimeFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeFilter<$PrismaModel> | Date | string
}

export type EnumUserRoleFilter<$PrismaModel = never> = {
  equals?: $Enums.UserRole | Prisma.EnumUserRoleFieldRefInput<$PrismaModel>
  in?: $Enums.UserRole[] | Prisma.ListEnumUserRoleFieldRefInput<$PrismaModel>
  notIn?: $Enums.UserRole[] | Prisma.ListEnumUserRoleFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
}

export type DateTimeNullableFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel> | null
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
}

export type SortOrderInput = {
  sort: Prisma.SortOrder
  nulls?: Prisma.NullsOrder
}

export type IntWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntWithAggregatesFilter<$PrismaModel> | number
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatFilter<$PrismaModel>
  _sum?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedIntFilter<$PrismaModel>
  _max?: Prisma.NestedIntFilter<$PrismaModel>
}

export type StringWithAggregatesFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel>
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  mode?: Prisma.QueryMode
  not?: Prisma.NestedStringWithAggregatesFilter<$PrismaModel> | string
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedStringFilter<$PrismaModel>
  _max?: Prisma.NestedStringFilter<$PrismaModel>
}

export type BoolWithAggregatesFilter<$PrismaModel = never> = {
  equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>
  not?: Prisma.NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedBoolFilter<$PrismaModel>
  _max?: Prisma.NestedBoolFilter<$PrismaModel>
}

export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  mode?: Prisma.QueryMode
  not?: Prisma.NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedStringNullableFilter<$PrismaModel>
  _max?: Prisma.NestedStringNullableFilter<$PrismaModel>
}

export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedDateTimeFilter<$PrismaModel>
  _max?: Prisma.NestedDateTimeFilter<$PrismaModel>
}

export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.UserRole | Prisma.EnumUserRoleFieldRefInput<$PrismaModel>
  in?: $Enums.UserRole[] | Prisma.ListEnumUserRoleFieldRefInput<$PrismaModel>
  notIn?: $Enums.UserRole[] | Prisma.ListEnumUserRoleFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumUserRoleFilter<$PrismaModel>
  _max?: Prisma.NestedEnumUserRoleFilter<$PrismaModel>
}

export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel> | null
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedDateTimeNullableFilter<$PrismaModel>
  _max?: Prisma.NestedDateTimeNullableFilter<$PrismaModel>
}

export type EnumIssueStatusFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueStatus | Prisma.EnumIssueStatusFieldRefInput<$PrismaModel>
  in?: $Enums.IssueStatus[] | Prisma.ListEnumIssueStatusFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueStatus[] | Prisma.ListEnumIssueStatusFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueStatusFilter<$PrismaModel> | $Enums.IssueStatus
}

export type EnumIssueAuthorizedFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueAuthorized | Prisma.EnumIssueAuthorizedFieldRefInput<$PrismaModel>
  in?: $Enums.IssueAuthorized[] | Prisma.ListEnumIssueAuthorizedFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueAuthorized[] | Prisma.ListEnumIssueAuthorizedFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueAuthorizedFilter<$PrismaModel> | $Enums.IssueAuthorized
}

export type EnumIssueErrorFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueError | Prisma.EnumIssueErrorFieldRefInput<$PrismaModel>
  in?: $Enums.IssueError[] | Prisma.ListEnumIssueErrorFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueError[] | Prisma.ListEnumIssueErrorFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueErrorFilter<$PrismaModel> | $Enums.IssueError
}

export type IntNullableFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel> | null
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntNullableFilter<$PrismaModel> | number | null
}

export type EnumIssueTypeFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueType | Prisma.EnumIssueTypeFieldRefInput<$PrismaModel>
  in?: $Enums.IssueType[] | Prisma.ListEnumIssueTypeFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueType[] | Prisma.ListEnumIssueTypeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueTypeFilter<$PrismaModel> | $Enums.IssueType
}

export type EnumIssueStatusWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueStatus | Prisma.EnumIssueStatusFieldRefInput<$PrismaModel>
  in?: $Enums.IssueStatus[] | Prisma.ListEnumIssueStatusFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueStatus[] | Prisma.ListEnumIssueStatusFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel> | $Enums.IssueStatus
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumIssueStatusFilter<$PrismaModel>
  _max?: Prisma.NestedEnumIssueStatusFilter<$PrismaModel>
}

export type EnumIssueAuthorizedWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueAuthorized | Prisma.EnumIssueAuthorizedFieldRefInput<$PrismaModel>
  in?: $Enums.IssueAuthorized[] | Prisma.ListEnumIssueAuthorizedFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueAuthorized[] | Prisma.ListEnumIssueAuthorizedFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueAuthorizedWithAggregatesFilter<$PrismaModel> | $Enums.IssueAuthorized
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumIssueAuthorizedFilter<$PrismaModel>
  _max?: Prisma.NestedEnumIssueAuthorizedFilter<$PrismaModel>
}

export type EnumIssueErrorWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueError | Prisma.EnumIssueErrorFieldRefInput<$PrismaModel>
  in?: $Enums.IssueError[] | Prisma.ListEnumIssueErrorFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueError[] | Prisma.ListEnumIssueErrorFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueErrorWithAggregatesFilter<$PrismaModel> | $Enums.IssueError
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumIssueErrorFilter<$PrismaModel>
  _max?: Prisma.NestedEnumIssueErrorFilter<$PrismaModel>
}

export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel> | null
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatNullableFilter<$PrismaModel>
  _sum?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _max?: Prisma.NestedIntNullableFilter<$PrismaModel>
}

export type EnumIssueTypeWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueType | Prisma.EnumIssueTypeFieldRefInput<$PrismaModel>
  in?: $Enums.IssueType[] | Prisma.ListEnumIssueTypeFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueType[] | Prisma.ListEnumIssueTypeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel> | $Enums.IssueType
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumIssueTypeFilter<$PrismaModel>
  _max?: Prisma.NestedEnumIssueTypeFilter<$PrismaModel>
}

export type EnumNotificationTypeFilter<$PrismaModel = never> = {
  equals?: $Enums.NotificationType | Prisma.EnumNotificationTypeFieldRefInput<$PrismaModel>
  in?: $Enums.NotificationType[] | Prisma.ListEnumNotificationTypeFieldRefInput<$PrismaModel>
  notIn?: $Enums.NotificationType[] | Prisma.ListEnumNotificationTypeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
}

export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.NotificationType | Prisma.EnumNotificationTypeFieldRefInput<$PrismaModel>
  in?: $Enums.NotificationType[] | Prisma.ListEnumNotificationTypeFieldRefInput<$PrismaModel>
  notIn?: $Enums.NotificationType[] | Prisma.ListEnumNotificationTypeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumNotificationTypeFilter<$PrismaModel>
  _max?: Prisma.NestedEnumNotificationTypeFilter<$PrismaModel>
}

export type FloatFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatFilter<$PrismaModel> | number
}

export type FloatWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatWithAggregatesFilter<$PrismaModel> | number
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatFilter<$PrismaModel>
  _sum?: Prisma.NestedFloatFilter<$PrismaModel>
  _min?: Prisma.NestedFloatFilter<$PrismaModel>
  _max?: Prisma.NestedFloatFilter<$PrismaModel>
}

export type NestedIntFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntFilter<$PrismaModel> | number
}

export type NestedStringFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel>
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  not?: Prisma.NestedStringFilter<$PrismaModel> | string
}

export type NestedBoolFilter<$PrismaModel = never> = {
  equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>
  not?: Prisma.NestedBoolFilter<$PrismaModel> | boolean
}

export type NestedStringNullableFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  not?: Prisma.NestedStringNullableFilter<$PrismaModel> | string | null
}

export type NestedDateTimeFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeFilter<$PrismaModel> | Date | string
}

export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
  equals?: $Enums.UserRole | Prisma.EnumUserRoleFieldRefInput<$PrismaModel>
  in?: $Enums.UserRole[] | Prisma.ListEnumUserRoleFieldRefInput<$PrismaModel>
  notIn?: $Enums.UserRole[] | Prisma.ListEnumUserRoleFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
}

export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel> | null
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
}

export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel>
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntWithAggregatesFilter<$PrismaModel> | number
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatFilter<$PrismaModel>
  _sum?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedIntFilter<$PrismaModel>
  _max?: Prisma.NestedIntFilter<$PrismaModel>
}

export type NestedFloatFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatFilter<$PrismaModel> | number
}

export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel>
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel>
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  not?: Prisma.NestedStringWithAggregatesFilter<$PrismaModel> | string
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedStringFilter<$PrismaModel>
  _max?: Prisma.NestedStringFilter<$PrismaModel>
}

export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
  equals?: boolean | Prisma.BooleanFieldRefInput<$PrismaModel>
  not?: Prisma.NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedBoolFilter<$PrismaModel>
  _max?: Prisma.NestedBoolFilter<$PrismaModel>
}

export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: string | Prisma.StringFieldRefInput<$PrismaModel> | null
  in?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  notIn?: string[] | Prisma.ListStringFieldRefInput<$PrismaModel> | null
  lt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  lte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gt?: string | Prisma.StringFieldRefInput<$PrismaModel>
  gte?: string | Prisma.StringFieldRefInput<$PrismaModel>
  contains?: string | Prisma.StringFieldRefInput<$PrismaModel>
  startsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  endsWith?: string | Prisma.StringFieldRefInput<$PrismaModel>
  not?: Prisma.NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedStringNullableFilter<$PrismaModel>
  _max?: Prisma.NestedStringNullableFilter<$PrismaModel>
}

export type NestedIntNullableFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel> | null
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntNullableFilter<$PrismaModel> | number | null
}

export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel>
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedDateTimeFilter<$PrismaModel>
  _max?: Prisma.NestedDateTimeFilter<$PrismaModel>
}

export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.UserRole | Prisma.EnumUserRoleFieldRefInput<$PrismaModel>
  in?: $Enums.UserRole[] | Prisma.ListEnumUserRoleFieldRefInput<$PrismaModel>
  notIn?: $Enums.UserRole[] | Prisma.ListEnumUserRoleFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumUserRoleFilter<$PrismaModel>
  _max?: Prisma.NestedEnumUserRoleFilter<$PrismaModel>
}

export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel> | null
  in?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  notIn?: Date[] | string[] | Prisma.ListDateTimeFieldRefInput<$PrismaModel> | null
  lt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  lte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gt?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  gte?: Date | string | Prisma.DateTimeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedDateTimeNullableFilter<$PrismaModel>
  _max?: Prisma.NestedDateTimeNullableFilter<$PrismaModel>
}

export type NestedEnumIssueStatusFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueStatus | Prisma.EnumIssueStatusFieldRefInput<$PrismaModel>
  in?: $Enums.IssueStatus[] | Prisma.ListEnumIssueStatusFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueStatus[] | Prisma.ListEnumIssueStatusFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueStatusFilter<$PrismaModel> | $Enums.IssueStatus
}

export type NestedEnumIssueAuthorizedFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueAuthorized | Prisma.EnumIssueAuthorizedFieldRefInput<$PrismaModel>
  in?: $Enums.IssueAuthorized[] | Prisma.ListEnumIssueAuthorizedFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueAuthorized[] | Prisma.ListEnumIssueAuthorizedFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueAuthorizedFilter<$PrismaModel> | $Enums.IssueAuthorized
}

export type NestedEnumIssueErrorFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueError | Prisma.EnumIssueErrorFieldRefInput<$PrismaModel>
  in?: $Enums.IssueError[] | Prisma.ListEnumIssueErrorFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueError[] | Prisma.ListEnumIssueErrorFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueErrorFilter<$PrismaModel> | $Enums.IssueError
}

export type NestedEnumIssueTypeFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueType | Prisma.EnumIssueTypeFieldRefInput<$PrismaModel>
  in?: $Enums.IssueType[] | Prisma.ListEnumIssueTypeFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueType[] | Prisma.ListEnumIssueTypeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueTypeFilter<$PrismaModel> | $Enums.IssueType
}

export type NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueStatus | Prisma.EnumIssueStatusFieldRefInput<$PrismaModel>
  in?: $Enums.IssueStatus[] | Prisma.ListEnumIssueStatusFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueStatus[] | Prisma.ListEnumIssueStatusFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel> | $Enums.IssueStatus
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumIssueStatusFilter<$PrismaModel>
  _max?: Prisma.NestedEnumIssueStatusFilter<$PrismaModel>
}

export type NestedEnumIssueAuthorizedWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueAuthorized | Prisma.EnumIssueAuthorizedFieldRefInput<$PrismaModel>
  in?: $Enums.IssueAuthorized[] | Prisma.ListEnumIssueAuthorizedFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueAuthorized[] | Prisma.ListEnumIssueAuthorizedFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueAuthorizedWithAggregatesFilter<$PrismaModel> | $Enums.IssueAuthorized
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumIssueAuthorizedFilter<$PrismaModel>
  _max?: Prisma.NestedEnumIssueAuthorizedFilter<$PrismaModel>
}

export type NestedEnumIssueErrorWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueError | Prisma.EnumIssueErrorFieldRefInput<$PrismaModel>
  in?: $Enums.IssueError[] | Prisma.ListEnumIssueErrorFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueError[] | Prisma.ListEnumIssueErrorFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueErrorWithAggregatesFilter<$PrismaModel> | $Enums.IssueError
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumIssueErrorFilter<$PrismaModel>
  _max?: Prisma.NestedEnumIssueErrorFilter<$PrismaModel>
}

export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.IntFieldRefInput<$PrismaModel> | null
  in?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  notIn?: number[] | Prisma.ListIntFieldRefInput<$PrismaModel> | null
  lt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  lte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gt?: number | Prisma.IntFieldRefInput<$PrismaModel>
  gte?: number | Prisma.IntFieldRefInput<$PrismaModel>
  not?: Prisma.NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
  _count?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatNullableFilter<$PrismaModel>
  _sum?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _min?: Prisma.NestedIntNullableFilter<$PrismaModel>
  _max?: Prisma.NestedIntNullableFilter<$PrismaModel>
}

export type NestedFloatNullableFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel> | null
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel> | null
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel> | null
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatNullableFilter<$PrismaModel> | number | null
}

export type NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.IssueType | Prisma.EnumIssueTypeFieldRefInput<$PrismaModel>
  in?: $Enums.IssueType[] | Prisma.ListEnumIssueTypeFieldRefInput<$PrismaModel>
  notIn?: $Enums.IssueType[] | Prisma.ListEnumIssueTypeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel> | $Enums.IssueType
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumIssueTypeFilter<$PrismaModel>
  _max?: Prisma.NestedEnumIssueTypeFilter<$PrismaModel>
}

export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
  equals?: $Enums.NotificationType | Prisma.EnumNotificationTypeFieldRefInput<$PrismaModel>
  in?: $Enums.NotificationType[] | Prisma.ListEnumNotificationTypeFieldRefInput<$PrismaModel>
  notIn?: $Enums.NotificationType[] | Prisma.ListEnumNotificationTypeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
}

export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
  equals?: $Enums.NotificationType | Prisma.EnumNotificationTypeFieldRefInput<$PrismaModel>
  in?: $Enums.NotificationType[] | Prisma.ListEnumNotificationTypeFieldRefInput<$PrismaModel>
  notIn?: $Enums.NotificationType[] | Prisma.ListEnumNotificationTypeFieldRefInput<$PrismaModel>
  not?: Prisma.NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _min?: Prisma.NestedEnumNotificationTypeFilter<$PrismaModel>
  _max?: Prisma.NestedEnumNotificationTypeFilter<$PrismaModel>
}

export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
  equals?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  in?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  notIn?: number[] | Prisma.ListFloatFieldRefInput<$PrismaModel>
  lt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  lte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gt?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  gte?: number | Prisma.FloatFieldRefInput<$PrismaModel>
  not?: Prisma.NestedFloatWithAggregatesFilter<$PrismaModel> | number
  _count?: Prisma.NestedIntFilter<$PrismaModel>
  _avg?: Prisma.NestedFloatFilter<$PrismaModel>
  _sum?: Prisma.NestedFloatFilter<$PrismaModel>
  _min?: Prisma.NestedFloatFilter<$PrismaModel>
  _max?: Prisma.NestedFloatFilter<$PrismaModel>
}



</code>

## segfault-backend\src\generated\prisma\enums.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
* This file exports all enum related types from the schema.
*
*  You can import this file directly.
*/

export const UserRole = {
  USER: 'USER',
  ADMIN: 'ADMIN',
  GUEST: 'GUEST',
  PIGS: 'PIGS'
} as const

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const IssueStatus = {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED'
} as const

export type IssueStatus = (typeof IssueStatus)[keyof typeof IssueStatus]


export const IssueAuthorized = {
  TRUE: 'TRUE',
  FALSE: 'FALSE'
} as const

export type IssueAuthorized = (typeof IssueAuthorized)[keyof typeof IssueAuthorized]


export const IssueError = {
  NONE: 'NONE',
  INVALID_LOCATION: 'INVALID_LOCATION',
  INAPPROPRIATE_CONTENT: 'INAPPROPRIATE_CONTENT',
  PENDING: 'PENDING'
} as const

export type IssueError = (typeof IssueError)[keyof typeof IssueError]


export const IssueType = {
  POTHOLE: 'POTHOLE',
  ROAD_DAMAGE: 'ROAD_DAMAGE',
  STREETLIGHT_FAULT: 'STREETLIGHT_FAULT',
  GARBAGE_UNCOLLECTED: 'GARBAGE_UNCOLLECTED',
  ILLEGAL_DUMPING: 'ILLEGAL_DUMPING',
  DRAINAGE_BLOCKED: 'DRAINAGE_BLOCKED',
  SEWAGE_OVERFLOW: 'SEWAGE_OVERFLOW',
  WATER_SUPPLY_ISSUE: 'WATER_SUPPLY_ISSUE',
  LOW_WATER_PRESSURE: 'LOW_WATER_PRESSURE',
  OPEN_MANHOLE: 'OPEN_MANHOLE',
  BROKEN_FOOTPATH: 'BROKEN_FOOTPATH',
  ILLEGAL_ENCROACHMENT: 'ILLEGAL_ENCROACHMENT',
  STRAY_CATTLE: 'STRAY_CATTLE',
  TREE_FALL: 'TREE_FALL',
  TRAFFIC_LIGHT_FAULT: 'TRAFFIC_LIGHT_FAULT',
  MOSQUITO_BREEDING: 'MOSQUITO_BREEDING',
  NOISE_COMPLAINT: 'NOISE_COMPLAINT',
  BUILDING_SAFETY: 'BUILDING_SAFETY'
} as const

export type IssueType = (typeof IssueType)[keyof typeof IssueType]


export const NotificationType = {
  ISSUE_STATUS_UPDATE: 'ISSUE_STATUS_UPDATE',
  NEW_COMMENT: 'NEW_COMMENT',
  GENERAL: 'GENERAL',
  BAN_NOTICE: 'BAN_NOTICE',
  REMOVAL_NOTICE: 'REMOVAL_NOTICE',
  UPVOTE_RECEIVED: 'UPVOTE_RECEIVED'
} as const

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

</code>

## segfault-backend\src\generated\prisma\models.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This is a barrel export file for all models and their related types.
 *
 *  You can import this file directly.
 */
export type * from './models/User'
export type * from './models/UserBadge'
export type * from './models/GuestToken'
export type * from './models/Issue'
export type * from './models/IssueUpvote'
export type * from './models/IssueResolutionVote'
export type * from './models/Comment'
export type * from './models/CommentUpvote'
export type * from './models/Notification'
export type * from './models/GraphNode'
export type * from './models/GraphEdge'
export type * from './commonInputTypes'
</code>

## segfault-backend\src\generated\prisma\internal\class.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 *  Under no circumstances should you import this file directly! 
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "./prismaNamespace"


const config: runtime.GetPrismaClientConfig = {
  "generator": {
    "name": "client",
    "provider": {
      "fromEnvVar": null,
      "value": "prisma-client"
    },
    "output": {
      "value": "C:\\Github\\spatial-issue-tracker\\segfault-backend\\src\\generated\\prisma",
      "fromEnvVar": null
    },
    "config": {
      "engineType": "library"
    },
    "binaryTargets": [
      {
        "fromEnvVar": null,
        "value": "windows",
        "native": true
      },
      {
        "fromEnvVar": null,
        "value": "windows"
      },
      {
        "fromEnvVar": null,
        "value": "darwin-arm64"
      }
    ],
    "previewFeatures": [],
    "sourceFilePath": "C:\\Github\\spatial-issue-tracker\\segfault-backend\\prisma\\schema.prisma",
    "isCustomOutput": true
  },
  "relativePath": "../../../prisma",
  "clientVersion": "6.19.0",
  "engineVersion": "2ba551f319ab1df4bc874a89965d8b3641056773",
  "datasourceNames": [
    "db"
  ],
  "activeProvider": "postgresql",
  "postinstall": false,
  "inlineDatasources": {
    "db": {
      "url": {
        "fromEnvVar": "DATABASE_URL",
        "value": null
      }
    }
  },
  "inlineSchema": "generator client {\n  provider      = \"prisma-client\"\n  binaryTargets = [\"native\", \"windows\", \"darwin-arm64\"]\n  output        = \"../src/generated/prisma\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\n// Primary user stuff\nenum UserRole {\n  USER\n  ADMIN\n  GUEST\n  PIGS // Government officials (.gov.in emails)\n}\n\nmodel User {\n  id            Int      @id @default(autoincrement())\n  email         String   @unique\n  emailVerified Boolean  @default(false)\n  password      String\n  name          String?\n  picture       String?\n  createdAt     DateTime @default(now())\n\n  issues          Issue[]\n  comments        Comment[]\n  commentUpvotes  CommentUpvote[]\n  issueUpvotes    IssueUpvote[]\n  resolutionVotes IssueResolutionVote[]\n\n  role         UserRole  @default(USER)\n  isBanned     Boolean   @default(false)\n  banExpiresAt DateTime?\n  banReason    String?\n\n  credibility Int         @default(0)\n  badges      UserBadge[]\n\n  notifications Notification[]\n}\n\n// Would this need an image?\nmodel UserBadge {\n  id        Int      @id @default(autoincrement())\n  name      String\n  awardedAt DateTime @default(now())\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n}\n\n// Support for guest- store this in local storage\nmodel GuestToken {\n  id        Int      @id @default(autoincrement())\n  token     String   @unique\n  createdAt DateTime @default(now())\n\n  issues Issue[]\n}\n\n// Issue stuff\n\nmodel Issue {\n  id          Int                                   @id @default(autoincrement())\n  title       String\n  description String\n  location    Unsupported(\"geometry(Point, 4326)\")?\n  status      IssueStatus                           @default(PENDING)\n  authorized  IssueAuthorized                       @default(FALSE)\n  error       IssueError                            @default(PENDING)\n  createdAt   DateTime                              @default(now())\n  updatedAt   DateTime                              @default(now()) @updatedAt\n  severity    Int?\n\n  imageBlobId String?\n\n  userId   Int\n  user     User      @relation(fields: [userId], references: [id])\n  comments Comment[]\n\n  guestTokenId Int?\n  guestToken   GuestToken? @relation(fields: [guestTokenId], references: [id])\n\n  upvotes         IssueUpvote[]\n  resolutionVotes IssueResolutionVote[]\n\n  issueType IssueType\n  // PostGIS GIST index is created via raw SQL migration\n\n  @@index([issueType])\n  @@index([userId])\n}\n\nenum IssueStatus {\n  PENDING\n  IN_PROGRESS\n  RESOLVED\n}\n\nenum IssueAuthorized {\n  TRUE\n  FALSE\n}\n\nenum IssueError {\n  NONE\n  INVALID_LOCATION\n  INAPPROPRIATE_CONTENT\n  PENDING\n}\n\nmodel IssueUpvote {\n  id        Int      @id @default(autoincrement())\n  createdAt DateTime @default(now())\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  @@unique([issueId, userId])\n}\n\n// Each vote for an issue\nmodel IssueResolutionVote {\n  id         Int      @id @default(autoincrement())\n  createdAt  DateTime @default(now())\n  isResolved Boolean\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  @@unique([issueId, userId])\n}\n\nenum IssueType {\n  POTHOLE\n  ROAD_DAMAGE\n  STREETLIGHT_FAULT\n  GARBAGE_UNCOLLECTED\n  ILLEGAL_DUMPING\n  DRAINAGE_BLOCKED\n  SEWAGE_OVERFLOW\n  WATER_SUPPLY_ISSUE\n  LOW_WATER_PRESSURE\n  OPEN_MANHOLE\n  BROKEN_FOOTPATH\n  ILLEGAL_ENCROACHMENT\n  STRAY_CATTLE\n  TREE_FALL\n  TRAFFIC_LIGHT_FAULT\n  MOSQUITO_BREEDING\n  NOISE_COMPLAINT\n  BUILDING_SAFETY\n}\n\nmodel Comment {\n  id        Int      @id @default(autoincrement())\n  content   String\n  createdAt DateTime @default(now())\n\n  issueId Int\n  issue   Issue @relation(fields: [issueId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  upvotes CommentUpvote[]\n\n  isFlagged         Boolean @default(false)\n  flaggedReason     String?\n  isSystemGenerated Boolean @default(false)\n}\n\nmodel CommentUpvote {\n  id Int @id @default(autoincrement())\n\n  commentId Int\n  comment   Comment @relation(fields: [commentId], references: [id])\n\n  userId Int\n  user   User @relation(fields: [userId], references: [id])\n\n  createdAt DateTime @default(now())\n\n  @@unique([commentId, userId])\n}\n\nmodel Notification {\n  id        Int              @id @default(autoincrement())\n  type      NotificationType @default(GENERAL)\n  message   String\n  createdAt DateTime         @default(now())\n  read      Boolean          @default(false)\n\n  userId Int?\n  user   User? @relation(fields: [userId], references: [id])\n}\n\nenum NotificationType {\n  ISSUE_STATUS_UPDATE\n  NEW_COMMENT\n  GENERAL\n  BAN_NOTICE\n  REMOVAL_NOTICE\n  UPVOTE_RECEIVED\n}\n\n// Road network graph for pathfinding\nmodel GraphNode {\n  id        String      @id @default(uuid())\n  osmId     String      @unique // OSM node ID as string to avoid BigInt serialization issues\n  latitude  Float\n  longitude Float\n  outgoing  GraphEdge[] @relation(\"StartNode\")\n  incoming  GraphEdge[] @relation(\"EndNode\")\n\n  @@index([latitude, longitude])\n}\n\nmodel GraphEdge {\n  id          String    @id @default(uuid())\n  startNodeId String\n  endNodeId   String\n  startNode   GraphNode @relation(\"StartNode\", fields: [startNodeId], references: [id])\n  endNode     GraphNode @relation(\"EndNode\", fields: [endNodeId], references: [id])\n\n  distance Float // In meters\n  baseCost Float // Usually same as distance\n  penalty  Float @default(1.0) // Multiplier: 1.0 = normal, higher = avoid\n\n  @@index([startNodeId])\n  @@index([endNodeId])\n}\n",
  "inlineSchemaHash": "8e9fd5518a73a1b404f110ff17c8905812afb45e0a1ac8eb9abd40d3b6df79bb",
  "copyEngine": true,
  "runtimeDataModel": {
    "models": {},
    "enums": {},
    "types": {}
  },
  "dirname": ""
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"emailVerified\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"password\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"picture\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issues\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"commentUpvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"CommentUpvote\",\"nativeType\":null,\"relationName\":\"CommentUpvoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueUpvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueUpvote\",\"nativeType\":null,\"relationName\":\"IssueUpvoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"resolutionVotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueResolutionVote\",\"nativeType\":null,\"relationName\":\"IssueResolutionVoteToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"role\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"UserRole\",\"nativeType\":null,\"default\":\"USER\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isBanned\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"banExpiresAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"banReason\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"credibility\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":0,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"badges\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"UserBadge\",\"nativeType\":null,\"relationName\":\"UserToUserBadge\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"notifications\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Notification\",\"nativeType\":null,\"relationName\":\"NotificationToUser\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"UserBadge\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"awardedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"UserToUserBadge\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"GuestToken\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"token\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issues\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"GuestTokenToIssue\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Issue\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"description\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"status\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueStatus\",\"nativeType\":null,\"default\":\"PENDING\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"authorized\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueAuthorized\",\"nativeType\":null,\"default\":\"FALSE\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"error\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"IssueError\",\"nativeType\":null,\"default\":\"PENDING\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":true},{\"name\":\"severity\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"imageBlobId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comments\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToIssue\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"guestTokenId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"guestToken\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"GuestToken\",\"nativeType\":null,\"relationName\":\"GuestTokenToIssue\",\"relationFromFields\":[\"guestTokenId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"upvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueUpvote\",\"nativeType\":null,\"relationName\":\"IssueToIssueUpvote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"resolutionVotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueResolutionVote\",\"nativeType\":null,\"relationName\":\"IssueToIssueResolutionVote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueType\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"IssueType\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"IssueUpvote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToIssueUpvote\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueUpvoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"issueId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"issueId\",\"userId\"]}],\"isGenerated\":false},\"IssueResolutionVote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isResolved\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Boolean\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"IssueToIssueResolutionVote\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"IssueResolutionVoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"issueId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"issueId\",\"userId\"]}],\"isGenerated\":false},\"Comment\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"content\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issueId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"issue\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Issue\",\"nativeType\":null,\"relationName\":\"CommentToIssue\",\"relationFromFields\":[\"issueId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"CommentToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"upvotes\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"CommentUpvote\",\"nativeType\":null,\"relationName\":\"CommentToCommentUpvote\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isFlagged\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"flaggedReason\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"isSystemGenerated\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"CommentUpvote\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"commentId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"comment\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Comment\",\"nativeType\":null,\"relationName\":\"CommentToCommentUpvote\",\"relationFromFields\":[\"commentId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"CommentUpvoteToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[[\"commentId\",\"userId\"]],\"uniqueIndexes\":[{\"name\":null,\"fields\":[\"commentId\",\"userId\"]}],\"isGenerated\":false},\"Notification\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"type\",\"kind\":\"enum\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"NotificationType\",\"nativeType\":null,\"default\":\"GENERAL\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"message\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"read\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"userId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"user\",\"kind\":\"object\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"User\",\"nativeType\":null,\"relationName\":\"NotificationToUser\",\"relationFromFields\":[\"userId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"GraphNode\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"uuid\",\"args\":[4]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"osmId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"latitude\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"longitude\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"outgoing\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"GraphEdge\",\"nativeType\":null,\"relationName\":\"StartNode\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"incoming\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"GraphEdge\",\"nativeType\":null,\"relationName\":\"EndNode\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"GraphEdge\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"uuid\",\"args\":[4]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"startNodeId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"endNodeId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"startNode\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"GraphNode\",\"nativeType\":null,\"relationName\":\"StartNode\",\"relationFromFields\":[\"startNodeId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"endNode\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"GraphNode\",\"nativeType\":null,\"relationName\":\"EndNode\",\"relationFromFields\":[\"endNodeId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"distance\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"baseCost\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Float\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"penalty\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Float\",\"nativeType\":null,\"default\":1,\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{\"UserRole\":{\"values\":[{\"name\":\"USER\",\"dbName\":null},{\"name\":\"ADMIN\",\"dbName\":null},{\"name\":\"GUEST\",\"dbName\":null},{\"name\":\"PIGS\",\"dbName\":null}],\"dbName\":null},\"IssueStatus\":{\"values\":[{\"name\":\"PENDING\",\"dbName\":null},{\"name\":\"IN_PROGRESS\",\"dbName\":null},{\"name\":\"RESOLVED\",\"dbName\":null}],\"dbName\":null},\"IssueAuthorized\":{\"values\":[{\"name\":\"TRUE\",\"dbName\":null},{\"name\":\"FALSE\",\"dbName\":null}],\"dbName\":null},\"IssueError\":{\"values\":[{\"name\":\"NONE\",\"dbName\":null},{\"name\":\"INVALID_LOCATION\",\"dbName\":null},{\"name\":\"INAPPROPRIATE_CONTENT\",\"dbName\":null},{\"name\":\"PENDING\",\"dbName\":null}],\"dbName\":null},\"IssueType\":{\"values\":[{\"name\":\"POTHOLE\",\"dbName\":null},{\"name\":\"ROAD_DAMAGE\",\"dbName\":null},{\"name\":\"STREETLIGHT_FAULT\",\"dbName\":null},{\"name\":\"GARBAGE_UNCOLLECTED\",\"dbName\":null},{\"name\":\"ILLEGAL_DUMPING\",\"dbName\":null},{\"name\":\"DRAINAGE_BLOCKED\",\"dbName\":null},{\"name\":\"SEWAGE_OVERFLOW\",\"dbName\":null},{\"name\":\"WATER_SUPPLY_ISSUE\",\"dbName\":null},{\"name\":\"LOW_WATER_PRESSURE\",\"dbName\":null},{\"name\":\"OPEN_MANHOLE\",\"dbName\":null},{\"name\":\"BROKEN_FOOTPATH\",\"dbName\":null},{\"name\":\"ILLEGAL_ENCROACHMENT\",\"dbName\":null},{\"name\":\"STRAY_CATTLE\",\"dbName\":null},{\"name\":\"TREE_FALL\",\"dbName\":null},{\"name\":\"TRAFFIC_LIGHT_FAULT\",\"dbName\":null},{\"name\":\"MOSQUITO_BREEDING\",\"dbName\":null},{\"name\":\"NOISE_COMPLAINT\",\"dbName\":null},{\"name\":\"BUILDING_SAFETY\",\"dbName\":null}],\"dbName\":null},\"NotificationType\":{\"values\":[{\"name\":\"ISSUE_STATUS_UPDATE\",\"dbName\":null},{\"name\":\"NEW_COMMENT\",\"dbName\":null},{\"name\":\"GENERAL\",\"dbName\":null},{\"name\":\"BAN_NOTICE\",\"dbName\":null},{\"name\":\"REMOVAL_NOTICE\",\"dbName\":null},{\"name\":\"UPVOTE_RECEIVED\",\"dbName\":null}],\"dbName\":null}},\"types\":{}}")
config.engineWasm = undefined
config.compilerWasm = undefined




export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never

export interface PrismaClientConstructor {
    /**
   * ## Prisma Client
   * 
   * Type-safe database client for TypeScript
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  new <
    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    LogOpts extends LogOptions<Options> = LogOptions<Options>,
    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
  >(options?: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */

export interface PrismaClient<
  in LogOpts extends Prisma.LogLevel = never,
  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = Prisma.PrismaClientOptions['omit'],
  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): runtime.Types.Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>


  $extends: runtime.Types.Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.guestToken`: Exposes CRUD operations for the **GuestToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GuestTokens
    * const guestTokens = await prisma.guestToken.findMany()
    * ```
    */
  get guestToken(): Prisma.GuestTokenDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issue`: Exposes CRUD operations for the **Issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
  get issue(): Prisma.IssueDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issueUpvote`: Exposes CRUD operations for the **IssueUpvote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueUpvotes
    * const issueUpvotes = await prisma.issueUpvote.findMany()
    * ```
    */
  get issueUpvote(): Prisma.IssueUpvoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.issueResolutionVote`: Exposes CRUD operations for the **IssueResolutionVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueResolutionVotes
    * const issueResolutionVotes = await prisma.issueResolutionVote.findMany()
    * ```
    */
  get issueResolutionVote(): Prisma.IssueResolutionVoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.commentUpvote`: Exposes CRUD operations for the **CommentUpvote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentUpvotes
    * const commentUpvotes = await prisma.commentUpvote.findMany()
    * ```
    */
  get commentUpvote(): Prisma.CommentUpvoteDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.graphNode`: Exposes CRUD operations for the **GraphNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GraphNodes
    * const graphNodes = await prisma.graphNode.findMany()
    * ```
    */
  get graphNode(): Prisma.GraphNodeDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.graphEdge`: Exposes CRUD operations for the **GraphEdge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GraphEdges
    * const graphEdges = await prisma.graphEdge.findMany()
    * ```
    */
  get graphEdge(): Prisma.GraphEdgeDelegate<ExtArgs, { omit: OmitOpts }>;
}

export function getPrismaClientClass(dirname: string): PrismaClientConstructor {
  config.dirname = dirname
  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}

</code>

## segfault-backend\src\generated\prisma\internal\prismaNamespace.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 *  Under no circumstances should you import this file directly! 
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 6.19.0
 * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
 */
export const prismaVersion: PrismaVersion = {
  client: "6.19.0",
  engine: "2ba551f319ab1df4bc874a89965d8b3641056773"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  UserBadge: 'UserBadge',
  GuestToken: 'GuestToken',
  Issue: 'Issue',
  IssueUpvote: 'IssueUpvote',
  IssueResolutionVote: 'IssueResolutionVote',
  Comment: 'Comment',
  CommentUpvote: 'CommentUpvote',
  Notification: 'Notification',
  GraphNode: 'GraphNode',
  GraphEdge: 'GraphEdge'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "userBadge" | "guestToken" | "issue" | "issueUpvote" | "issueResolutionVote" | "comment" | "commentUpvote" | "notification" | "graphNode" | "graphEdge"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    UserBadge: {
      payload: Prisma.$UserBadgePayload<ExtArgs>
      fields: Prisma.UserBadgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        findFirst: {
          args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        findMany: {
          args: Prisma.UserBadgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
        }
        create: {
          args: Prisma.UserBadgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        createMany: {
          args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
        }
        delete: {
          args: Prisma.UserBadgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        update: {
          args: Prisma.UserBadgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        deleteMany: {
          args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserBadgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
        }
        upsert: {
          args: Prisma.UserBadgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserBadgePayload>
        }
        aggregate: {
          args: Prisma.UserBadgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserBadge>
        }
        groupBy: {
          args: Prisma.UserBadgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserBadgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserBadgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserBadgeCountAggregateOutputType> | number
        }
      }
    }
    GuestToken: {
      payload: Prisma.$GuestTokenPayload<ExtArgs>
      fields: Prisma.GuestTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GuestTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GuestTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>
        }
        findFirst: {
          args: Prisma.GuestTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GuestTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>
        }
        findMany: {
          args: Prisma.GuestTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>[]
        }
        create: {
          args: Prisma.GuestTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>
        }
        createMany: {
          args: Prisma.GuestTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GuestTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>[]
        }
        delete: {
          args: Prisma.GuestTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>
        }
        update: {
          args: Prisma.GuestTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>
        }
        deleteMany: {
          args: Prisma.GuestTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GuestTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GuestTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>[]
        }
        upsert: {
          args: Prisma.GuestTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestTokenPayload>
        }
        aggregate: {
          args: Prisma.GuestTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGuestToken>
        }
        groupBy: {
          args: Prisma.GuestTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GuestTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.GuestTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GuestTokenCountAggregateOutputType> | number
        }
      }
    }
    Issue: {
      payload: Prisma.$IssuePayload<ExtArgs>
      fields: Prisma.IssueFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IssueFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IssueFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>
        }
        findFirst: {
          args: Prisma.IssueFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IssueFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>
        }
        findMany: {
          args: Prisma.IssueFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>[]
        }
        create: {
          args: Prisma.IssueCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>
        }
        createMany: {
          args: Prisma.IssueCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.IssueCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>[]
        }
        delete: {
          args: Prisma.IssueDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>
        }
        update: {
          args: Prisma.IssueUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>
        }
        deleteMany: {
          args: Prisma.IssueDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IssueUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.IssueUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>[]
        }
        upsert: {
          args: Prisma.IssueUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssuePayload>
        }
        aggregate: {
          args: Prisma.IssueAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIssue>
        }
        groupBy: {
          args: Prisma.IssueGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssueGroupByOutputType>[]
        }
        count: {
          args: Prisma.IssueCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssueCountAggregateOutputType> | number
        }
      }
    }
    IssueUpvote: {
      payload: Prisma.$IssueUpvotePayload<ExtArgs>
      fields: Prisma.IssueUpvoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IssueUpvoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IssueUpvoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>
        }
        findFirst: {
          args: Prisma.IssueUpvoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IssueUpvoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>
        }
        findMany: {
          args: Prisma.IssueUpvoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>[]
        }
        create: {
          args: Prisma.IssueUpvoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>
        }
        createMany: {
          args: Prisma.IssueUpvoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.IssueUpvoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>[]
        }
        delete: {
          args: Prisma.IssueUpvoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>
        }
        update: {
          args: Prisma.IssueUpvoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>
        }
        deleteMany: {
          args: Prisma.IssueUpvoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IssueUpvoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.IssueUpvoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>[]
        }
        upsert: {
          args: Prisma.IssueUpvoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueUpvotePayload>
        }
        aggregate: {
          args: Prisma.IssueUpvoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIssueUpvote>
        }
        groupBy: {
          args: Prisma.IssueUpvoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssueUpvoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.IssueUpvoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssueUpvoteCountAggregateOutputType> | number
        }
      }
    }
    IssueResolutionVote: {
      payload: Prisma.$IssueResolutionVotePayload<ExtArgs>
      fields: Prisma.IssueResolutionVoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.IssueResolutionVoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.IssueResolutionVoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>
        }
        findFirst: {
          args: Prisma.IssueResolutionVoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.IssueResolutionVoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>
        }
        findMany: {
          args: Prisma.IssueResolutionVoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>[]
        }
        create: {
          args: Prisma.IssueResolutionVoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>
        }
        createMany: {
          args: Prisma.IssueResolutionVoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.IssueResolutionVoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>[]
        }
        delete: {
          args: Prisma.IssueResolutionVoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>
        }
        update: {
          args: Prisma.IssueResolutionVoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>
        }
        deleteMany: {
          args: Prisma.IssueResolutionVoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.IssueResolutionVoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.IssueResolutionVoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>[]
        }
        upsert: {
          args: Prisma.IssueResolutionVoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$IssueResolutionVotePayload>
        }
        aggregate: {
          args: Prisma.IssueResolutionVoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateIssueResolutionVote>
        }
        groupBy: {
          args: Prisma.IssueResolutionVoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssueResolutionVoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.IssueResolutionVoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.IssueResolutionVoteCountAggregateOutputType> | number
        }
      }
    }
    Comment: {
      payload: Prisma.$CommentPayload<ExtArgs>
      fields: Prisma.CommentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findFirst: {
          args: Prisma.CommentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        findMany: {
          args: Prisma.CommentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        create: {
          args: Prisma.CommentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        createMany: {
          args: Prisma.CommentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        delete: {
          args: Prisma.CommentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        update: {
          args: Prisma.CommentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        deleteMany: {
          args: Prisma.CommentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>[]
        }
        upsert: {
          args: Prisma.CommentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentPayload>
        }
        aggregate: {
          args: Prisma.CommentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateComment>
        }
        groupBy: {
          args: Prisma.CommentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentCountAggregateOutputType> | number
        }
      }
    }
    CommentUpvote: {
      payload: Prisma.$CommentUpvotePayload<ExtArgs>
      fields: Prisma.CommentUpvoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommentUpvoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommentUpvoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
        }
        findFirst: {
          args: Prisma.CommentUpvoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommentUpvoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
        }
        findMany: {
          args: Prisma.CommentUpvoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>[]
        }
        create: {
          args: Prisma.CommentUpvoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
        }
        createMany: {
          args: Prisma.CommentUpvoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommentUpvoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>[]
        }
        delete: {
          args: Prisma.CommentUpvoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
        }
        update: {
          args: Prisma.CommentUpvoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
        }
        deleteMany: {
          args: Prisma.CommentUpvoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommentUpvoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommentUpvoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>[]
        }
        upsert: {
          args: Prisma.CommentUpvoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
        }
        aggregate: {
          args: Prisma.CommentUpvoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommentUpvote>
        }
        groupBy: {
          args: Prisma.CommentUpvoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentUpvoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommentUpvoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommentUpvoteCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    GraphNode: {
      payload: Prisma.$GraphNodePayload<ExtArgs>
      fields: Prisma.GraphNodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GraphNodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GraphNodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>
        }
        findFirst: {
          args: Prisma.GraphNodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GraphNodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>
        }
        findMany: {
          args: Prisma.GraphNodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>[]
        }
        create: {
          args: Prisma.GraphNodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>
        }
        createMany: {
          args: Prisma.GraphNodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GraphNodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>[]
        }
        delete: {
          args: Prisma.GraphNodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>
        }
        update: {
          args: Prisma.GraphNodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>
        }
        deleteMany: {
          args: Prisma.GraphNodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GraphNodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GraphNodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>[]
        }
        upsert: {
          args: Prisma.GraphNodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphNodePayload>
        }
        aggregate: {
          args: Prisma.GraphNodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGraphNode>
        }
        groupBy: {
          args: Prisma.GraphNodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GraphNodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.GraphNodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GraphNodeCountAggregateOutputType> | number
        }
      }
    }
    GraphEdge: {
      payload: Prisma.$GraphEdgePayload<ExtArgs>
      fields: Prisma.GraphEdgeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GraphEdgeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GraphEdgeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>
        }
        findFirst: {
          args: Prisma.GraphEdgeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GraphEdgeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>
        }
        findMany: {
          args: Prisma.GraphEdgeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>[]
        }
        create: {
          args: Prisma.GraphEdgeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>
        }
        createMany: {
          args: Prisma.GraphEdgeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GraphEdgeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>[]
        }
        delete: {
          args: Prisma.GraphEdgeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>
        }
        update: {
          args: Prisma.GraphEdgeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>
        }
        deleteMany: {
          args: Prisma.GraphEdgeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GraphEdgeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GraphEdgeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>[]
        }
        upsert: {
          args: Prisma.GraphEdgeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GraphEdgePayload>
        }
        aggregate: {
          args: Prisma.GraphEdgeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGraphEdge>
        }
        groupBy: {
          args: Prisma.GraphEdgeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GraphEdgeGroupByOutputType>[]
        }
        count: {
          args: Prisma.GraphEdgeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GraphEdgeCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  emailVerified: 'emailVerified',
  password: 'password',
  name: 'name',
  picture: 'picture',
  createdAt: 'createdAt',
  role: 'role',
  isBanned: 'isBanned',
  banExpiresAt: 'banExpiresAt',
  banReason: 'banReason',
  credibility: 'credibility'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const UserBadgeScalarFieldEnum = {
  id: 'id',
  name: 'name',
  awardedAt: 'awardedAt',
  userId: 'userId'
} as const

export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


export const GuestTokenScalarFieldEnum = {
  id: 'id',
  token: 'token',
  createdAt: 'createdAt'
} as const

export type GuestTokenScalarFieldEnum = (typeof GuestTokenScalarFieldEnum)[keyof typeof GuestTokenScalarFieldEnum]


export const IssueScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  status: 'status',
  authorized: 'authorized',
  error: 'error',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  severity: 'severity',
  imageBlobId: 'imageBlobId',
  userId: 'userId',
  guestTokenId: 'guestTokenId',
  issueType: 'issueType'
} as const

export type IssueScalarFieldEnum = (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum]


export const IssueUpvoteScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  issueId: 'issueId',
  userId: 'userId'
} as const

export type IssueUpvoteScalarFieldEnum = (typeof IssueUpvoteScalarFieldEnum)[keyof typeof IssueUpvoteScalarFieldEnum]


export const IssueResolutionVoteScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  isResolved: 'isResolved',
  issueId: 'issueId',
  userId: 'userId'
} as const

export type IssueResolutionVoteScalarFieldEnum = (typeof IssueResolutionVoteScalarFieldEnum)[keyof typeof IssueResolutionVoteScalarFieldEnum]


export const CommentScalarFieldEnum = {
  id: 'id',
  content: 'content',
  createdAt: 'createdAt',
  issueId: 'issueId',
  userId: 'userId',
  isFlagged: 'isFlagged',
  flaggedReason: 'flaggedReason',
  isSystemGenerated: 'isSystemGenerated'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const CommentUpvoteScalarFieldEnum = {
  id: 'id',
  commentId: 'commentId',
  userId: 'userId',
  createdAt: 'createdAt'
} as const

export type CommentUpvoteScalarFieldEnum = (typeof CommentUpvoteScalarFieldEnum)[keyof typeof CommentUpvoteScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  type: 'type',
  message: 'message',
  createdAt: 'createdAt',
  read: 'read',
  userId: 'userId'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const GraphNodeScalarFieldEnum = {
  id: 'id',
  osmId: 'osmId',
  latitude: 'latitude',
  longitude: 'longitude'
} as const

export type GraphNodeScalarFieldEnum = (typeof GraphNodeScalarFieldEnum)[keyof typeof GraphNodeScalarFieldEnum]


export const GraphEdgeScalarFieldEnum = {
  id: 'id',
  startNodeId: 'startNodeId',
  endNodeId: 'endNodeId',
  distance: 'distance',
  baseCost: 'baseCost',
  penalty: 'penalty'
} as const

export type GraphEdgeScalarFieldEnum = (typeof GraphEdgeScalarFieldEnum)[keyof typeof GraphEdgeScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


/**
 * Reference to a field of type 'IssueStatus'
 */
export type EnumIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueStatus'>
    


/**
 * Reference to a field of type 'IssueStatus[]'
 */
export type ListEnumIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueStatus[]'>
    


/**
 * Reference to a field of type 'IssueAuthorized'
 */
export type EnumIssueAuthorizedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueAuthorized'>
    


/**
 * Reference to a field of type 'IssueAuthorized[]'
 */
export type ListEnumIssueAuthorizedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueAuthorized[]'>
    


/**
 * Reference to a field of type 'IssueError'
 */
export type EnumIssueErrorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueError'>
    


/**
 * Reference to a field of type 'IssueError[]'
 */
export type ListEnumIssueErrorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueError[]'>
    


/**
 * Reference to a field of type 'IssueType'
 */
export type EnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueType'>
    


/**
 * Reference to a field of type 'IssueType[]'
 */
export type ListEnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueType[]'>
    


/**
 * Reference to a field of type 'NotificationType'
 */
export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


/**
 * Reference to a field of type 'NotificationType[]'
 */
export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}


export type Datasource = {
  url?: string
}
export type Datasources = {
  db?: Datasource
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
   */
  adapter?: runtime.SqlDriverAdapterFactory | null
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  userBadge?: Prisma.UserBadgeOmit
  guestToken?: Prisma.GuestTokenOmit
  issue?: Prisma.IssueOmit
  issueUpvote?: Prisma.IssueUpvoteOmit
  issueResolutionVote?: Prisma.IssueResolutionVoteOmit
  comment?: Prisma.CommentOmit
  commentUpvote?: Prisma.CommentUpvoteOmit
  notification?: Prisma.NotificationOmit
  graphNode?: Prisma.GraphNodeOmit
  graphEdge?: Prisma.GraphEdgeOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>


</code>

## segfault-backend\src\generated\prisma\internal\prismaNamespaceBrowser.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 *  Under no circumstances should you import this file directly! 
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the browser.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/index-browser"

export type * from '../models'
export type * from './prismaNamespace'

export const Decimal = runtime.Decimal


export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull


export const ModelName = {
  User: 'User',
  UserBadge: 'UserBadge',
  GuestToken: 'GuestToken',
  Issue: 'Issue',
  IssueUpvote: 'IssueUpvote',
  IssueResolutionVote: 'IssueResolutionVote',
  Comment: 'Comment',
  CommentUpvote: 'CommentUpvote',
  Notification: 'Notification',
  GraphNode: 'GraphNode',
  GraphEdge: 'GraphEdge'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]

/*
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  emailVerified: 'emailVerified',
  password: 'password',
  name: 'name',
  picture: 'picture',
  createdAt: 'createdAt',
  role: 'role',
  isBanned: 'isBanned',
  banExpiresAt: 'banExpiresAt',
  banReason: 'banReason',
  credibility: 'credibility'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const UserBadgeScalarFieldEnum = {
  id: 'id',
  name: 'name',
  awardedAt: 'awardedAt',
  userId: 'userId'
} as const

export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


export const GuestTokenScalarFieldEnum = {
  id: 'id',
  token: 'token',
  createdAt: 'createdAt'
} as const

export type GuestTokenScalarFieldEnum = (typeof GuestTokenScalarFieldEnum)[keyof typeof GuestTokenScalarFieldEnum]


export const IssueScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  status: 'status',
  authorized: 'authorized',
  error: 'error',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  severity: 'severity',
  imageBlobId: 'imageBlobId',
  userId: 'userId',
  guestTokenId: 'guestTokenId',
  issueType: 'issueType'
} as const

export type IssueScalarFieldEnum = (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum]


export const IssueUpvoteScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  issueId: 'issueId',
  userId: 'userId'
} as const

export type IssueUpvoteScalarFieldEnum = (typeof IssueUpvoteScalarFieldEnum)[keyof typeof IssueUpvoteScalarFieldEnum]


export const IssueResolutionVoteScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  isResolved: 'isResolved',
  issueId: 'issueId',
  userId: 'userId'
} as const

export type IssueResolutionVoteScalarFieldEnum = (typeof IssueResolutionVoteScalarFieldEnum)[keyof typeof IssueResolutionVoteScalarFieldEnum]


export const CommentScalarFieldEnum = {
  id: 'id',
  content: 'content',
  createdAt: 'createdAt',
  issueId: 'issueId',
  userId: 'userId',
  isFlagged: 'isFlagged',
  flaggedReason: 'flaggedReason',
  isSystemGenerated: 'isSystemGenerated'
} as const

export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


export const CommentUpvoteScalarFieldEnum = {
  id: 'id',
  commentId: 'commentId',
  userId: 'userId',
  createdAt: 'createdAt'
} as const

export type CommentUpvoteScalarFieldEnum = (typeof CommentUpvoteScalarFieldEnum)[keyof typeof CommentUpvoteScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  type: 'type',
  message: 'message',
  createdAt: 'createdAt',
  read: 'read',
  userId: 'userId'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const GraphNodeScalarFieldEnum = {
  id: 'id',
  osmId: 'osmId',
  latitude: 'latitude',
  longitude: 'longitude'
} as const

export type GraphNodeScalarFieldEnum = (typeof GraphNodeScalarFieldEnum)[keyof typeof GraphNodeScalarFieldEnum]


export const GraphEdgeScalarFieldEnum = {
  id: 'id',
  startNodeId: 'startNodeId',
  endNodeId: 'endNodeId',
  distance: 'distance',
  baseCost: 'baseCost',
  penalty: 'penalty'
} as const

export type GraphEdgeScalarFieldEnum = (typeof GraphEdgeScalarFieldEnum)[keyof typeof GraphEdgeScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


</code>

## segfault-backend\src\generated\prisma\models\Comment.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Comment` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Comment
 * 
 */
export type CommentModel = runtime.Types.Result.DefaultSelection<Prisma.$CommentPayload>

export type AggregateComment = {
  _count: CommentCountAggregateOutputType | null
  _avg: CommentAvgAggregateOutputType | null
  _sum: CommentSumAggregateOutputType | null
  _min: CommentMinAggregateOutputType | null
  _max: CommentMaxAggregateOutputType | null
}

export type CommentAvgAggregateOutputType = {
  id: number | null
  issueId: number | null
  userId: number | null
}

export type CommentSumAggregateOutputType = {
  id: number | null
  issueId: number | null
  userId: number | null
}

export type CommentMinAggregateOutputType = {
  id: number | null
  content: string | null
  createdAt: Date | null
  issueId: number | null
  userId: number | null
  isFlagged: boolean | null
  flaggedReason: string | null
  isSystemGenerated: boolean | null
}

export type CommentMaxAggregateOutputType = {
  id: number | null
  content: string | null
  createdAt: Date | null
  issueId: number | null
  userId: number | null
  isFlagged: boolean | null
  flaggedReason: string | null
  isSystemGenerated: boolean | null
}

export type CommentCountAggregateOutputType = {
  id: number
  content: number
  createdAt: number
  issueId: number
  userId: number
  isFlagged: number
  flaggedReason: number
  isSystemGenerated: number
  _all: number
}


export type CommentAvgAggregateInputType = {
  id?: true
  issueId?: true
  userId?: true
}

export type CommentSumAggregateInputType = {
  id?: true
  issueId?: true
  userId?: true
}

export type CommentMinAggregateInputType = {
  id?: true
  content?: true
  createdAt?: true
  issueId?: true
  userId?: true
  isFlagged?: true
  flaggedReason?: true
  isSystemGenerated?: true
}

export type CommentMaxAggregateInputType = {
  id?: true
  content?: true
  createdAt?: true
  issueId?: true
  userId?: true
  isFlagged?: true
  flaggedReason?: true
  isSystemGenerated?: true
}

export type CommentCountAggregateInputType = {
  id?: true
  content?: true
  createdAt?: true
  issueId?: true
  userId?: true
  isFlagged?: true
  flaggedReason?: true
  isSystemGenerated?: true
  _all?: true
}

export type CommentAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Comment to aggregate.
   */
  where?: Prisma.CommentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Comments to fetch.
   */
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.CommentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Comments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Comments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Comments
  **/
  _count?: true | CommentCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: CommentAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: CommentSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: CommentMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: CommentMaxAggregateInputType
}

export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
      [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateComment[P]>
    : Prisma.GetScalarType<T[P], AggregateComment[P]>
}




export type CommentGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommentWhereInput
  orderBy?: Prisma.CommentOrderByWithAggregationInput | Prisma.CommentOrderByWithAggregationInput[]
  by: Prisma.CommentScalarFieldEnum[] | Prisma.CommentScalarFieldEnum
  having?: Prisma.CommentScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: CommentCountAggregateInputType | true
  _avg?: CommentAvgAggregateInputType
  _sum?: CommentSumAggregateInputType
  _min?: CommentMinAggregateInputType
  _max?: CommentMaxAggregateInputType
}

export type CommentGroupByOutputType = {
  id: number
  content: string
  createdAt: Date
  issueId: number
  userId: number
  isFlagged: boolean
  flaggedReason: string | null
  isSystemGenerated: boolean
  _count: CommentCountAggregateOutputType | null
  _avg: CommentAvgAggregateOutputType | null
  _sum: CommentSumAggregateOutputType | null
  _min: CommentMinAggregateOutputType | null
  _max: CommentMaxAggregateOutputType | null
}

type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<CommentGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], CommentGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], CommentGroupByOutputType[P]>
      }
    >
  >



export type CommentWhereInput = {
  AND?: Prisma.CommentWhereInput | Prisma.CommentWhereInput[]
  OR?: Prisma.CommentWhereInput[]
  NOT?: Prisma.CommentWhereInput | Prisma.CommentWhereInput[]
  id?: Prisma.IntFilter<"Comment"> | number
  content?: Prisma.StringFilter<"Comment"> | string
  createdAt?: Prisma.DateTimeFilter<"Comment"> | Date | string
  issueId?: Prisma.IntFilter<"Comment"> | number
  userId?: Prisma.IntFilter<"Comment"> | number
  isFlagged?: Prisma.BoolFilter<"Comment"> | boolean
  flaggedReason?: Prisma.StringNullableFilter<"Comment"> | string | null
  isSystemGenerated?: Prisma.BoolFilter<"Comment"> | boolean
  issue?: Prisma.XOR<Prisma.IssueScalarRelationFilter, Prisma.IssueWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  upvotes?: Prisma.CommentUpvoteListRelationFilter
}

export type CommentOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  isFlagged?: Prisma.SortOrder
  flaggedReason?: Prisma.SortOrderInput | Prisma.SortOrder
  isSystemGenerated?: Prisma.SortOrder
  issue?: Prisma.IssueOrderByWithRelationInput
  user?: Prisma.UserOrderByWithRelationInput
  upvotes?: Prisma.CommentUpvoteOrderByRelationAggregateInput
}

export type CommentWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  AND?: Prisma.CommentWhereInput | Prisma.CommentWhereInput[]
  OR?: Prisma.CommentWhereInput[]
  NOT?: Prisma.CommentWhereInput | Prisma.CommentWhereInput[]
  content?: Prisma.StringFilter<"Comment"> | string
  createdAt?: Prisma.DateTimeFilter<"Comment"> | Date | string
  issueId?: Prisma.IntFilter<"Comment"> | number
  userId?: Prisma.IntFilter<"Comment"> | number
  isFlagged?: Prisma.BoolFilter<"Comment"> | boolean
  flaggedReason?: Prisma.StringNullableFilter<"Comment"> | string | null
  isSystemGenerated?: Prisma.BoolFilter<"Comment"> | boolean
  issue?: Prisma.XOR<Prisma.IssueScalarRelationFilter, Prisma.IssueWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  upvotes?: Prisma.CommentUpvoteListRelationFilter
}, "id">

export type CommentOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  isFlagged?: Prisma.SortOrder
  flaggedReason?: Prisma.SortOrderInput | Prisma.SortOrder
  isSystemGenerated?: Prisma.SortOrder
  _count?: Prisma.CommentCountOrderByAggregateInput
  _avg?: Prisma.CommentAvgOrderByAggregateInput
  _max?: Prisma.CommentMaxOrderByAggregateInput
  _min?: Prisma.CommentMinOrderByAggregateInput
  _sum?: Prisma.CommentSumOrderByAggregateInput
}

export type CommentScalarWhereWithAggregatesInput = {
  AND?: Prisma.CommentScalarWhereWithAggregatesInput | Prisma.CommentScalarWhereWithAggregatesInput[]
  OR?: Prisma.CommentScalarWhereWithAggregatesInput[]
  NOT?: Prisma.CommentScalarWhereWithAggregatesInput | Prisma.CommentScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"Comment"> | number
  content?: Prisma.StringWithAggregatesFilter<"Comment"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Comment"> | Date | string
  issueId?: Prisma.IntWithAggregatesFilter<"Comment"> | number
  userId?: Prisma.IntWithAggregatesFilter<"Comment"> | number
  isFlagged?: Prisma.BoolWithAggregatesFilter<"Comment"> | boolean
  flaggedReason?: Prisma.StringNullableWithAggregatesFilter<"Comment"> | string | null
  isSystemGenerated?: Prisma.BoolWithAggregatesFilter<"Comment"> | boolean
}

export type CommentCreateInput = {
  content: string
  createdAt?: Date | string
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
  issue: Prisma.IssueCreateNestedOneWithoutCommentsInput
  user: Prisma.UserCreateNestedOneWithoutCommentsInput
  upvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutCommentInput
}

export type CommentUncheckedCreateInput = {
  id?: number
  content: string
  createdAt?: Date | string
  issueId: number
  userId: number
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
  upvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput
}

export type CommentUpdateInput = {
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issue?: Prisma.IssueUpdateOneRequiredWithoutCommentsNestedInput
  user?: Prisma.UserUpdateOneRequiredWithoutCommentsNestedInput
  upvotes?: Prisma.CommentUpvoteUpdateManyWithoutCommentNestedInput
}

export type CommentUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
  upvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput
}

export type CommentCreateManyInput = {
  id?: number
  content: string
  createdAt?: Date | string
  issueId: number
  userId: number
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
}

export type CommentUpdateManyMutationInput = {
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type CommentUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type CommentListRelationFilter = {
  every?: Prisma.CommentWhereInput
  some?: Prisma.CommentWhereInput
  none?: Prisma.CommentWhereInput
}

export type CommentOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type CommentCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  isFlagged?: Prisma.SortOrder
  flaggedReason?: Prisma.SortOrder
  isSystemGenerated?: Prisma.SortOrder
}

export type CommentAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CommentMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  isFlagged?: Prisma.SortOrder
  flaggedReason?: Prisma.SortOrder
  isSystemGenerated?: Prisma.SortOrder
}

export type CommentMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  content?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  isFlagged?: Prisma.SortOrder
  flaggedReason?: Prisma.SortOrder
  isSystemGenerated?: Prisma.SortOrder
}

export type CommentSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CommentScalarRelationFilter = {
  is?: Prisma.CommentWhereInput
  isNot?: Prisma.CommentWhereInput
}

export type CommentCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutUserInput, Prisma.CommentUncheckedCreateWithoutUserInput> | Prisma.CommentCreateWithoutUserInput[] | Prisma.CommentUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutUserInput | Prisma.CommentCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.CommentCreateManyUserInputEnvelope
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
}

export type CommentUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutUserInput, Prisma.CommentUncheckedCreateWithoutUserInput> | Prisma.CommentCreateWithoutUserInput[] | Prisma.CommentUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutUserInput | Prisma.CommentCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.CommentCreateManyUserInputEnvelope
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
}

export type CommentUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutUserInput, Prisma.CommentUncheckedCreateWithoutUserInput> | Prisma.CommentCreateWithoutUserInput[] | Prisma.CommentUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutUserInput | Prisma.CommentCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.CommentUpsertWithWhereUniqueWithoutUserInput | Prisma.CommentUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.CommentCreateManyUserInputEnvelope
  set?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  disconnect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  delete?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  update?: Prisma.CommentUpdateWithWhereUniqueWithoutUserInput | Prisma.CommentUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.CommentUpdateManyWithWhereWithoutUserInput | Prisma.CommentUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
}

export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutUserInput, Prisma.CommentUncheckedCreateWithoutUserInput> | Prisma.CommentCreateWithoutUserInput[] | Prisma.CommentUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutUserInput | Prisma.CommentCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.CommentUpsertWithWhereUniqueWithoutUserInput | Prisma.CommentUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.CommentCreateManyUserInputEnvelope
  set?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  disconnect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  delete?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  update?: Prisma.CommentUpdateWithWhereUniqueWithoutUserInput | Prisma.CommentUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.CommentUpdateManyWithWhereWithoutUserInput | Prisma.CommentUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
}

export type CommentCreateNestedManyWithoutIssueInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutIssueInput, Prisma.CommentUncheckedCreateWithoutIssueInput> | Prisma.CommentCreateWithoutIssueInput[] | Prisma.CommentUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutIssueInput | Prisma.CommentCreateOrConnectWithoutIssueInput[]
  createMany?: Prisma.CommentCreateManyIssueInputEnvelope
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
}

export type CommentUncheckedCreateNestedManyWithoutIssueInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutIssueInput, Prisma.CommentUncheckedCreateWithoutIssueInput> | Prisma.CommentCreateWithoutIssueInput[] | Prisma.CommentUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutIssueInput | Prisma.CommentCreateOrConnectWithoutIssueInput[]
  createMany?: Prisma.CommentCreateManyIssueInputEnvelope
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
}

export type CommentUpdateManyWithoutIssueNestedInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutIssueInput, Prisma.CommentUncheckedCreateWithoutIssueInput> | Prisma.CommentCreateWithoutIssueInput[] | Prisma.CommentUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutIssueInput | Prisma.CommentCreateOrConnectWithoutIssueInput[]
  upsert?: Prisma.CommentUpsertWithWhereUniqueWithoutIssueInput | Prisma.CommentUpsertWithWhereUniqueWithoutIssueInput[]
  createMany?: Prisma.CommentCreateManyIssueInputEnvelope
  set?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  disconnect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  delete?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  update?: Prisma.CommentUpdateWithWhereUniqueWithoutIssueInput | Prisma.CommentUpdateWithWhereUniqueWithoutIssueInput[]
  updateMany?: Prisma.CommentUpdateManyWithWhereWithoutIssueInput | Prisma.CommentUpdateManyWithWhereWithoutIssueInput[]
  deleteMany?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
}

export type CommentUncheckedUpdateManyWithoutIssueNestedInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutIssueInput, Prisma.CommentUncheckedCreateWithoutIssueInput> | Prisma.CommentCreateWithoutIssueInput[] | Prisma.CommentUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutIssueInput | Prisma.CommentCreateOrConnectWithoutIssueInput[]
  upsert?: Prisma.CommentUpsertWithWhereUniqueWithoutIssueInput | Prisma.CommentUpsertWithWhereUniqueWithoutIssueInput[]
  createMany?: Prisma.CommentCreateManyIssueInputEnvelope
  set?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  disconnect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  delete?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  connect?: Prisma.CommentWhereUniqueInput | Prisma.CommentWhereUniqueInput[]
  update?: Prisma.CommentUpdateWithWhereUniqueWithoutIssueInput | Prisma.CommentUpdateWithWhereUniqueWithoutIssueInput[]
  updateMany?: Prisma.CommentUpdateManyWithWhereWithoutIssueInput | Prisma.CommentUpdateManyWithWhereWithoutIssueInput[]
  deleteMany?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
}

export type CommentCreateNestedOneWithoutUpvotesInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutUpvotesInput, Prisma.CommentUncheckedCreateWithoutUpvotesInput>
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutUpvotesInput
  connect?: Prisma.CommentWhereUniqueInput
}

export type CommentUpdateOneRequiredWithoutUpvotesNestedInput = {
  create?: Prisma.XOR<Prisma.CommentCreateWithoutUpvotesInput, Prisma.CommentUncheckedCreateWithoutUpvotesInput>
  connectOrCreate?: Prisma.CommentCreateOrConnectWithoutUpvotesInput
  upsert?: Prisma.CommentUpsertWithoutUpvotesInput
  connect?: Prisma.CommentWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.CommentUpdateToOneWithWhereWithoutUpvotesInput, Prisma.CommentUpdateWithoutUpvotesInput>, Prisma.CommentUncheckedUpdateWithoutUpvotesInput>
}

export type CommentCreateWithoutUserInput = {
  content: string
  createdAt?: Date | string
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
  issue: Prisma.IssueCreateNestedOneWithoutCommentsInput
  upvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutCommentInput
}

export type CommentUncheckedCreateWithoutUserInput = {
  id?: number
  content: string
  createdAt?: Date | string
  issueId: number
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
  upvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput
}

export type CommentCreateOrConnectWithoutUserInput = {
  where: Prisma.CommentWhereUniqueInput
  create: Prisma.XOR<Prisma.CommentCreateWithoutUserInput, Prisma.CommentUncheckedCreateWithoutUserInput>
}

export type CommentCreateManyUserInputEnvelope = {
  data: Prisma.CommentCreateManyUserInput | Prisma.CommentCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type CommentUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.CommentWhereUniqueInput
  update: Prisma.XOR<Prisma.CommentUpdateWithoutUserInput, Prisma.CommentUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.CommentCreateWithoutUserInput, Prisma.CommentUncheckedCreateWithoutUserInput>
}

export type CommentUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.CommentWhereUniqueInput
  data: Prisma.XOR<Prisma.CommentUpdateWithoutUserInput, Prisma.CommentUncheckedUpdateWithoutUserInput>
}

export type CommentUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.CommentScalarWhereInput
  data: Prisma.XOR<Prisma.CommentUpdateManyMutationInput, Prisma.CommentUncheckedUpdateManyWithoutUserInput>
}

export type CommentScalarWhereInput = {
  AND?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
  OR?: Prisma.CommentScalarWhereInput[]
  NOT?: Prisma.CommentScalarWhereInput | Prisma.CommentScalarWhereInput[]
  id?: Prisma.IntFilter<"Comment"> | number
  content?: Prisma.StringFilter<"Comment"> | string
  createdAt?: Prisma.DateTimeFilter<"Comment"> | Date | string
  issueId?: Prisma.IntFilter<"Comment"> | number
  userId?: Prisma.IntFilter<"Comment"> | number
  isFlagged?: Prisma.BoolFilter<"Comment"> | boolean
  flaggedReason?: Prisma.StringNullableFilter<"Comment"> | string | null
  isSystemGenerated?: Prisma.BoolFilter<"Comment"> | boolean
}

export type CommentCreateWithoutIssueInput = {
  content: string
  createdAt?: Date | string
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
  user: Prisma.UserCreateNestedOneWithoutCommentsInput
  upvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutCommentInput
}

export type CommentUncheckedCreateWithoutIssueInput = {
  id?: number
  content: string
  createdAt?: Date | string
  userId: number
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
  upvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput
}

export type CommentCreateOrConnectWithoutIssueInput = {
  where: Prisma.CommentWhereUniqueInput
  create: Prisma.XOR<Prisma.CommentCreateWithoutIssueInput, Prisma.CommentUncheckedCreateWithoutIssueInput>
}

export type CommentCreateManyIssueInputEnvelope = {
  data: Prisma.CommentCreateManyIssueInput | Prisma.CommentCreateManyIssueInput[]
  skipDuplicates?: boolean
}

export type CommentUpsertWithWhereUniqueWithoutIssueInput = {
  where: Prisma.CommentWhereUniqueInput
  update: Prisma.XOR<Prisma.CommentUpdateWithoutIssueInput, Prisma.CommentUncheckedUpdateWithoutIssueInput>
  create: Prisma.XOR<Prisma.CommentCreateWithoutIssueInput, Prisma.CommentUncheckedCreateWithoutIssueInput>
}

export type CommentUpdateWithWhereUniqueWithoutIssueInput = {
  where: Prisma.CommentWhereUniqueInput
  data: Prisma.XOR<Prisma.CommentUpdateWithoutIssueInput, Prisma.CommentUncheckedUpdateWithoutIssueInput>
}

export type CommentUpdateManyWithWhereWithoutIssueInput = {
  where: Prisma.CommentScalarWhereInput
  data: Prisma.XOR<Prisma.CommentUpdateManyMutationInput, Prisma.CommentUncheckedUpdateManyWithoutIssueInput>
}

export type CommentCreateWithoutUpvotesInput = {
  content: string
  createdAt?: Date | string
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
  issue: Prisma.IssueCreateNestedOneWithoutCommentsInput
  user: Prisma.UserCreateNestedOneWithoutCommentsInput
}

export type CommentUncheckedCreateWithoutUpvotesInput = {
  id?: number
  content: string
  createdAt?: Date | string
  issueId: number
  userId: number
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
}

export type CommentCreateOrConnectWithoutUpvotesInput = {
  where: Prisma.CommentWhereUniqueInput
  create: Prisma.XOR<Prisma.CommentCreateWithoutUpvotesInput, Prisma.CommentUncheckedCreateWithoutUpvotesInput>
}

export type CommentUpsertWithoutUpvotesInput = {
  update: Prisma.XOR<Prisma.CommentUpdateWithoutUpvotesInput, Prisma.CommentUncheckedUpdateWithoutUpvotesInput>
  create: Prisma.XOR<Prisma.CommentCreateWithoutUpvotesInput, Prisma.CommentUncheckedCreateWithoutUpvotesInput>
  where?: Prisma.CommentWhereInput
}

export type CommentUpdateToOneWithWhereWithoutUpvotesInput = {
  where?: Prisma.CommentWhereInput
  data: Prisma.XOR<Prisma.CommentUpdateWithoutUpvotesInput, Prisma.CommentUncheckedUpdateWithoutUpvotesInput>
}

export type CommentUpdateWithoutUpvotesInput = {
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issue?: Prisma.IssueUpdateOneRequiredWithoutCommentsNestedInput
  user?: Prisma.UserUpdateOneRequiredWithoutCommentsNestedInput
}

export type CommentUncheckedUpdateWithoutUpvotesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type CommentCreateManyUserInput = {
  id?: number
  content: string
  createdAt?: Date | string
  issueId: number
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
}

export type CommentUpdateWithoutUserInput = {
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issue?: Prisma.IssueUpdateOneRequiredWithoutCommentsNestedInput
  upvotes?: Prisma.CommentUpvoteUpdateManyWithoutCommentNestedInput
}

export type CommentUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
  upvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput
}

export type CommentUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type CommentCreateManyIssueInput = {
  id?: number
  content: string
  createdAt?: Date | string
  userId: number
  isFlagged?: boolean
  flaggedReason?: string | null
  isSystemGenerated?: boolean
}

export type CommentUpdateWithoutIssueInput = {
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
  user?: Prisma.UserUpdateOneRequiredWithoutCommentsNestedInput
  upvotes?: Prisma.CommentUpvoteUpdateManyWithoutCommentNestedInput
}

export type CommentUncheckedUpdateWithoutIssueInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
  upvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput
}

export type CommentUncheckedUpdateManyWithoutIssueInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  content?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  isFlagged?: Prisma.BoolFieldUpdateOperationsInput | boolean
  flaggedReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  isSystemGenerated?: Prisma.BoolFieldUpdateOperationsInput | boolean
}


/**
 * Count Type CommentCountOutputType
 */

export type CommentCountOutputType = {
  upvotes: number
}

export type CommentCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  upvotes?: boolean | CommentCountOutputTypeCountUpvotesArgs
}

/**
 * CommentCountOutputType without action
 */
export type CommentCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentCountOutputType
   */
  select?: Prisma.CommentCountOutputTypeSelect<ExtArgs> | null
}

/**
 * CommentCountOutputType without action
 */
export type CommentCountOutputTypeCountUpvotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommentUpvoteWhereInput
}


export type CommentSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  content?: boolean
  createdAt?: boolean
  issueId?: boolean
  userId?: boolean
  isFlagged?: boolean
  flaggedReason?: boolean
  isSystemGenerated?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  upvotes?: boolean | Prisma.Comment$upvotesArgs<ExtArgs>
  _count?: boolean | Prisma.CommentCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["comment"]>

export type CommentSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  content?: boolean
  createdAt?: boolean
  issueId?: boolean
  userId?: boolean
  isFlagged?: boolean
  flaggedReason?: boolean
  isSystemGenerated?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["comment"]>

export type CommentSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  content?: boolean
  createdAt?: boolean
  issueId?: boolean
  userId?: boolean
  isFlagged?: boolean
  flaggedReason?: boolean
  isSystemGenerated?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["comment"]>

export type CommentSelectScalar = {
  id?: boolean
  content?: boolean
  createdAt?: boolean
  issueId?: boolean
  userId?: boolean
  isFlagged?: boolean
  flaggedReason?: boolean
  isSystemGenerated?: boolean
}

export type CommentOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "content" | "createdAt" | "issueId" | "userId" | "isFlagged" | "flaggedReason" | "isSystemGenerated", ExtArgs["result"]["comment"]>
export type CommentInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  upvotes?: boolean | Prisma.Comment$upvotesArgs<ExtArgs>
  _count?: boolean | Prisma.CommentCountOutputTypeDefaultArgs<ExtArgs>
}
export type CommentIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type CommentIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $CommentPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Comment"
  objects: {
    issue: Prisma.$IssuePayload<ExtArgs>
    user: Prisma.$UserPayload<ExtArgs>
    upvotes: Prisma.$CommentUpvotePayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    content: string
    createdAt: Date
    issueId: number
    userId: number
    isFlagged: boolean
    flaggedReason: string | null
    isSystemGenerated: boolean
  }, ExtArgs["result"]["comment"]>
  composites: {}
}

export type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CommentPayload, S>

export type CommentCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CommentCountAggregateInputType | true
  }

export interface CommentDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
  /**
   * Find zero or one Comment that matches the filter.
   * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends CommentFindUniqueArgs>(args: Prisma.SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Comment that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentFindFirstArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends CommentFindFirstArgs>(args?: Prisma.SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Comment that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
   * @example
   * // Get one Comment
   * const comment = await prisma.comment.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Comments that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Comments
   * const comments = await prisma.comment.findMany()
   * 
   * // Get first 10 Comments
   * const comments = await prisma.comment.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends CommentFindManyArgs>(args?: Prisma.SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Comment.
   * @param {CommentCreateArgs} args - Arguments to create a Comment.
   * @example
   * // Create one Comment
   * const Comment = await prisma.comment.create({
   *   data: {
   *     // ... data to create a Comment
   *   }
   * })
   * 
   */
  create<T extends CommentCreateArgs>(args: Prisma.SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Comments.
   * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
   * @example
   * // Create many Comments
   * const comment = await prisma.comment.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends CommentCreateManyArgs>(args?: Prisma.SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Comments and returns the data saved in the database.
   * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
   * @example
   * // Create many Comments
   * const comment = await prisma.comment.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Comments and only return the `id`
   * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Comment.
   * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
   * @example
   * // Delete one Comment
   * const Comment = await prisma.comment.delete({
   *   where: {
   *     // ... filter to delete one Comment
   *   }
   * })
   * 
   */
  delete<T extends CommentDeleteArgs>(args: Prisma.SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Comment.
   * @param {CommentUpdateArgs} args - Arguments to update one Comment.
   * @example
   * // Update one Comment
   * const comment = await prisma.comment.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends CommentUpdateArgs>(args: Prisma.SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Comments.
   * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
   * @example
   * // Delete a few Comments
   * const { count } = await prisma.comment.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends CommentDeleteManyArgs>(args?: Prisma.SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Comments.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Comments
   * const comment = await prisma.comment.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends CommentUpdateManyArgs>(args: Prisma.SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Comments and returns the data updated in the database.
   * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
   * @example
   * // Update many Comments
   * const comment = await prisma.comment.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Comments and only return the `id`
   * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Comment.
   * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
   * @example
   * // Update or create a Comment
   * const comment = await prisma.comment.upsert({
   *   create: {
   *     // ... data to create a Comment
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Comment we want to update
   *   }
   * })
   */
  upsert<T extends CommentUpsertArgs>(args: Prisma.SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Comments.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentCountArgs} args - Arguments to filter Comments to count.
   * @example
   * // Count the number of Comments
   * const count = await prisma.comment.count({
   *   where: {
   *     // ... the filter for the Comments we want to count
   *   }
   * })
  **/
  count<T extends CommentCountArgs>(
    args?: Prisma.Subset<T, CommentCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], CommentCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Comment.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends CommentAggregateArgs>(args: Prisma.Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

  /**
   * Group by Comment.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends CommentGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: CommentGroupByArgs['orderBy'] }
      : { orderBy?: CommentGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Comment model
 */
readonly fields: CommentFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Comment.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CommentClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  issue<T extends Prisma.IssueDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.IssueDefaultArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  upvotes<T extends Prisma.Comment$upvotesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Comment$upvotesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Comment model
 */
export interface CommentFieldRefs {
  readonly id: Prisma.FieldRef<"Comment", 'Int'>
  readonly content: Prisma.FieldRef<"Comment", 'String'>
  readonly createdAt: Prisma.FieldRef<"Comment", 'DateTime'>
  readonly issueId: Prisma.FieldRef<"Comment", 'Int'>
  readonly userId: Prisma.FieldRef<"Comment", 'Int'>
  readonly isFlagged: Prisma.FieldRef<"Comment", 'Boolean'>
  readonly flaggedReason: Prisma.FieldRef<"Comment", 'String'>
  readonly isSystemGenerated: Prisma.FieldRef<"Comment", 'Boolean'>
}
    

// Custom InputTypes
/**
 * Comment findUnique
 */
export type CommentFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comment to fetch.
   */
  where: Prisma.CommentWhereUniqueInput
}

/**
 * Comment findUniqueOrThrow
 */
export type CommentFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comment to fetch.
   */
  where: Prisma.CommentWhereUniqueInput
}

/**
 * Comment findFirst
 */
export type CommentFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comment to fetch.
   */
  where?: Prisma.CommentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Comments to fetch.
   */
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Comments.
   */
  cursor?: Prisma.CommentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Comments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Comments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Comments.
   */
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * Comment findFirstOrThrow
 */
export type CommentFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comment to fetch.
   */
  where?: Prisma.CommentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Comments to fetch.
   */
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Comments.
   */
  cursor?: Prisma.CommentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Comments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Comments.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Comments.
   */
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * Comment findMany
 */
export type CommentFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter, which Comments to fetch.
   */
  where?: Prisma.CommentWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Comments to fetch.
   */
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Comments.
   */
  cursor?: Prisma.CommentWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Comments from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Comments.
   */
  skip?: number
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * Comment create
 */
export type CommentCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * The data needed to create a Comment.
   */
  data: Prisma.XOR<Prisma.CommentCreateInput, Prisma.CommentUncheckedCreateInput>
}

/**
 * Comment createMany
 */
export type CommentCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Comments.
   */
  data: Prisma.CommentCreateManyInput | Prisma.CommentCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Comment createManyAndReturn
 */
export type CommentCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * The data used to create many Comments.
   */
  data: Prisma.CommentCreateManyInput | Prisma.CommentCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Comment update
 */
export type CommentUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * The data needed to update a Comment.
   */
  data: Prisma.XOR<Prisma.CommentUpdateInput, Prisma.CommentUncheckedUpdateInput>
  /**
   * Choose, which Comment to update.
   */
  where: Prisma.CommentWhereUniqueInput
}

/**
 * Comment updateMany
 */
export type CommentUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Comments.
   */
  data: Prisma.XOR<Prisma.CommentUpdateManyMutationInput, Prisma.CommentUncheckedUpdateManyInput>
  /**
   * Filter which Comments to update
   */
  where?: Prisma.CommentWhereInput
  /**
   * Limit how many Comments to update.
   */
  limit?: number
}

/**
 * Comment updateManyAndReturn
 */
export type CommentUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * The data used to update Comments.
   */
  data: Prisma.XOR<Prisma.CommentUpdateManyMutationInput, Prisma.CommentUncheckedUpdateManyInput>
  /**
   * Filter which Comments to update
   */
  where?: Prisma.CommentWhereInput
  /**
   * Limit how many Comments to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Comment upsert
 */
export type CommentUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * The filter to search for the Comment to update in case it exists.
   */
  where: Prisma.CommentWhereUniqueInput
  /**
   * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
   */
  create: Prisma.XOR<Prisma.CommentCreateInput, Prisma.CommentUncheckedCreateInput>
  /**
   * In case the Comment was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.CommentUpdateInput, Prisma.CommentUncheckedUpdateInput>
}

/**
 * Comment delete
 */
export type CommentDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  /**
   * Filter which Comment to delete.
   */
  where: Prisma.CommentWhereUniqueInput
}

/**
 * Comment deleteMany
 */
export type CommentDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Comments to delete
   */
  where?: Prisma.CommentWhereInput
  /**
   * Limit how many Comments to delete.
   */
  limit?: number
}

/**
 * Comment.upvotes
 */
export type Comment$upvotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  where?: Prisma.CommentUpvoteWhereInput
  orderBy?: Prisma.CommentUpvoteOrderByWithRelationInput | Prisma.CommentUpvoteOrderByWithRelationInput[]
  cursor?: Prisma.CommentUpvoteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CommentUpvoteScalarFieldEnum | Prisma.CommentUpvoteScalarFieldEnum[]
}

/**
 * Comment without action
 */
export type CommentDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\CommentUpvote.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `CommentUpvote` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model CommentUpvote
 * 
 */
export type CommentUpvoteModel = runtime.Types.Result.DefaultSelection<Prisma.$CommentUpvotePayload>

export type AggregateCommentUpvote = {
  _count: CommentUpvoteCountAggregateOutputType | null
  _avg: CommentUpvoteAvgAggregateOutputType | null
  _sum: CommentUpvoteSumAggregateOutputType | null
  _min: CommentUpvoteMinAggregateOutputType | null
  _max: CommentUpvoteMaxAggregateOutputType | null
}

export type CommentUpvoteAvgAggregateOutputType = {
  id: number | null
  commentId: number | null
  userId: number | null
}

export type CommentUpvoteSumAggregateOutputType = {
  id: number | null
  commentId: number | null
  userId: number | null
}

export type CommentUpvoteMinAggregateOutputType = {
  id: number | null
  commentId: number | null
  userId: number | null
  createdAt: Date | null
}

export type CommentUpvoteMaxAggregateOutputType = {
  id: number | null
  commentId: number | null
  userId: number | null
  createdAt: Date | null
}

export type CommentUpvoteCountAggregateOutputType = {
  id: number
  commentId: number
  userId: number
  createdAt: number
  _all: number
}


export type CommentUpvoteAvgAggregateInputType = {
  id?: true
  commentId?: true
  userId?: true
}

export type CommentUpvoteSumAggregateInputType = {
  id?: true
  commentId?: true
  userId?: true
}

export type CommentUpvoteMinAggregateInputType = {
  id?: true
  commentId?: true
  userId?: true
  createdAt?: true
}

export type CommentUpvoteMaxAggregateInputType = {
  id?: true
  commentId?: true
  userId?: true
  createdAt?: true
}

export type CommentUpvoteCountAggregateInputType = {
  id?: true
  commentId?: true
  userId?: true
  createdAt?: true
  _all?: true
}

export type CommentUpvoteAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CommentUpvote to aggregate.
   */
  where?: Prisma.CommentUpvoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CommentUpvotes to fetch.
   */
  orderBy?: Prisma.CommentUpvoteOrderByWithRelationInput | Prisma.CommentUpvoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.CommentUpvoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` CommentUpvotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CommentUpvotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned CommentUpvotes
  **/
  _count?: true | CommentUpvoteCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: CommentUpvoteAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: CommentUpvoteSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: CommentUpvoteMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: CommentUpvoteMaxAggregateInputType
}

export type GetCommentUpvoteAggregateType<T extends CommentUpvoteAggregateArgs> = {
      [P in keyof T & keyof AggregateCommentUpvote]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateCommentUpvote[P]>
    : Prisma.GetScalarType<T[P], AggregateCommentUpvote[P]>
}




export type CommentUpvoteGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommentUpvoteWhereInput
  orderBy?: Prisma.CommentUpvoteOrderByWithAggregationInput | Prisma.CommentUpvoteOrderByWithAggregationInput[]
  by: Prisma.CommentUpvoteScalarFieldEnum[] | Prisma.CommentUpvoteScalarFieldEnum
  having?: Prisma.CommentUpvoteScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: CommentUpvoteCountAggregateInputType | true
  _avg?: CommentUpvoteAvgAggregateInputType
  _sum?: CommentUpvoteSumAggregateInputType
  _min?: CommentUpvoteMinAggregateInputType
  _max?: CommentUpvoteMaxAggregateInputType
}

export type CommentUpvoteGroupByOutputType = {
  id: number
  commentId: number
  userId: number
  createdAt: Date
  _count: CommentUpvoteCountAggregateOutputType | null
  _avg: CommentUpvoteAvgAggregateOutputType | null
  _sum: CommentUpvoteSumAggregateOutputType | null
  _min: CommentUpvoteMinAggregateOutputType | null
  _max: CommentUpvoteMaxAggregateOutputType | null
}

type GetCommentUpvoteGroupByPayload<T extends CommentUpvoteGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<CommentUpvoteGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof CommentUpvoteGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], CommentUpvoteGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], CommentUpvoteGroupByOutputType[P]>
      }
    >
  >



export type CommentUpvoteWhereInput = {
  AND?: Prisma.CommentUpvoteWhereInput | Prisma.CommentUpvoteWhereInput[]
  OR?: Prisma.CommentUpvoteWhereInput[]
  NOT?: Prisma.CommentUpvoteWhereInput | Prisma.CommentUpvoteWhereInput[]
  id?: Prisma.IntFilter<"CommentUpvote"> | number
  commentId?: Prisma.IntFilter<"CommentUpvote"> | number
  userId?: Prisma.IntFilter<"CommentUpvote"> | number
  createdAt?: Prisma.DateTimeFilter<"CommentUpvote"> | Date | string
  comment?: Prisma.XOR<Prisma.CommentScalarRelationFilter, Prisma.CommentWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}

export type CommentUpvoteOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  commentId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  comment?: Prisma.CommentOrderByWithRelationInput
  user?: Prisma.UserOrderByWithRelationInput
}

export type CommentUpvoteWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  commentId_userId?: Prisma.CommentUpvoteCommentIdUserIdCompoundUniqueInput
  AND?: Prisma.CommentUpvoteWhereInput | Prisma.CommentUpvoteWhereInput[]
  OR?: Prisma.CommentUpvoteWhereInput[]
  NOT?: Prisma.CommentUpvoteWhereInput | Prisma.CommentUpvoteWhereInput[]
  commentId?: Prisma.IntFilter<"CommentUpvote"> | number
  userId?: Prisma.IntFilter<"CommentUpvote"> | number
  createdAt?: Prisma.DateTimeFilter<"CommentUpvote"> | Date | string
  comment?: Prisma.XOR<Prisma.CommentScalarRelationFilter, Prisma.CommentWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}, "id" | "commentId_userId">

export type CommentUpvoteOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  commentId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.CommentUpvoteCountOrderByAggregateInput
  _avg?: Prisma.CommentUpvoteAvgOrderByAggregateInput
  _max?: Prisma.CommentUpvoteMaxOrderByAggregateInput
  _min?: Prisma.CommentUpvoteMinOrderByAggregateInput
  _sum?: Prisma.CommentUpvoteSumOrderByAggregateInput
}

export type CommentUpvoteScalarWhereWithAggregatesInput = {
  AND?: Prisma.CommentUpvoteScalarWhereWithAggregatesInput | Prisma.CommentUpvoteScalarWhereWithAggregatesInput[]
  OR?: Prisma.CommentUpvoteScalarWhereWithAggregatesInput[]
  NOT?: Prisma.CommentUpvoteScalarWhereWithAggregatesInput | Prisma.CommentUpvoteScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"CommentUpvote"> | number
  commentId?: Prisma.IntWithAggregatesFilter<"CommentUpvote"> | number
  userId?: Prisma.IntWithAggregatesFilter<"CommentUpvote"> | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"CommentUpvote"> | Date | string
}

export type CommentUpvoteCreateInput = {
  createdAt?: Date | string
  comment: Prisma.CommentCreateNestedOneWithoutUpvotesInput
  user: Prisma.UserCreateNestedOneWithoutCommentUpvotesInput
}

export type CommentUpvoteUncheckedCreateInput = {
  id?: number
  commentId: number
  userId: number
  createdAt?: Date | string
}

export type CommentUpvoteUpdateInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  comment?: Prisma.CommentUpdateOneRequiredWithoutUpvotesNestedInput
  user?: Prisma.UserUpdateOneRequiredWithoutCommentUpvotesNestedInput
}

export type CommentUpvoteUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  commentId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUpvoteCreateManyInput = {
  id?: number
  commentId: number
  userId: number
  createdAt?: Date | string
}

export type CommentUpvoteUpdateManyMutationInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUpvoteUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  commentId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUpvoteListRelationFilter = {
  every?: Prisma.CommentUpvoteWhereInput
  some?: Prisma.CommentUpvoteWhereInput
  none?: Prisma.CommentUpvoteWhereInput
}

export type CommentUpvoteOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type CommentUpvoteCommentIdUserIdCompoundUniqueInput = {
  commentId: number
  userId: number
}

export type CommentUpvoteCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  commentId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type CommentUpvoteAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  commentId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CommentUpvoteMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  commentId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type CommentUpvoteMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  commentId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type CommentUpvoteSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  commentId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type CommentUpvoteCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutUserInput, Prisma.CommentUpvoteUncheckedCreateWithoutUserInput> | Prisma.CommentUpvoteCreateWithoutUserInput[] | Prisma.CommentUpvoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CommentUpvoteCreateOrConnectWithoutUserInput | Prisma.CommentUpvoteCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.CommentUpvoteCreateManyUserInputEnvelope
  connect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
}

export type CommentUpvoteUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutUserInput, Prisma.CommentUpvoteUncheckedCreateWithoutUserInput> | Prisma.CommentUpvoteCreateWithoutUserInput[] | Prisma.CommentUpvoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CommentUpvoteCreateOrConnectWithoutUserInput | Prisma.CommentUpvoteCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.CommentUpvoteCreateManyUserInputEnvelope
  connect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
}

export type CommentUpvoteUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutUserInput, Prisma.CommentUpvoteUncheckedCreateWithoutUserInput> | Prisma.CommentUpvoteCreateWithoutUserInput[] | Prisma.CommentUpvoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CommentUpvoteCreateOrConnectWithoutUserInput | Prisma.CommentUpvoteCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.CommentUpvoteUpsertWithWhereUniqueWithoutUserInput | Prisma.CommentUpvoteUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.CommentUpvoteCreateManyUserInputEnvelope
  set?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  disconnect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  delete?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  connect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  update?: Prisma.CommentUpvoteUpdateWithWhereUniqueWithoutUserInput | Prisma.CommentUpvoteUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.CommentUpvoteUpdateManyWithWhereWithoutUserInput | Prisma.CommentUpvoteUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.CommentUpvoteScalarWhereInput | Prisma.CommentUpvoteScalarWhereInput[]
}

export type CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutUserInput, Prisma.CommentUpvoteUncheckedCreateWithoutUserInput> | Prisma.CommentUpvoteCreateWithoutUserInput[] | Prisma.CommentUpvoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.CommentUpvoteCreateOrConnectWithoutUserInput | Prisma.CommentUpvoteCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.CommentUpvoteUpsertWithWhereUniqueWithoutUserInput | Prisma.CommentUpvoteUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.CommentUpvoteCreateManyUserInputEnvelope
  set?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  disconnect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  delete?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  connect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  update?: Prisma.CommentUpvoteUpdateWithWhereUniqueWithoutUserInput | Prisma.CommentUpvoteUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.CommentUpvoteUpdateManyWithWhereWithoutUserInput | Prisma.CommentUpvoteUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.CommentUpvoteScalarWhereInput | Prisma.CommentUpvoteScalarWhereInput[]
}

export type CommentUpvoteCreateNestedManyWithoutCommentInput = {
  create?: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutCommentInput, Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput> | Prisma.CommentUpvoteCreateWithoutCommentInput[] | Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput[]
  connectOrCreate?: Prisma.CommentUpvoteCreateOrConnectWithoutCommentInput | Prisma.CommentUpvoteCreateOrConnectWithoutCommentInput[]
  createMany?: Prisma.CommentUpvoteCreateManyCommentInputEnvelope
  connect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
}

export type CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput = {
  create?: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutCommentInput, Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput> | Prisma.CommentUpvoteCreateWithoutCommentInput[] | Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput[]
  connectOrCreate?: Prisma.CommentUpvoteCreateOrConnectWithoutCommentInput | Prisma.CommentUpvoteCreateOrConnectWithoutCommentInput[]
  createMany?: Prisma.CommentUpvoteCreateManyCommentInputEnvelope
  connect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
}

export type CommentUpvoteUpdateManyWithoutCommentNestedInput = {
  create?: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutCommentInput, Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput> | Prisma.CommentUpvoteCreateWithoutCommentInput[] | Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput[]
  connectOrCreate?: Prisma.CommentUpvoteCreateOrConnectWithoutCommentInput | Prisma.CommentUpvoteCreateOrConnectWithoutCommentInput[]
  upsert?: Prisma.CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput | Prisma.CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput[]
  createMany?: Prisma.CommentUpvoteCreateManyCommentInputEnvelope
  set?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  disconnect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  delete?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  connect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  update?: Prisma.CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput | Prisma.CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput[]
  updateMany?: Prisma.CommentUpvoteUpdateManyWithWhereWithoutCommentInput | Prisma.CommentUpvoteUpdateManyWithWhereWithoutCommentInput[]
  deleteMany?: Prisma.CommentUpvoteScalarWhereInput | Prisma.CommentUpvoteScalarWhereInput[]
}

export type CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput = {
  create?: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutCommentInput, Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput> | Prisma.CommentUpvoteCreateWithoutCommentInput[] | Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput[]
  connectOrCreate?: Prisma.CommentUpvoteCreateOrConnectWithoutCommentInput | Prisma.CommentUpvoteCreateOrConnectWithoutCommentInput[]
  upsert?: Prisma.CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput | Prisma.CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput[]
  createMany?: Prisma.CommentUpvoteCreateManyCommentInputEnvelope
  set?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  disconnect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  delete?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  connect?: Prisma.CommentUpvoteWhereUniqueInput | Prisma.CommentUpvoteWhereUniqueInput[]
  update?: Prisma.CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput | Prisma.CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput[]
  updateMany?: Prisma.CommentUpvoteUpdateManyWithWhereWithoutCommentInput | Prisma.CommentUpvoteUpdateManyWithWhereWithoutCommentInput[]
  deleteMany?: Prisma.CommentUpvoteScalarWhereInput | Prisma.CommentUpvoteScalarWhereInput[]
}

export type CommentUpvoteCreateWithoutUserInput = {
  createdAt?: Date | string
  comment: Prisma.CommentCreateNestedOneWithoutUpvotesInput
}

export type CommentUpvoteUncheckedCreateWithoutUserInput = {
  id?: number
  commentId: number
  createdAt?: Date | string
}

export type CommentUpvoteCreateOrConnectWithoutUserInput = {
  where: Prisma.CommentUpvoteWhereUniqueInput
  create: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutUserInput, Prisma.CommentUpvoteUncheckedCreateWithoutUserInput>
}

export type CommentUpvoteCreateManyUserInputEnvelope = {
  data: Prisma.CommentUpvoteCreateManyUserInput | Prisma.CommentUpvoteCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type CommentUpvoteUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.CommentUpvoteWhereUniqueInput
  update: Prisma.XOR<Prisma.CommentUpvoteUpdateWithoutUserInput, Prisma.CommentUpvoteUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutUserInput, Prisma.CommentUpvoteUncheckedCreateWithoutUserInput>
}

export type CommentUpvoteUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.CommentUpvoteWhereUniqueInput
  data: Prisma.XOR<Prisma.CommentUpvoteUpdateWithoutUserInput, Prisma.CommentUpvoteUncheckedUpdateWithoutUserInput>
}

export type CommentUpvoteUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.CommentUpvoteScalarWhereInput
  data: Prisma.XOR<Prisma.CommentUpvoteUpdateManyMutationInput, Prisma.CommentUpvoteUncheckedUpdateManyWithoutUserInput>
}

export type CommentUpvoteScalarWhereInput = {
  AND?: Prisma.CommentUpvoteScalarWhereInput | Prisma.CommentUpvoteScalarWhereInput[]
  OR?: Prisma.CommentUpvoteScalarWhereInput[]
  NOT?: Prisma.CommentUpvoteScalarWhereInput | Prisma.CommentUpvoteScalarWhereInput[]
  id?: Prisma.IntFilter<"CommentUpvote"> | number
  commentId?: Prisma.IntFilter<"CommentUpvote"> | number
  userId?: Prisma.IntFilter<"CommentUpvote"> | number
  createdAt?: Prisma.DateTimeFilter<"CommentUpvote"> | Date | string
}

export type CommentUpvoteCreateWithoutCommentInput = {
  createdAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutCommentUpvotesInput
}

export type CommentUpvoteUncheckedCreateWithoutCommentInput = {
  id?: number
  userId: number
  createdAt?: Date | string
}

export type CommentUpvoteCreateOrConnectWithoutCommentInput = {
  where: Prisma.CommentUpvoteWhereUniqueInput
  create: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutCommentInput, Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput>
}

export type CommentUpvoteCreateManyCommentInputEnvelope = {
  data: Prisma.CommentUpvoteCreateManyCommentInput | Prisma.CommentUpvoteCreateManyCommentInput[]
  skipDuplicates?: boolean
}

export type CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput = {
  where: Prisma.CommentUpvoteWhereUniqueInput
  update: Prisma.XOR<Prisma.CommentUpvoteUpdateWithoutCommentInput, Prisma.CommentUpvoteUncheckedUpdateWithoutCommentInput>
  create: Prisma.XOR<Prisma.CommentUpvoteCreateWithoutCommentInput, Prisma.CommentUpvoteUncheckedCreateWithoutCommentInput>
}

export type CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput = {
  where: Prisma.CommentUpvoteWhereUniqueInput
  data: Prisma.XOR<Prisma.CommentUpvoteUpdateWithoutCommentInput, Prisma.CommentUpvoteUncheckedUpdateWithoutCommentInput>
}

export type CommentUpvoteUpdateManyWithWhereWithoutCommentInput = {
  where: Prisma.CommentUpvoteScalarWhereInput
  data: Prisma.XOR<Prisma.CommentUpvoteUpdateManyMutationInput, Prisma.CommentUpvoteUncheckedUpdateManyWithoutCommentInput>
}

export type CommentUpvoteCreateManyUserInput = {
  id?: number
  commentId: number
  createdAt?: Date | string
}

export type CommentUpvoteUpdateWithoutUserInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  comment?: Prisma.CommentUpdateOneRequiredWithoutUpvotesNestedInput
}

export type CommentUpvoteUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  commentId?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUpvoteUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  commentId?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUpvoteCreateManyCommentInput = {
  id?: number
  userId: number
  createdAt?: Date | string
}

export type CommentUpvoteUpdateWithoutCommentInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutCommentUpvotesNestedInput
}

export type CommentUpvoteUncheckedUpdateWithoutCommentInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type CommentUpvoteUncheckedUpdateManyWithoutCommentInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type CommentUpvoteSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  commentId?: boolean
  userId?: boolean
  createdAt?: boolean
  comment?: boolean | Prisma.CommentDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["commentUpvote"]>

export type CommentUpvoteSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  commentId?: boolean
  userId?: boolean
  createdAt?: boolean
  comment?: boolean | Prisma.CommentDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["commentUpvote"]>

export type CommentUpvoteSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  commentId?: boolean
  userId?: boolean
  createdAt?: boolean
  comment?: boolean | Prisma.CommentDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["commentUpvote"]>

export type CommentUpvoteSelectScalar = {
  id?: boolean
  commentId?: boolean
  userId?: boolean
  createdAt?: boolean
}

export type CommentUpvoteOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "commentId" | "userId" | "createdAt", ExtArgs["result"]["commentUpvote"]>
export type CommentUpvoteInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  comment?: boolean | Prisma.CommentDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type CommentUpvoteIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  comment?: boolean | Prisma.CommentDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type CommentUpvoteIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  comment?: boolean | Prisma.CommentDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $CommentUpvotePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "CommentUpvote"
  objects: {
    comment: Prisma.$CommentPayload<ExtArgs>
    user: Prisma.$UserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    commentId: number
    userId: number
    createdAt: Date
  }, ExtArgs["result"]["commentUpvote"]>
  composites: {}
}

export type CommentUpvoteGetPayload<S extends boolean | null | undefined | CommentUpvoteDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload, S>

export type CommentUpvoteCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<CommentUpvoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: CommentUpvoteCountAggregateInputType | true
  }

export interface CommentUpvoteDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentUpvote'], meta: { name: 'CommentUpvote' } }
  /**
   * Find zero or one CommentUpvote that matches the filter.
   * @param {CommentUpvoteFindUniqueArgs} args - Arguments to find a CommentUpvote
   * @example
   * // Get one CommentUpvote
   * const commentUpvote = await prisma.commentUpvote.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends CommentUpvoteFindUniqueArgs>(args: Prisma.SelectSubset<T, CommentUpvoteFindUniqueArgs<ExtArgs>>): Prisma.Prisma__CommentUpvoteClient<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one CommentUpvote that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {CommentUpvoteFindUniqueOrThrowArgs} args - Arguments to find a CommentUpvote
   * @example
   * // Get one CommentUpvote
   * const commentUpvote = await prisma.commentUpvote.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends CommentUpvoteFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, CommentUpvoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__CommentUpvoteClient<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CommentUpvote that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpvoteFindFirstArgs} args - Arguments to find a CommentUpvote
   * @example
   * // Get one CommentUpvote
   * const commentUpvote = await prisma.commentUpvote.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends CommentUpvoteFindFirstArgs>(args?: Prisma.SelectSubset<T, CommentUpvoteFindFirstArgs<ExtArgs>>): Prisma.Prisma__CommentUpvoteClient<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first CommentUpvote that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpvoteFindFirstOrThrowArgs} args - Arguments to find a CommentUpvote
   * @example
   * // Get one CommentUpvote
   * const commentUpvote = await prisma.commentUpvote.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends CommentUpvoteFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, CommentUpvoteFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__CommentUpvoteClient<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more CommentUpvotes that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpvoteFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all CommentUpvotes
   * const commentUpvotes = await prisma.commentUpvote.findMany()
   * 
   * // Get first 10 CommentUpvotes
   * const commentUpvotes = await prisma.commentUpvote.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const commentUpvoteWithIdOnly = await prisma.commentUpvote.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends CommentUpvoteFindManyArgs>(args?: Prisma.SelectSubset<T, CommentUpvoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a CommentUpvote.
   * @param {CommentUpvoteCreateArgs} args - Arguments to create a CommentUpvote.
   * @example
   * // Create one CommentUpvote
   * const CommentUpvote = await prisma.commentUpvote.create({
   *   data: {
   *     // ... data to create a CommentUpvote
   *   }
   * })
   * 
   */
  create<T extends CommentUpvoteCreateArgs>(args: Prisma.SelectSubset<T, CommentUpvoteCreateArgs<ExtArgs>>): Prisma.Prisma__CommentUpvoteClient<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many CommentUpvotes.
   * @param {CommentUpvoteCreateManyArgs} args - Arguments to create many CommentUpvotes.
   * @example
   * // Create many CommentUpvotes
   * const commentUpvote = await prisma.commentUpvote.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends CommentUpvoteCreateManyArgs>(args?: Prisma.SelectSubset<T, CommentUpvoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many CommentUpvotes and returns the data saved in the database.
   * @param {CommentUpvoteCreateManyAndReturnArgs} args - Arguments to create many CommentUpvotes.
   * @example
   * // Create many CommentUpvotes
   * const commentUpvote = await prisma.commentUpvote.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many CommentUpvotes and only return the `id`
   * const commentUpvoteWithIdOnly = await prisma.commentUpvote.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends CommentUpvoteCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, CommentUpvoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a CommentUpvote.
   * @param {CommentUpvoteDeleteArgs} args - Arguments to delete one CommentUpvote.
   * @example
   * // Delete one CommentUpvote
   * const CommentUpvote = await prisma.commentUpvote.delete({
   *   where: {
   *     // ... filter to delete one CommentUpvote
   *   }
   * })
   * 
   */
  delete<T extends CommentUpvoteDeleteArgs>(args: Prisma.SelectSubset<T, CommentUpvoteDeleteArgs<ExtArgs>>): Prisma.Prisma__CommentUpvoteClient<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one CommentUpvote.
   * @param {CommentUpvoteUpdateArgs} args - Arguments to update one CommentUpvote.
   * @example
   * // Update one CommentUpvote
   * const commentUpvote = await prisma.commentUpvote.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends CommentUpvoteUpdateArgs>(args: Prisma.SelectSubset<T, CommentUpvoteUpdateArgs<ExtArgs>>): Prisma.Prisma__CommentUpvoteClient<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more CommentUpvotes.
   * @param {CommentUpvoteDeleteManyArgs} args - Arguments to filter CommentUpvotes to delete.
   * @example
   * // Delete a few CommentUpvotes
   * const { count } = await prisma.commentUpvote.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends CommentUpvoteDeleteManyArgs>(args?: Prisma.SelectSubset<T, CommentUpvoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CommentUpvotes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpvoteUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many CommentUpvotes
   * const commentUpvote = await prisma.commentUpvote.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends CommentUpvoteUpdateManyArgs>(args: Prisma.SelectSubset<T, CommentUpvoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more CommentUpvotes and returns the data updated in the database.
   * @param {CommentUpvoteUpdateManyAndReturnArgs} args - Arguments to update many CommentUpvotes.
   * @example
   * // Update many CommentUpvotes
   * const commentUpvote = await prisma.commentUpvote.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more CommentUpvotes and only return the `id`
   * const commentUpvoteWithIdOnly = await prisma.commentUpvote.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends CommentUpvoteUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, CommentUpvoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one CommentUpvote.
   * @param {CommentUpvoteUpsertArgs} args - Arguments to update or create a CommentUpvote.
   * @example
   * // Update or create a CommentUpvote
   * const commentUpvote = await prisma.commentUpvote.upsert({
   *   create: {
   *     // ... data to create a CommentUpvote
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the CommentUpvote we want to update
   *   }
   * })
   */
  upsert<T extends CommentUpvoteUpsertArgs>(args: Prisma.SelectSubset<T, CommentUpvoteUpsertArgs<ExtArgs>>): Prisma.Prisma__CommentUpvoteClient<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of CommentUpvotes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpvoteCountArgs} args - Arguments to filter CommentUpvotes to count.
   * @example
   * // Count the number of CommentUpvotes
   * const count = await prisma.commentUpvote.count({
   *   where: {
   *     // ... the filter for the CommentUpvotes we want to count
   *   }
   * })
  **/
  count<T extends CommentUpvoteCountArgs>(
    args?: Prisma.Subset<T, CommentUpvoteCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], CommentUpvoteCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a CommentUpvote.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpvoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends CommentUpvoteAggregateArgs>(args: Prisma.Subset<T, CommentUpvoteAggregateArgs>): Prisma.PrismaPromise<GetCommentUpvoteAggregateType<T>>

  /**
   * Group by CommentUpvote.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {CommentUpvoteGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends CommentUpvoteGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: CommentUpvoteGroupByArgs['orderBy'] }
      : { orderBy?: CommentUpvoteGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, CommentUpvoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentUpvoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the CommentUpvote model
 */
readonly fields: CommentUpvoteFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for CommentUpvote.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CommentUpvoteClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  comment<T extends Prisma.CommentDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.CommentDefaultArgs<ExtArgs>>): Prisma.Prisma__CommentClient<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the CommentUpvote model
 */
export interface CommentUpvoteFieldRefs {
  readonly id: Prisma.FieldRef<"CommentUpvote", 'Int'>
  readonly commentId: Prisma.FieldRef<"CommentUpvote", 'Int'>
  readonly userId: Prisma.FieldRef<"CommentUpvote", 'Int'>
  readonly createdAt: Prisma.FieldRef<"CommentUpvote", 'DateTime'>
}
    

// Custom InputTypes
/**
 * CommentUpvote findUnique
 */
export type CommentUpvoteFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which CommentUpvote to fetch.
   */
  where: Prisma.CommentUpvoteWhereUniqueInput
}

/**
 * CommentUpvote findUniqueOrThrow
 */
export type CommentUpvoteFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which CommentUpvote to fetch.
   */
  where: Prisma.CommentUpvoteWhereUniqueInput
}

/**
 * CommentUpvote findFirst
 */
export type CommentUpvoteFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which CommentUpvote to fetch.
   */
  where?: Prisma.CommentUpvoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CommentUpvotes to fetch.
   */
  orderBy?: Prisma.CommentUpvoteOrderByWithRelationInput | Prisma.CommentUpvoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CommentUpvotes.
   */
  cursor?: Prisma.CommentUpvoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` CommentUpvotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CommentUpvotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CommentUpvotes.
   */
  distinct?: Prisma.CommentUpvoteScalarFieldEnum | Prisma.CommentUpvoteScalarFieldEnum[]
}

/**
 * CommentUpvote findFirstOrThrow
 */
export type CommentUpvoteFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which CommentUpvote to fetch.
   */
  where?: Prisma.CommentUpvoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CommentUpvotes to fetch.
   */
  orderBy?: Prisma.CommentUpvoteOrderByWithRelationInput | Prisma.CommentUpvoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for CommentUpvotes.
   */
  cursor?: Prisma.CommentUpvoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` CommentUpvotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CommentUpvotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of CommentUpvotes.
   */
  distinct?: Prisma.CommentUpvoteScalarFieldEnum | Prisma.CommentUpvoteScalarFieldEnum[]
}

/**
 * CommentUpvote findMany
 */
export type CommentUpvoteFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which CommentUpvotes to fetch.
   */
  where?: Prisma.CommentUpvoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of CommentUpvotes to fetch.
   */
  orderBy?: Prisma.CommentUpvoteOrderByWithRelationInput | Prisma.CommentUpvoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing CommentUpvotes.
   */
  cursor?: Prisma.CommentUpvoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` CommentUpvotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` CommentUpvotes.
   */
  skip?: number
  distinct?: Prisma.CommentUpvoteScalarFieldEnum | Prisma.CommentUpvoteScalarFieldEnum[]
}

/**
 * CommentUpvote create
 */
export type CommentUpvoteCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * The data needed to create a CommentUpvote.
   */
  data: Prisma.XOR<Prisma.CommentUpvoteCreateInput, Prisma.CommentUpvoteUncheckedCreateInput>
}

/**
 * CommentUpvote createMany
 */
export type CommentUpvoteCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many CommentUpvotes.
   */
  data: Prisma.CommentUpvoteCreateManyInput | Prisma.CommentUpvoteCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * CommentUpvote createManyAndReturn
 */
export type CommentUpvoteCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * The data used to create many CommentUpvotes.
   */
  data: Prisma.CommentUpvoteCreateManyInput | Prisma.CommentUpvoteCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * CommentUpvote update
 */
export type CommentUpvoteUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * The data needed to update a CommentUpvote.
   */
  data: Prisma.XOR<Prisma.CommentUpvoteUpdateInput, Prisma.CommentUpvoteUncheckedUpdateInput>
  /**
   * Choose, which CommentUpvote to update.
   */
  where: Prisma.CommentUpvoteWhereUniqueInput
}

/**
 * CommentUpvote updateMany
 */
export type CommentUpvoteUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update CommentUpvotes.
   */
  data: Prisma.XOR<Prisma.CommentUpvoteUpdateManyMutationInput, Prisma.CommentUpvoteUncheckedUpdateManyInput>
  /**
   * Filter which CommentUpvotes to update
   */
  where?: Prisma.CommentUpvoteWhereInput
  /**
   * Limit how many CommentUpvotes to update.
   */
  limit?: number
}

/**
 * CommentUpvote updateManyAndReturn
 */
export type CommentUpvoteUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * The data used to update CommentUpvotes.
   */
  data: Prisma.XOR<Prisma.CommentUpvoteUpdateManyMutationInput, Prisma.CommentUpvoteUncheckedUpdateManyInput>
  /**
   * Filter which CommentUpvotes to update
   */
  where?: Prisma.CommentUpvoteWhereInput
  /**
   * Limit how many CommentUpvotes to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * CommentUpvote upsert
 */
export type CommentUpvoteUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * The filter to search for the CommentUpvote to update in case it exists.
   */
  where: Prisma.CommentUpvoteWhereUniqueInput
  /**
   * In case the CommentUpvote found by the `where` argument doesn't exist, create a new CommentUpvote with this data.
   */
  create: Prisma.XOR<Prisma.CommentUpvoteCreateInput, Prisma.CommentUpvoteUncheckedCreateInput>
  /**
   * In case the CommentUpvote was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.CommentUpvoteUpdateInput, Prisma.CommentUpvoteUncheckedUpdateInput>
}

/**
 * CommentUpvote delete
 */
export type CommentUpvoteDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  /**
   * Filter which CommentUpvote to delete.
   */
  where: Prisma.CommentUpvoteWhereUniqueInput
}

/**
 * CommentUpvote deleteMany
 */
export type CommentUpvoteDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which CommentUpvotes to delete
   */
  where?: Prisma.CommentUpvoteWhereInput
  /**
   * Limit how many CommentUpvotes to delete.
   */
  limit?: number
}

/**
 * CommentUpvote without action
 */
export type CommentUpvoteDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\GraphEdge.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `GraphEdge` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model GraphEdge
 * 
 */
export type GraphEdgeModel = runtime.Types.Result.DefaultSelection<Prisma.$GraphEdgePayload>

export type AggregateGraphEdge = {
  _count: GraphEdgeCountAggregateOutputType | null
  _avg: GraphEdgeAvgAggregateOutputType | null
  _sum: GraphEdgeSumAggregateOutputType | null
  _min: GraphEdgeMinAggregateOutputType | null
  _max: GraphEdgeMaxAggregateOutputType | null
}

export type GraphEdgeAvgAggregateOutputType = {
  distance: number | null
  baseCost: number | null
  penalty: number | null
}

export type GraphEdgeSumAggregateOutputType = {
  distance: number | null
  baseCost: number | null
  penalty: number | null
}

export type GraphEdgeMinAggregateOutputType = {
  id: string | null
  startNodeId: string | null
  endNodeId: string | null
  distance: number | null
  baseCost: number | null
  penalty: number | null
}

export type GraphEdgeMaxAggregateOutputType = {
  id: string | null
  startNodeId: string | null
  endNodeId: string | null
  distance: number | null
  baseCost: number | null
  penalty: number | null
}

export type GraphEdgeCountAggregateOutputType = {
  id: number
  startNodeId: number
  endNodeId: number
  distance: number
  baseCost: number
  penalty: number
  _all: number
}


export type GraphEdgeAvgAggregateInputType = {
  distance?: true
  baseCost?: true
  penalty?: true
}

export type GraphEdgeSumAggregateInputType = {
  distance?: true
  baseCost?: true
  penalty?: true
}

export type GraphEdgeMinAggregateInputType = {
  id?: true
  startNodeId?: true
  endNodeId?: true
  distance?: true
  baseCost?: true
  penalty?: true
}

export type GraphEdgeMaxAggregateInputType = {
  id?: true
  startNodeId?: true
  endNodeId?: true
  distance?: true
  baseCost?: true
  penalty?: true
}

export type GraphEdgeCountAggregateInputType = {
  id?: true
  startNodeId?: true
  endNodeId?: true
  distance?: true
  baseCost?: true
  penalty?: true
  _all?: true
}

export type GraphEdgeAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which GraphEdge to aggregate.
   */
  where?: Prisma.GraphEdgeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GraphEdges to fetch.
   */
  orderBy?: Prisma.GraphEdgeOrderByWithRelationInput | Prisma.GraphEdgeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.GraphEdgeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GraphEdges from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GraphEdges.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned GraphEdges
  **/
  _count?: true | GraphEdgeCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: GraphEdgeAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: GraphEdgeSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: GraphEdgeMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: GraphEdgeMaxAggregateInputType
}

export type GetGraphEdgeAggregateType<T extends GraphEdgeAggregateArgs> = {
      [P in keyof T & keyof AggregateGraphEdge]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateGraphEdge[P]>
    : Prisma.GetScalarType<T[P], AggregateGraphEdge[P]>
}




export type GraphEdgeGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.GraphEdgeWhereInput
  orderBy?: Prisma.GraphEdgeOrderByWithAggregationInput | Prisma.GraphEdgeOrderByWithAggregationInput[]
  by: Prisma.GraphEdgeScalarFieldEnum[] | Prisma.GraphEdgeScalarFieldEnum
  having?: Prisma.GraphEdgeScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: GraphEdgeCountAggregateInputType | true
  _avg?: GraphEdgeAvgAggregateInputType
  _sum?: GraphEdgeSumAggregateInputType
  _min?: GraphEdgeMinAggregateInputType
  _max?: GraphEdgeMaxAggregateInputType
}

export type GraphEdgeGroupByOutputType = {
  id: string
  startNodeId: string
  endNodeId: string
  distance: number
  baseCost: number
  penalty: number
  _count: GraphEdgeCountAggregateOutputType | null
  _avg: GraphEdgeAvgAggregateOutputType | null
  _sum: GraphEdgeSumAggregateOutputType | null
  _min: GraphEdgeMinAggregateOutputType | null
  _max: GraphEdgeMaxAggregateOutputType | null
}

type GetGraphEdgeGroupByPayload<T extends GraphEdgeGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<GraphEdgeGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof GraphEdgeGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], GraphEdgeGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], GraphEdgeGroupByOutputType[P]>
      }
    >
  >



export type GraphEdgeWhereInput = {
  AND?: Prisma.GraphEdgeWhereInput | Prisma.GraphEdgeWhereInput[]
  OR?: Prisma.GraphEdgeWhereInput[]
  NOT?: Prisma.GraphEdgeWhereInput | Prisma.GraphEdgeWhereInput[]
  id?: Prisma.StringFilter<"GraphEdge"> | string
  startNodeId?: Prisma.StringFilter<"GraphEdge"> | string
  endNodeId?: Prisma.StringFilter<"GraphEdge"> | string
  distance?: Prisma.FloatFilter<"GraphEdge"> | number
  baseCost?: Prisma.FloatFilter<"GraphEdge"> | number
  penalty?: Prisma.FloatFilter<"GraphEdge"> | number
  startNode?: Prisma.XOR<Prisma.GraphNodeScalarRelationFilter, Prisma.GraphNodeWhereInput>
  endNode?: Prisma.XOR<Prisma.GraphNodeScalarRelationFilter, Prisma.GraphNodeWhereInput>
}

export type GraphEdgeOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  startNodeId?: Prisma.SortOrder
  endNodeId?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  baseCost?: Prisma.SortOrder
  penalty?: Prisma.SortOrder
  startNode?: Prisma.GraphNodeOrderByWithRelationInput
  endNode?: Prisma.GraphNodeOrderByWithRelationInput
}

export type GraphEdgeWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.GraphEdgeWhereInput | Prisma.GraphEdgeWhereInput[]
  OR?: Prisma.GraphEdgeWhereInput[]
  NOT?: Prisma.GraphEdgeWhereInput | Prisma.GraphEdgeWhereInput[]
  startNodeId?: Prisma.StringFilter<"GraphEdge"> | string
  endNodeId?: Prisma.StringFilter<"GraphEdge"> | string
  distance?: Prisma.FloatFilter<"GraphEdge"> | number
  baseCost?: Prisma.FloatFilter<"GraphEdge"> | number
  penalty?: Prisma.FloatFilter<"GraphEdge"> | number
  startNode?: Prisma.XOR<Prisma.GraphNodeScalarRelationFilter, Prisma.GraphNodeWhereInput>
  endNode?: Prisma.XOR<Prisma.GraphNodeScalarRelationFilter, Prisma.GraphNodeWhereInput>
}, "id">

export type GraphEdgeOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  startNodeId?: Prisma.SortOrder
  endNodeId?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  baseCost?: Prisma.SortOrder
  penalty?: Prisma.SortOrder
  _count?: Prisma.GraphEdgeCountOrderByAggregateInput
  _avg?: Prisma.GraphEdgeAvgOrderByAggregateInput
  _max?: Prisma.GraphEdgeMaxOrderByAggregateInput
  _min?: Prisma.GraphEdgeMinOrderByAggregateInput
  _sum?: Prisma.GraphEdgeSumOrderByAggregateInput
}

export type GraphEdgeScalarWhereWithAggregatesInput = {
  AND?: Prisma.GraphEdgeScalarWhereWithAggregatesInput | Prisma.GraphEdgeScalarWhereWithAggregatesInput[]
  OR?: Prisma.GraphEdgeScalarWhereWithAggregatesInput[]
  NOT?: Prisma.GraphEdgeScalarWhereWithAggregatesInput | Prisma.GraphEdgeScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"GraphEdge"> | string
  startNodeId?: Prisma.StringWithAggregatesFilter<"GraphEdge"> | string
  endNodeId?: Prisma.StringWithAggregatesFilter<"GraphEdge"> | string
  distance?: Prisma.FloatWithAggregatesFilter<"GraphEdge"> | number
  baseCost?: Prisma.FloatWithAggregatesFilter<"GraphEdge"> | number
  penalty?: Prisma.FloatWithAggregatesFilter<"GraphEdge"> | number
}

export type GraphEdgeCreateInput = {
  id?: string
  distance: number
  baseCost: number
  penalty?: number
  startNode: Prisma.GraphNodeCreateNestedOneWithoutOutgoingInput
  endNode: Prisma.GraphNodeCreateNestedOneWithoutIncomingInput
}

export type GraphEdgeUncheckedCreateInput = {
  id?: string
  startNodeId: string
  endNodeId: string
  distance: number
  baseCost: number
  penalty?: number
}

export type GraphEdgeUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
  startNode?: Prisma.GraphNodeUpdateOneRequiredWithoutOutgoingNestedInput
  endNode?: Prisma.GraphNodeUpdateOneRequiredWithoutIncomingNestedInput
}

export type GraphEdgeUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startNodeId?: Prisma.StringFieldUpdateOperationsInput | string
  endNodeId?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type GraphEdgeCreateManyInput = {
  id?: string
  startNodeId: string
  endNodeId: string
  distance: number
  baseCost: number
  penalty?: number
}

export type GraphEdgeUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type GraphEdgeUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startNodeId?: Prisma.StringFieldUpdateOperationsInput | string
  endNodeId?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type GraphEdgeListRelationFilter = {
  every?: Prisma.GraphEdgeWhereInput
  some?: Prisma.GraphEdgeWhereInput
  none?: Prisma.GraphEdgeWhereInput
}

export type GraphEdgeOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type GraphEdgeCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  startNodeId?: Prisma.SortOrder
  endNodeId?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  baseCost?: Prisma.SortOrder
  penalty?: Prisma.SortOrder
}

export type GraphEdgeAvgOrderByAggregateInput = {
  distance?: Prisma.SortOrder
  baseCost?: Prisma.SortOrder
  penalty?: Prisma.SortOrder
}

export type GraphEdgeMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  startNodeId?: Prisma.SortOrder
  endNodeId?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  baseCost?: Prisma.SortOrder
  penalty?: Prisma.SortOrder
}

export type GraphEdgeMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  startNodeId?: Prisma.SortOrder
  endNodeId?: Prisma.SortOrder
  distance?: Prisma.SortOrder
  baseCost?: Prisma.SortOrder
  penalty?: Prisma.SortOrder
}

export type GraphEdgeSumOrderByAggregateInput = {
  distance?: Prisma.SortOrder
  baseCost?: Prisma.SortOrder
  penalty?: Prisma.SortOrder
}

export type GraphEdgeCreateNestedManyWithoutStartNodeInput = {
  create?: Prisma.XOR<Prisma.GraphEdgeCreateWithoutStartNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput> | Prisma.GraphEdgeCreateWithoutStartNodeInput[] | Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput[]
  connectOrCreate?: Prisma.GraphEdgeCreateOrConnectWithoutStartNodeInput | Prisma.GraphEdgeCreateOrConnectWithoutStartNodeInput[]
  createMany?: Prisma.GraphEdgeCreateManyStartNodeInputEnvelope
  connect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
}

export type GraphEdgeCreateNestedManyWithoutEndNodeInput = {
  create?: Prisma.XOR<Prisma.GraphEdgeCreateWithoutEndNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput> | Prisma.GraphEdgeCreateWithoutEndNodeInput[] | Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput[]
  connectOrCreate?: Prisma.GraphEdgeCreateOrConnectWithoutEndNodeInput | Prisma.GraphEdgeCreateOrConnectWithoutEndNodeInput[]
  createMany?: Prisma.GraphEdgeCreateManyEndNodeInputEnvelope
  connect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
}

export type GraphEdgeUncheckedCreateNestedManyWithoutStartNodeInput = {
  create?: Prisma.XOR<Prisma.GraphEdgeCreateWithoutStartNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput> | Prisma.GraphEdgeCreateWithoutStartNodeInput[] | Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput[]
  connectOrCreate?: Prisma.GraphEdgeCreateOrConnectWithoutStartNodeInput | Prisma.GraphEdgeCreateOrConnectWithoutStartNodeInput[]
  createMany?: Prisma.GraphEdgeCreateManyStartNodeInputEnvelope
  connect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
}

export type GraphEdgeUncheckedCreateNestedManyWithoutEndNodeInput = {
  create?: Prisma.XOR<Prisma.GraphEdgeCreateWithoutEndNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput> | Prisma.GraphEdgeCreateWithoutEndNodeInput[] | Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput[]
  connectOrCreate?: Prisma.GraphEdgeCreateOrConnectWithoutEndNodeInput | Prisma.GraphEdgeCreateOrConnectWithoutEndNodeInput[]
  createMany?: Prisma.GraphEdgeCreateManyEndNodeInputEnvelope
  connect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
}

export type GraphEdgeUpdateManyWithoutStartNodeNestedInput = {
  create?: Prisma.XOR<Prisma.GraphEdgeCreateWithoutStartNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput> | Prisma.GraphEdgeCreateWithoutStartNodeInput[] | Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput[]
  connectOrCreate?: Prisma.GraphEdgeCreateOrConnectWithoutStartNodeInput | Prisma.GraphEdgeCreateOrConnectWithoutStartNodeInput[]
  upsert?: Prisma.GraphEdgeUpsertWithWhereUniqueWithoutStartNodeInput | Prisma.GraphEdgeUpsertWithWhereUniqueWithoutStartNodeInput[]
  createMany?: Prisma.GraphEdgeCreateManyStartNodeInputEnvelope
  set?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  disconnect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  delete?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  connect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  update?: Prisma.GraphEdgeUpdateWithWhereUniqueWithoutStartNodeInput | Prisma.GraphEdgeUpdateWithWhereUniqueWithoutStartNodeInput[]
  updateMany?: Prisma.GraphEdgeUpdateManyWithWhereWithoutStartNodeInput | Prisma.GraphEdgeUpdateManyWithWhereWithoutStartNodeInput[]
  deleteMany?: Prisma.GraphEdgeScalarWhereInput | Prisma.GraphEdgeScalarWhereInput[]
}

export type GraphEdgeUpdateManyWithoutEndNodeNestedInput = {
  create?: Prisma.XOR<Prisma.GraphEdgeCreateWithoutEndNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput> | Prisma.GraphEdgeCreateWithoutEndNodeInput[] | Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput[]
  connectOrCreate?: Prisma.GraphEdgeCreateOrConnectWithoutEndNodeInput | Prisma.GraphEdgeCreateOrConnectWithoutEndNodeInput[]
  upsert?: Prisma.GraphEdgeUpsertWithWhereUniqueWithoutEndNodeInput | Prisma.GraphEdgeUpsertWithWhereUniqueWithoutEndNodeInput[]
  createMany?: Prisma.GraphEdgeCreateManyEndNodeInputEnvelope
  set?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  disconnect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  delete?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  connect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  update?: Prisma.GraphEdgeUpdateWithWhereUniqueWithoutEndNodeInput | Prisma.GraphEdgeUpdateWithWhereUniqueWithoutEndNodeInput[]
  updateMany?: Prisma.GraphEdgeUpdateManyWithWhereWithoutEndNodeInput | Prisma.GraphEdgeUpdateManyWithWhereWithoutEndNodeInput[]
  deleteMany?: Prisma.GraphEdgeScalarWhereInput | Prisma.GraphEdgeScalarWhereInput[]
}

export type GraphEdgeUncheckedUpdateManyWithoutStartNodeNestedInput = {
  create?: Prisma.XOR<Prisma.GraphEdgeCreateWithoutStartNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput> | Prisma.GraphEdgeCreateWithoutStartNodeInput[] | Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput[]
  connectOrCreate?: Prisma.GraphEdgeCreateOrConnectWithoutStartNodeInput | Prisma.GraphEdgeCreateOrConnectWithoutStartNodeInput[]
  upsert?: Prisma.GraphEdgeUpsertWithWhereUniqueWithoutStartNodeInput | Prisma.GraphEdgeUpsertWithWhereUniqueWithoutStartNodeInput[]
  createMany?: Prisma.GraphEdgeCreateManyStartNodeInputEnvelope
  set?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  disconnect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  delete?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  connect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  update?: Prisma.GraphEdgeUpdateWithWhereUniqueWithoutStartNodeInput | Prisma.GraphEdgeUpdateWithWhereUniqueWithoutStartNodeInput[]
  updateMany?: Prisma.GraphEdgeUpdateManyWithWhereWithoutStartNodeInput | Prisma.GraphEdgeUpdateManyWithWhereWithoutStartNodeInput[]
  deleteMany?: Prisma.GraphEdgeScalarWhereInput | Prisma.GraphEdgeScalarWhereInput[]
}

export type GraphEdgeUncheckedUpdateManyWithoutEndNodeNestedInput = {
  create?: Prisma.XOR<Prisma.GraphEdgeCreateWithoutEndNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput> | Prisma.GraphEdgeCreateWithoutEndNodeInput[] | Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput[]
  connectOrCreate?: Prisma.GraphEdgeCreateOrConnectWithoutEndNodeInput | Prisma.GraphEdgeCreateOrConnectWithoutEndNodeInput[]
  upsert?: Prisma.GraphEdgeUpsertWithWhereUniqueWithoutEndNodeInput | Prisma.GraphEdgeUpsertWithWhereUniqueWithoutEndNodeInput[]
  createMany?: Prisma.GraphEdgeCreateManyEndNodeInputEnvelope
  set?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  disconnect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  delete?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  connect?: Prisma.GraphEdgeWhereUniqueInput | Prisma.GraphEdgeWhereUniqueInput[]
  update?: Prisma.GraphEdgeUpdateWithWhereUniqueWithoutEndNodeInput | Prisma.GraphEdgeUpdateWithWhereUniqueWithoutEndNodeInput[]
  updateMany?: Prisma.GraphEdgeUpdateManyWithWhereWithoutEndNodeInput | Prisma.GraphEdgeUpdateManyWithWhereWithoutEndNodeInput[]
  deleteMany?: Prisma.GraphEdgeScalarWhereInput | Prisma.GraphEdgeScalarWhereInput[]
}

export type GraphEdgeCreateWithoutStartNodeInput = {
  id?: string
  distance: number
  baseCost: number
  penalty?: number
  endNode: Prisma.GraphNodeCreateNestedOneWithoutIncomingInput
}

export type GraphEdgeUncheckedCreateWithoutStartNodeInput = {
  id?: string
  endNodeId: string
  distance: number
  baseCost: number
  penalty?: number
}

export type GraphEdgeCreateOrConnectWithoutStartNodeInput = {
  where: Prisma.GraphEdgeWhereUniqueInput
  create: Prisma.XOR<Prisma.GraphEdgeCreateWithoutStartNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput>
}

export type GraphEdgeCreateManyStartNodeInputEnvelope = {
  data: Prisma.GraphEdgeCreateManyStartNodeInput | Prisma.GraphEdgeCreateManyStartNodeInput[]
  skipDuplicates?: boolean
}

export type GraphEdgeCreateWithoutEndNodeInput = {
  id?: string
  distance: number
  baseCost: number
  penalty?: number
  startNode: Prisma.GraphNodeCreateNestedOneWithoutOutgoingInput
}

export type GraphEdgeUncheckedCreateWithoutEndNodeInput = {
  id?: string
  startNodeId: string
  distance: number
  baseCost: number
  penalty?: number
}

export type GraphEdgeCreateOrConnectWithoutEndNodeInput = {
  where: Prisma.GraphEdgeWhereUniqueInput
  create: Prisma.XOR<Prisma.GraphEdgeCreateWithoutEndNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput>
}

export type GraphEdgeCreateManyEndNodeInputEnvelope = {
  data: Prisma.GraphEdgeCreateManyEndNodeInput | Prisma.GraphEdgeCreateManyEndNodeInput[]
  skipDuplicates?: boolean
}

export type GraphEdgeUpsertWithWhereUniqueWithoutStartNodeInput = {
  where: Prisma.GraphEdgeWhereUniqueInput
  update: Prisma.XOR<Prisma.GraphEdgeUpdateWithoutStartNodeInput, Prisma.GraphEdgeUncheckedUpdateWithoutStartNodeInput>
  create: Prisma.XOR<Prisma.GraphEdgeCreateWithoutStartNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutStartNodeInput>
}

export type GraphEdgeUpdateWithWhereUniqueWithoutStartNodeInput = {
  where: Prisma.GraphEdgeWhereUniqueInput
  data: Prisma.XOR<Prisma.GraphEdgeUpdateWithoutStartNodeInput, Prisma.GraphEdgeUncheckedUpdateWithoutStartNodeInput>
}

export type GraphEdgeUpdateManyWithWhereWithoutStartNodeInput = {
  where: Prisma.GraphEdgeScalarWhereInput
  data: Prisma.XOR<Prisma.GraphEdgeUpdateManyMutationInput, Prisma.GraphEdgeUncheckedUpdateManyWithoutStartNodeInput>
}

export type GraphEdgeScalarWhereInput = {
  AND?: Prisma.GraphEdgeScalarWhereInput | Prisma.GraphEdgeScalarWhereInput[]
  OR?: Prisma.GraphEdgeScalarWhereInput[]
  NOT?: Prisma.GraphEdgeScalarWhereInput | Prisma.GraphEdgeScalarWhereInput[]
  id?: Prisma.StringFilter<"GraphEdge"> | string
  startNodeId?: Prisma.StringFilter<"GraphEdge"> | string
  endNodeId?: Prisma.StringFilter<"GraphEdge"> | string
  distance?: Prisma.FloatFilter<"GraphEdge"> | number
  baseCost?: Prisma.FloatFilter<"GraphEdge"> | number
  penalty?: Prisma.FloatFilter<"GraphEdge"> | number
}

export type GraphEdgeUpsertWithWhereUniqueWithoutEndNodeInput = {
  where: Prisma.GraphEdgeWhereUniqueInput
  update: Prisma.XOR<Prisma.GraphEdgeUpdateWithoutEndNodeInput, Prisma.GraphEdgeUncheckedUpdateWithoutEndNodeInput>
  create: Prisma.XOR<Prisma.GraphEdgeCreateWithoutEndNodeInput, Prisma.GraphEdgeUncheckedCreateWithoutEndNodeInput>
}

export type GraphEdgeUpdateWithWhereUniqueWithoutEndNodeInput = {
  where: Prisma.GraphEdgeWhereUniqueInput
  data: Prisma.XOR<Prisma.GraphEdgeUpdateWithoutEndNodeInput, Prisma.GraphEdgeUncheckedUpdateWithoutEndNodeInput>
}

export type GraphEdgeUpdateManyWithWhereWithoutEndNodeInput = {
  where: Prisma.GraphEdgeScalarWhereInput
  data: Prisma.XOR<Prisma.GraphEdgeUpdateManyMutationInput, Prisma.GraphEdgeUncheckedUpdateManyWithoutEndNodeInput>
}

export type GraphEdgeCreateManyStartNodeInput = {
  id?: string
  endNodeId: string
  distance: number
  baseCost: number
  penalty?: number
}

export type GraphEdgeCreateManyEndNodeInput = {
  id?: string
  startNodeId: string
  distance: number
  baseCost: number
  penalty?: number
}

export type GraphEdgeUpdateWithoutStartNodeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
  endNode?: Prisma.GraphNodeUpdateOneRequiredWithoutIncomingNestedInput
}

export type GraphEdgeUncheckedUpdateWithoutStartNodeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  endNodeId?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type GraphEdgeUncheckedUpdateManyWithoutStartNodeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  endNodeId?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type GraphEdgeUpdateWithoutEndNodeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
  startNode?: Prisma.GraphNodeUpdateOneRequiredWithoutOutgoingNestedInput
}

export type GraphEdgeUncheckedUpdateWithoutEndNodeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startNodeId?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type GraphEdgeUncheckedUpdateManyWithoutEndNodeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  startNodeId?: Prisma.StringFieldUpdateOperationsInput | string
  distance?: Prisma.FloatFieldUpdateOperationsInput | number
  baseCost?: Prisma.FloatFieldUpdateOperationsInput | number
  penalty?: Prisma.FloatFieldUpdateOperationsInput | number
}



export type GraphEdgeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  startNodeId?: boolean
  endNodeId?: boolean
  distance?: boolean
  baseCost?: boolean
  penalty?: boolean
  startNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
  endNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["graphEdge"]>

export type GraphEdgeSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  startNodeId?: boolean
  endNodeId?: boolean
  distance?: boolean
  baseCost?: boolean
  penalty?: boolean
  startNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
  endNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["graphEdge"]>

export type GraphEdgeSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  startNodeId?: boolean
  endNodeId?: boolean
  distance?: boolean
  baseCost?: boolean
  penalty?: boolean
  startNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
  endNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["graphEdge"]>

export type GraphEdgeSelectScalar = {
  id?: boolean
  startNodeId?: boolean
  endNodeId?: boolean
  distance?: boolean
  baseCost?: boolean
  penalty?: boolean
}

export type GraphEdgeOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "startNodeId" | "endNodeId" | "distance" | "baseCost" | "penalty", ExtArgs["result"]["graphEdge"]>
export type GraphEdgeInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  startNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
  endNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
}
export type GraphEdgeIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  startNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
  endNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
}
export type GraphEdgeIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  startNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
  endNode?: boolean | Prisma.GraphNodeDefaultArgs<ExtArgs>
}

export type $GraphEdgePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "GraphEdge"
  objects: {
    startNode: Prisma.$GraphNodePayload<ExtArgs>
    endNode: Prisma.$GraphNodePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    startNodeId: string
    endNodeId: string
    distance: number
    baseCost: number
    penalty: number
  }, ExtArgs["result"]["graphEdge"]>
  composites: {}
}

export type GraphEdgeGetPayload<S extends boolean | null | undefined | GraphEdgeDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload, S>

export type GraphEdgeCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<GraphEdgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: GraphEdgeCountAggregateInputType | true
  }

export interface GraphEdgeDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GraphEdge'], meta: { name: 'GraphEdge' } }
  /**
   * Find zero or one GraphEdge that matches the filter.
   * @param {GraphEdgeFindUniqueArgs} args - Arguments to find a GraphEdge
   * @example
   * // Get one GraphEdge
   * const graphEdge = await prisma.graphEdge.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends GraphEdgeFindUniqueArgs>(args: Prisma.SelectSubset<T, GraphEdgeFindUniqueArgs<ExtArgs>>): Prisma.Prisma__GraphEdgeClient<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one GraphEdge that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {GraphEdgeFindUniqueOrThrowArgs} args - Arguments to find a GraphEdge
   * @example
   * // Get one GraphEdge
   * const graphEdge = await prisma.graphEdge.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends GraphEdgeFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, GraphEdgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__GraphEdgeClient<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first GraphEdge that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphEdgeFindFirstArgs} args - Arguments to find a GraphEdge
   * @example
   * // Get one GraphEdge
   * const graphEdge = await prisma.graphEdge.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends GraphEdgeFindFirstArgs>(args?: Prisma.SelectSubset<T, GraphEdgeFindFirstArgs<ExtArgs>>): Prisma.Prisma__GraphEdgeClient<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first GraphEdge that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphEdgeFindFirstOrThrowArgs} args - Arguments to find a GraphEdge
   * @example
   * // Get one GraphEdge
   * const graphEdge = await prisma.graphEdge.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends GraphEdgeFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, GraphEdgeFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__GraphEdgeClient<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more GraphEdges that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphEdgeFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all GraphEdges
   * const graphEdges = await prisma.graphEdge.findMany()
   * 
   * // Get first 10 GraphEdges
   * const graphEdges = await prisma.graphEdge.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const graphEdgeWithIdOnly = await prisma.graphEdge.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends GraphEdgeFindManyArgs>(args?: Prisma.SelectSubset<T, GraphEdgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a GraphEdge.
   * @param {GraphEdgeCreateArgs} args - Arguments to create a GraphEdge.
   * @example
   * // Create one GraphEdge
   * const GraphEdge = await prisma.graphEdge.create({
   *   data: {
   *     // ... data to create a GraphEdge
   *   }
   * })
   * 
   */
  create<T extends GraphEdgeCreateArgs>(args: Prisma.SelectSubset<T, GraphEdgeCreateArgs<ExtArgs>>): Prisma.Prisma__GraphEdgeClient<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many GraphEdges.
   * @param {GraphEdgeCreateManyArgs} args - Arguments to create many GraphEdges.
   * @example
   * // Create many GraphEdges
   * const graphEdge = await prisma.graphEdge.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends GraphEdgeCreateManyArgs>(args?: Prisma.SelectSubset<T, GraphEdgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many GraphEdges and returns the data saved in the database.
   * @param {GraphEdgeCreateManyAndReturnArgs} args - Arguments to create many GraphEdges.
   * @example
   * // Create many GraphEdges
   * const graphEdge = await prisma.graphEdge.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many GraphEdges and only return the `id`
   * const graphEdgeWithIdOnly = await prisma.graphEdge.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends GraphEdgeCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, GraphEdgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a GraphEdge.
   * @param {GraphEdgeDeleteArgs} args - Arguments to delete one GraphEdge.
   * @example
   * // Delete one GraphEdge
   * const GraphEdge = await prisma.graphEdge.delete({
   *   where: {
   *     // ... filter to delete one GraphEdge
   *   }
   * })
   * 
   */
  delete<T extends GraphEdgeDeleteArgs>(args: Prisma.SelectSubset<T, GraphEdgeDeleteArgs<ExtArgs>>): Prisma.Prisma__GraphEdgeClient<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one GraphEdge.
   * @param {GraphEdgeUpdateArgs} args - Arguments to update one GraphEdge.
   * @example
   * // Update one GraphEdge
   * const graphEdge = await prisma.graphEdge.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends GraphEdgeUpdateArgs>(args: Prisma.SelectSubset<T, GraphEdgeUpdateArgs<ExtArgs>>): Prisma.Prisma__GraphEdgeClient<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more GraphEdges.
   * @param {GraphEdgeDeleteManyArgs} args - Arguments to filter GraphEdges to delete.
   * @example
   * // Delete a few GraphEdges
   * const { count } = await prisma.graphEdge.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends GraphEdgeDeleteManyArgs>(args?: Prisma.SelectSubset<T, GraphEdgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more GraphEdges.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphEdgeUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many GraphEdges
   * const graphEdge = await prisma.graphEdge.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends GraphEdgeUpdateManyArgs>(args: Prisma.SelectSubset<T, GraphEdgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more GraphEdges and returns the data updated in the database.
   * @param {GraphEdgeUpdateManyAndReturnArgs} args - Arguments to update many GraphEdges.
   * @example
   * // Update many GraphEdges
   * const graphEdge = await prisma.graphEdge.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more GraphEdges and only return the `id`
   * const graphEdgeWithIdOnly = await prisma.graphEdge.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends GraphEdgeUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, GraphEdgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one GraphEdge.
   * @param {GraphEdgeUpsertArgs} args - Arguments to update or create a GraphEdge.
   * @example
   * // Update or create a GraphEdge
   * const graphEdge = await prisma.graphEdge.upsert({
   *   create: {
   *     // ... data to create a GraphEdge
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the GraphEdge we want to update
   *   }
   * })
   */
  upsert<T extends GraphEdgeUpsertArgs>(args: Prisma.SelectSubset<T, GraphEdgeUpsertArgs<ExtArgs>>): Prisma.Prisma__GraphEdgeClient<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of GraphEdges.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphEdgeCountArgs} args - Arguments to filter GraphEdges to count.
   * @example
   * // Count the number of GraphEdges
   * const count = await prisma.graphEdge.count({
   *   where: {
   *     // ... the filter for the GraphEdges we want to count
   *   }
   * })
  **/
  count<T extends GraphEdgeCountArgs>(
    args?: Prisma.Subset<T, GraphEdgeCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], GraphEdgeCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a GraphEdge.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphEdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends GraphEdgeAggregateArgs>(args: Prisma.Subset<T, GraphEdgeAggregateArgs>): Prisma.PrismaPromise<GetGraphEdgeAggregateType<T>>

  /**
   * Group by GraphEdge.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphEdgeGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends GraphEdgeGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: GraphEdgeGroupByArgs['orderBy'] }
      : { orderBy?: GraphEdgeGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, GraphEdgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGraphEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the GraphEdge model
 */
readonly fields: GraphEdgeFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for GraphEdge.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__GraphEdgeClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  startNode<T extends Prisma.GraphNodeDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.GraphNodeDefaultArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  endNode<T extends Prisma.GraphNodeDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.GraphNodeDefaultArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the GraphEdge model
 */
export interface GraphEdgeFieldRefs {
  readonly id: Prisma.FieldRef<"GraphEdge", 'String'>
  readonly startNodeId: Prisma.FieldRef<"GraphEdge", 'String'>
  readonly endNodeId: Prisma.FieldRef<"GraphEdge", 'String'>
  readonly distance: Prisma.FieldRef<"GraphEdge", 'Float'>
  readonly baseCost: Prisma.FieldRef<"GraphEdge", 'Float'>
  readonly penalty: Prisma.FieldRef<"GraphEdge", 'Float'>
}
    

// Custom InputTypes
/**
 * GraphEdge findUnique
 */
export type GraphEdgeFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * Filter, which GraphEdge to fetch.
   */
  where: Prisma.GraphEdgeWhereUniqueInput
}

/**
 * GraphEdge findUniqueOrThrow
 */
export type GraphEdgeFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * Filter, which GraphEdge to fetch.
   */
  where: Prisma.GraphEdgeWhereUniqueInput
}

/**
 * GraphEdge findFirst
 */
export type GraphEdgeFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * Filter, which GraphEdge to fetch.
   */
  where?: Prisma.GraphEdgeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GraphEdges to fetch.
   */
  orderBy?: Prisma.GraphEdgeOrderByWithRelationInput | Prisma.GraphEdgeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for GraphEdges.
   */
  cursor?: Prisma.GraphEdgeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GraphEdges from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GraphEdges.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of GraphEdges.
   */
  distinct?: Prisma.GraphEdgeScalarFieldEnum | Prisma.GraphEdgeScalarFieldEnum[]
}

/**
 * GraphEdge findFirstOrThrow
 */
export type GraphEdgeFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * Filter, which GraphEdge to fetch.
   */
  where?: Prisma.GraphEdgeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GraphEdges to fetch.
   */
  orderBy?: Prisma.GraphEdgeOrderByWithRelationInput | Prisma.GraphEdgeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for GraphEdges.
   */
  cursor?: Prisma.GraphEdgeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GraphEdges from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GraphEdges.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of GraphEdges.
   */
  distinct?: Prisma.GraphEdgeScalarFieldEnum | Prisma.GraphEdgeScalarFieldEnum[]
}

/**
 * GraphEdge findMany
 */
export type GraphEdgeFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * Filter, which GraphEdges to fetch.
   */
  where?: Prisma.GraphEdgeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GraphEdges to fetch.
   */
  orderBy?: Prisma.GraphEdgeOrderByWithRelationInput | Prisma.GraphEdgeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing GraphEdges.
   */
  cursor?: Prisma.GraphEdgeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GraphEdges from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GraphEdges.
   */
  skip?: number
  distinct?: Prisma.GraphEdgeScalarFieldEnum | Prisma.GraphEdgeScalarFieldEnum[]
}

/**
 * GraphEdge create
 */
export type GraphEdgeCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * The data needed to create a GraphEdge.
   */
  data: Prisma.XOR<Prisma.GraphEdgeCreateInput, Prisma.GraphEdgeUncheckedCreateInput>
}

/**
 * GraphEdge createMany
 */
export type GraphEdgeCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many GraphEdges.
   */
  data: Prisma.GraphEdgeCreateManyInput | Prisma.GraphEdgeCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * GraphEdge createManyAndReturn
 */
export type GraphEdgeCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * The data used to create many GraphEdges.
   */
  data: Prisma.GraphEdgeCreateManyInput | Prisma.GraphEdgeCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * GraphEdge update
 */
export type GraphEdgeUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * The data needed to update a GraphEdge.
   */
  data: Prisma.XOR<Prisma.GraphEdgeUpdateInput, Prisma.GraphEdgeUncheckedUpdateInput>
  /**
   * Choose, which GraphEdge to update.
   */
  where: Prisma.GraphEdgeWhereUniqueInput
}

/**
 * GraphEdge updateMany
 */
export type GraphEdgeUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update GraphEdges.
   */
  data: Prisma.XOR<Prisma.GraphEdgeUpdateManyMutationInput, Prisma.GraphEdgeUncheckedUpdateManyInput>
  /**
   * Filter which GraphEdges to update
   */
  where?: Prisma.GraphEdgeWhereInput
  /**
   * Limit how many GraphEdges to update.
   */
  limit?: number
}

/**
 * GraphEdge updateManyAndReturn
 */
export type GraphEdgeUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * The data used to update GraphEdges.
   */
  data: Prisma.XOR<Prisma.GraphEdgeUpdateManyMutationInput, Prisma.GraphEdgeUncheckedUpdateManyInput>
  /**
   * Filter which GraphEdges to update
   */
  where?: Prisma.GraphEdgeWhereInput
  /**
   * Limit how many GraphEdges to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * GraphEdge upsert
 */
export type GraphEdgeUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * The filter to search for the GraphEdge to update in case it exists.
   */
  where: Prisma.GraphEdgeWhereUniqueInput
  /**
   * In case the GraphEdge found by the `where` argument doesn't exist, create a new GraphEdge with this data.
   */
  create: Prisma.XOR<Prisma.GraphEdgeCreateInput, Prisma.GraphEdgeUncheckedCreateInput>
  /**
   * In case the GraphEdge was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.GraphEdgeUpdateInput, Prisma.GraphEdgeUncheckedUpdateInput>
}

/**
 * GraphEdge delete
 */
export type GraphEdgeDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  /**
   * Filter which GraphEdge to delete.
   */
  where: Prisma.GraphEdgeWhereUniqueInput
}

/**
 * GraphEdge deleteMany
 */
export type GraphEdgeDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which GraphEdges to delete
   */
  where?: Prisma.GraphEdgeWhereInput
  /**
   * Limit how many GraphEdges to delete.
   */
  limit?: number
}

/**
 * GraphEdge without action
 */
export type GraphEdgeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\GraphNode.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `GraphNode` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model GraphNode
 * 
 */
export type GraphNodeModel = runtime.Types.Result.DefaultSelection<Prisma.$GraphNodePayload>

export type AggregateGraphNode = {
  _count: GraphNodeCountAggregateOutputType | null
  _avg: GraphNodeAvgAggregateOutputType | null
  _sum: GraphNodeSumAggregateOutputType | null
  _min: GraphNodeMinAggregateOutputType | null
  _max: GraphNodeMaxAggregateOutputType | null
}

export type GraphNodeAvgAggregateOutputType = {
  latitude: number | null
  longitude: number | null
}

export type GraphNodeSumAggregateOutputType = {
  latitude: number | null
  longitude: number | null
}

export type GraphNodeMinAggregateOutputType = {
  id: string | null
  osmId: string | null
  latitude: number | null
  longitude: number | null
}

export type GraphNodeMaxAggregateOutputType = {
  id: string | null
  osmId: string | null
  latitude: number | null
  longitude: number | null
}

export type GraphNodeCountAggregateOutputType = {
  id: number
  osmId: number
  latitude: number
  longitude: number
  _all: number
}


export type GraphNodeAvgAggregateInputType = {
  latitude?: true
  longitude?: true
}

export type GraphNodeSumAggregateInputType = {
  latitude?: true
  longitude?: true
}

export type GraphNodeMinAggregateInputType = {
  id?: true
  osmId?: true
  latitude?: true
  longitude?: true
}

export type GraphNodeMaxAggregateInputType = {
  id?: true
  osmId?: true
  latitude?: true
  longitude?: true
}

export type GraphNodeCountAggregateInputType = {
  id?: true
  osmId?: true
  latitude?: true
  longitude?: true
  _all?: true
}

export type GraphNodeAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which GraphNode to aggregate.
   */
  where?: Prisma.GraphNodeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GraphNodes to fetch.
   */
  orderBy?: Prisma.GraphNodeOrderByWithRelationInput | Prisma.GraphNodeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.GraphNodeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GraphNodes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GraphNodes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned GraphNodes
  **/
  _count?: true | GraphNodeCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: GraphNodeAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: GraphNodeSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: GraphNodeMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: GraphNodeMaxAggregateInputType
}

export type GetGraphNodeAggregateType<T extends GraphNodeAggregateArgs> = {
      [P in keyof T & keyof AggregateGraphNode]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateGraphNode[P]>
    : Prisma.GetScalarType<T[P], AggregateGraphNode[P]>
}




export type GraphNodeGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.GraphNodeWhereInput
  orderBy?: Prisma.GraphNodeOrderByWithAggregationInput | Prisma.GraphNodeOrderByWithAggregationInput[]
  by: Prisma.GraphNodeScalarFieldEnum[] | Prisma.GraphNodeScalarFieldEnum
  having?: Prisma.GraphNodeScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: GraphNodeCountAggregateInputType | true
  _avg?: GraphNodeAvgAggregateInputType
  _sum?: GraphNodeSumAggregateInputType
  _min?: GraphNodeMinAggregateInputType
  _max?: GraphNodeMaxAggregateInputType
}

export type GraphNodeGroupByOutputType = {
  id: string
  osmId: string
  latitude: number
  longitude: number
  _count: GraphNodeCountAggregateOutputType | null
  _avg: GraphNodeAvgAggregateOutputType | null
  _sum: GraphNodeSumAggregateOutputType | null
  _min: GraphNodeMinAggregateOutputType | null
  _max: GraphNodeMaxAggregateOutputType | null
}

type GetGraphNodeGroupByPayload<T extends GraphNodeGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<GraphNodeGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof GraphNodeGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], GraphNodeGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], GraphNodeGroupByOutputType[P]>
      }
    >
  >



export type GraphNodeWhereInput = {
  AND?: Prisma.GraphNodeWhereInput | Prisma.GraphNodeWhereInput[]
  OR?: Prisma.GraphNodeWhereInput[]
  NOT?: Prisma.GraphNodeWhereInput | Prisma.GraphNodeWhereInput[]
  id?: Prisma.StringFilter<"GraphNode"> | string
  osmId?: Prisma.StringFilter<"GraphNode"> | string
  latitude?: Prisma.FloatFilter<"GraphNode"> | number
  longitude?: Prisma.FloatFilter<"GraphNode"> | number
  outgoing?: Prisma.GraphEdgeListRelationFilter
  incoming?: Prisma.GraphEdgeListRelationFilter
}

export type GraphNodeOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  osmId?: Prisma.SortOrder
  latitude?: Prisma.SortOrder
  longitude?: Prisma.SortOrder
  outgoing?: Prisma.GraphEdgeOrderByRelationAggregateInput
  incoming?: Prisma.GraphEdgeOrderByRelationAggregateInput
}

export type GraphNodeWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  osmId?: string
  AND?: Prisma.GraphNodeWhereInput | Prisma.GraphNodeWhereInput[]
  OR?: Prisma.GraphNodeWhereInput[]
  NOT?: Prisma.GraphNodeWhereInput | Prisma.GraphNodeWhereInput[]
  latitude?: Prisma.FloatFilter<"GraphNode"> | number
  longitude?: Prisma.FloatFilter<"GraphNode"> | number
  outgoing?: Prisma.GraphEdgeListRelationFilter
  incoming?: Prisma.GraphEdgeListRelationFilter
}, "id" | "osmId">

export type GraphNodeOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  osmId?: Prisma.SortOrder
  latitude?: Prisma.SortOrder
  longitude?: Prisma.SortOrder
  _count?: Prisma.GraphNodeCountOrderByAggregateInput
  _avg?: Prisma.GraphNodeAvgOrderByAggregateInput
  _max?: Prisma.GraphNodeMaxOrderByAggregateInput
  _min?: Prisma.GraphNodeMinOrderByAggregateInput
  _sum?: Prisma.GraphNodeSumOrderByAggregateInput
}

export type GraphNodeScalarWhereWithAggregatesInput = {
  AND?: Prisma.GraphNodeScalarWhereWithAggregatesInput | Prisma.GraphNodeScalarWhereWithAggregatesInput[]
  OR?: Prisma.GraphNodeScalarWhereWithAggregatesInput[]
  NOT?: Prisma.GraphNodeScalarWhereWithAggregatesInput | Prisma.GraphNodeScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"GraphNode"> | string
  osmId?: Prisma.StringWithAggregatesFilter<"GraphNode"> | string
  latitude?: Prisma.FloatWithAggregatesFilter<"GraphNode"> | number
  longitude?: Prisma.FloatWithAggregatesFilter<"GraphNode"> | number
}

export type GraphNodeCreateInput = {
  id?: string
  osmId: string
  latitude: number
  longitude: number
  outgoing?: Prisma.GraphEdgeCreateNestedManyWithoutStartNodeInput
  incoming?: Prisma.GraphEdgeCreateNestedManyWithoutEndNodeInput
}

export type GraphNodeUncheckedCreateInput = {
  id?: string
  osmId: string
  latitude: number
  longitude: number
  outgoing?: Prisma.GraphEdgeUncheckedCreateNestedManyWithoutStartNodeInput
  incoming?: Prisma.GraphEdgeUncheckedCreateNestedManyWithoutEndNodeInput
}

export type GraphNodeUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  osmId?: Prisma.StringFieldUpdateOperationsInput | string
  latitude?: Prisma.FloatFieldUpdateOperationsInput | number
  longitude?: Prisma.FloatFieldUpdateOperationsInput | number
  outgoing?: Prisma.GraphEdgeUpdateManyWithoutStartNodeNestedInput
  incoming?: Prisma.GraphEdgeUpdateManyWithoutEndNodeNestedInput
}

export type GraphNodeUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  osmId?: Prisma.StringFieldUpdateOperationsInput | string
  latitude?: Prisma.FloatFieldUpdateOperationsInput | number
  longitude?: Prisma.FloatFieldUpdateOperationsInput | number
  outgoing?: Prisma.GraphEdgeUncheckedUpdateManyWithoutStartNodeNestedInput
  incoming?: Prisma.GraphEdgeUncheckedUpdateManyWithoutEndNodeNestedInput
}

export type GraphNodeCreateManyInput = {
  id?: string
  osmId: string
  latitude: number
  longitude: number
}

export type GraphNodeUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  osmId?: Prisma.StringFieldUpdateOperationsInput | string
  latitude?: Prisma.FloatFieldUpdateOperationsInput | number
  longitude?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type GraphNodeUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  osmId?: Prisma.StringFieldUpdateOperationsInput | string
  latitude?: Prisma.FloatFieldUpdateOperationsInput | number
  longitude?: Prisma.FloatFieldUpdateOperationsInput | number
}

export type GraphNodeCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  osmId?: Prisma.SortOrder
  latitude?: Prisma.SortOrder
  longitude?: Prisma.SortOrder
}

export type GraphNodeAvgOrderByAggregateInput = {
  latitude?: Prisma.SortOrder
  longitude?: Prisma.SortOrder
}

export type GraphNodeMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  osmId?: Prisma.SortOrder
  latitude?: Prisma.SortOrder
  longitude?: Prisma.SortOrder
}

export type GraphNodeMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  osmId?: Prisma.SortOrder
  latitude?: Prisma.SortOrder
  longitude?: Prisma.SortOrder
}

export type GraphNodeSumOrderByAggregateInput = {
  latitude?: Prisma.SortOrder
  longitude?: Prisma.SortOrder
}

export type GraphNodeScalarRelationFilter = {
  is?: Prisma.GraphNodeWhereInput
  isNot?: Prisma.GraphNodeWhereInput
}

export type FloatFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type GraphNodeCreateNestedOneWithoutOutgoingInput = {
  create?: Prisma.XOR<Prisma.GraphNodeCreateWithoutOutgoingInput, Prisma.GraphNodeUncheckedCreateWithoutOutgoingInput>
  connectOrCreate?: Prisma.GraphNodeCreateOrConnectWithoutOutgoingInput
  connect?: Prisma.GraphNodeWhereUniqueInput
}

export type GraphNodeCreateNestedOneWithoutIncomingInput = {
  create?: Prisma.XOR<Prisma.GraphNodeCreateWithoutIncomingInput, Prisma.GraphNodeUncheckedCreateWithoutIncomingInput>
  connectOrCreate?: Prisma.GraphNodeCreateOrConnectWithoutIncomingInput
  connect?: Prisma.GraphNodeWhereUniqueInput
}

export type GraphNodeUpdateOneRequiredWithoutOutgoingNestedInput = {
  create?: Prisma.XOR<Prisma.GraphNodeCreateWithoutOutgoingInput, Prisma.GraphNodeUncheckedCreateWithoutOutgoingInput>
  connectOrCreate?: Prisma.GraphNodeCreateOrConnectWithoutOutgoingInput
  upsert?: Prisma.GraphNodeUpsertWithoutOutgoingInput
  connect?: Prisma.GraphNodeWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.GraphNodeUpdateToOneWithWhereWithoutOutgoingInput, Prisma.GraphNodeUpdateWithoutOutgoingInput>, Prisma.GraphNodeUncheckedUpdateWithoutOutgoingInput>
}

export type GraphNodeUpdateOneRequiredWithoutIncomingNestedInput = {
  create?: Prisma.XOR<Prisma.GraphNodeCreateWithoutIncomingInput, Prisma.GraphNodeUncheckedCreateWithoutIncomingInput>
  connectOrCreate?: Prisma.GraphNodeCreateOrConnectWithoutIncomingInput
  upsert?: Prisma.GraphNodeUpsertWithoutIncomingInput
  connect?: Prisma.GraphNodeWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.GraphNodeUpdateToOneWithWhereWithoutIncomingInput, Prisma.GraphNodeUpdateWithoutIncomingInput>, Prisma.GraphNodeUncheckedUpdateWithoutIncomingInput>
}

export type GraphNodeCreateWithoutOutgoingInput = {
  id?: string
  osmId: string
  latitude: number
  longitude: number
  incoming?: Prisma.GraphEdgeCreateNestedManyWithoutEndNodeInput
}

export type GraphNodeUncheckedCreateWithoutOutgoingInput = {
  id?: string
  osmId: string
  latitude: number
  longitude: number
  incoming?: Prisma.GraphEdgeUncheckedCreateNestedManyWithoutEndNodeInput
}

export type GraphNodeCreateOrConnectWithoutOutgoingInput = {
  where: Prisma.GraphNodeWhereUniqueInput
  create: Prisma.XOR<Prisma.GraphNodeCreateWithoutOutgoingInput, Prisma.GraphNodeUncheckedCreateWithoutOutgoingInput>
}

export type GraphNodeCreateWithoutIncomingInput = {
  id?: string
  osmId: string
  latitude: number
  longitude: number
  outgoing?: Prisma.GraphEdgeCreateNestedManyWithoutStartNodeInput
}

export type GraphNodeUncheckedCreateWithoutIncomingInput = {
  id?: string
  osmId: string
  latitude: number
  longitude: number
  outgoing?: Prisma.GraphEdgeUncheckedCreateNestedManyWithoutStartNodeInput
}

export type GraphNodeCreateOrConnectWithoutIncomingInput = {
  where: Prisma.GraphNodeWhereUniqueInput
  create: Prisma.XOR<Prisma.GraphNodeCreateWithoutIncomingInput, Prisma.GraphNodeUncheckedCreateWithoutIncomingInput>
}

export type GraphNodeUpsertWithoutOutgoingInput = {
  update: Prisma.XOR<Prisma.GraphNodeUpdateWithoutOutgoingInput, Prisma.GraphNodeUncheckedUpdateWithoutOutgoingInput>
  create: Prisma.XOR<Prisma.GraphNodeCreateWithoutOutgoingInput, Prisma.GraphNodeUncheckedCreateWithoutOutgoingInput>
  where?: Prisma.GraphNodeWhereInput
}

export type GraphNodeUpdateToOneWithWhereWithoutOutgoingInput = {
  where?: Prisma.GraphNodeWhereInput
  data: Prisma.XOR<Prisma.GraphNodeUpdateWithoutOutgoingInput, Prisma.GraphNodeUncheckedUpdateWithoutOutgoingInput>
}

export type GraphNodeUpdateWithoutOutgoingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  osmId?: Prisma.StringFieldUpdateOperationsInput | string
  latitude?: Prisma.FloatFieldUpdateOperationsInput | number
  longitude?: Prisma.FloatFieldUpdateOperationsInput | number
  incoming?: Prisma.GraphEdgeUpdateManyWithoutEndNodeNestedInput
}

export type GraphNodeUncheckedUpdateWithoutOutgoingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  osmId?: Prisma.StringFieldUpdateOperationsInput | string
  latitude?: Prisma.FloatFieldUpdateOperationsInput | number
  longitude?: Prisma.FloatFieldUpdateOperationsInput | number
  incoming?: Prisma.GraphEdgeUncheckedUpdateManyWithoutEndNodeNestedInput
}

export type GraphNodeUpsertWithoutIncomingInput = {
  update: Prisma.XOR<Prisma.GraphNodeUpdateWithoutIncomingInput, Prisma.GraphNodeUncheckedUpdateWithoutIncomingInput>
  create: Prisma.XOR<Prisma.GraphNodeCreateWithoutIncomingInput, Prisma.GraphNodeUncheckedCreateWithoutIncomingInput>
  where?: Prisma.GraphNodeWhereInput
}

export type GraphNodeUpdateToOneWithWhereWithoutIncomingInput = {
  where?: Prisma.GraphNodeWhereInput
  data: Prisma.XOR<Prisma.GraphNodeUpdateWithoutIncomingInput, Prisma.GraphNodeUncheckedUpdateWithoutIncomingInput>
}

export type GraphNodeUpdateWithoutIncomingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  osmId?: Prisma.StringFieldUpdateOperationsInput | string
  latitude?: Prisma.FloatFieldUpdateOperationsInput | number
  longitude?: Prisma.FloatFieldUpdateOperationsInput | number
  outgoing?: Prisma.GraphEdgeUpdateManyWithoutStartNodeNestedInput
}

export type GraphNodeUncheckedUpdateWithoutIncomingInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  osmId?: Prisma.StringFieldUpdateOperationsInput | string
  latitude?: Prisma.FloatFieldUpdateOperationsInput | number
  longitude?: Prisma.FloatFieldUpdateOperationsInput | number
  outgoing?: Prisma.GraphEdgeUncheckedUpdateManyWithoutStartNodeNestedInput
}


/**
 * Count Type GraphNodeCountOutputType
 */

export type GraphNodeCountOutputType = {
  outgoing: number
  incoming: number
}

export type GraphNodeCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  outgoing?: boolean | GraphNodeCountOutputTypeCountOutgoingArgs
  incoming?: boolean | GraphNodeCountOutputTypeCountIncomingArgs
}

/**
 * GraphNodeCountOutputType without action
 */
export type GraphNodeCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNodeCountOutputType
   */
  select?: Prisma.GraphNodeCountOutputTypeSelect<ExtArgs> | null
}

/**
 * GraphNodeCountOutputType without action
 */
export type GraphNodeCountOutputTypeCountOutgoingArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.GraphEdgeWhereInput
}

/**
 * GraphNodeCountOutputType without action
 */
export type GraphNodeCountOutputTypeCountIncomingArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.GraphEdgeWhereInput
}


export type GraphNodeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  osmId?: boolean
  latitude?: boolean
  longitude?: boolean
  outgoing?: boolean | Prisma.GraphNode$outgoingArgs<ExtArgs>
  incoming?: boolean | Prisma.GraphNode$incomingArgs<ExtArgs>
  _count?: boolean | Prisma.GraphNodeCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["graphNode"]>

export type GraphNodeSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  osmId?: boolean
  latitude?: boolean
  longitude?: boolean
}, ExtArgs["result"]["graphNode"]>

export type GraphNodeSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  osmId?: boolean
  latitude?: boolean
  longitude?: boolean
}, ExtArgs["result"]["graphNode"]>

export type GraphNodeSelectScalar = {
  id?: boolean
  osmId?: boolean
  latitude?: boolean
  longitude?: boolean
}

export type GraphNodeOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "osmId" | "latitude" | "longitude", ExtArgs["result"]["graphNode"]>
export type GraphNodeInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  outgoing?: boolean | Prisma.GraphNode$outgoingArgs<ExtArgs>
  incoming?: boolean | Prisma.GraphNode$incomingArgs<ExtArgs>
  _count?: boolean | Prisma.GraphNodeCountOutputTypeDefaultArgs<ExtArgs>
}
export type GraphNodeIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}
export type GraphNodeIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $GraphNodePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "GraphNode"
  objects: {
    outgoing: Prisma.$GraphEdgePayload<ExtArgs>[]
    incoming: Prisma.$GraphEdgePayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    osmId: string
    latitude: number
    longitude: number
  }, ExtArgs["result"]["graphNode"]>
  composites: {}
}

export type GraphNodeGetPayload<S extends boolean | null | undefined | GraphNodeDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$GraphNodePayload, S>

export type GraphNodeCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<GraphNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: GraphNodeCountAggregateInputType | true
  }

export interface GraphNodeDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GraphNode'], meta: { name: 'GraphNode' } }
  /**
   * Find zero or one GraphNode that matches the filter.
   * @param {GraphNodeFindUniqueArgs} args - Arguments to find a GraphNode
   * @example
   * // Get one GraphNode
   * const graphNode = await prisma.graphNode.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends GraphNodeFindUniqueArgs>(args: Prisma.SelectSubset<T, GraphNodeFindUniqueArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one GraphNode that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {GraphNodeFindUniqueOrThrowArgs} args - Arguments to find a GraphNode
   * @example
   * // Get one GraphNode
   * const graphNode = await prisma.graphNode.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends GraphNodeFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, GraphNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first GraphNode that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphNodeFindFirstArgs} args - Arguments to find a GraphNode
   * @example
   * // Get one GraphNode
   * const graphNode = await prisma.graphNode.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends GraphNodeFindFirstArgs>(args?: Prisma.SelectSubset<T, GraphNodeFindFirstArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first GraphNode that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphNodeFindFirstOrThrowArgs} args - Arguments to find a GraphNode
   * @example
   * // Get one GraphNode
   * const graphNode = await prisma.graphNode.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends GraphNodeFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, GraphNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more GraphNodes that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphNodeFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all GraphNodes
   * const graphNodes = await prisma.graphNode.findMany()
   * 
   * // Get first 10 GraphNodes
   * const graphNodes = await prisma.graphNode.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const graphNodeWithIdOnly = await prisma.graphNode.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends GraphNodeFindManyArgs>(args?: Prisma.SelectSubset<T, GraphNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a GraphNode.
   * @param {GraphNodeCreateArgs} args - Arguments to create a GraphNode.
   * @example
   * // Create one GraphNode
   * const GraphNode = await prisma.graphNode.create({
   *   data: {
   *     // ... data to create a GraphNode
   *   }
   * })
   * 
   */
  create<T extends GraphNodeCreateArgs>(args: Prisma.SelectSubset<T, GraphNodeCreateArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many GraphNodes.
   * @param {GraphNodeCreateManyArgs} args - Arguments to create many GraphNodes.
   * @example
   * // Create many GraphNodes
   * const graphNode = await prisma.graphNode.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends GraphNodeCreateManyArgs>(args?: Prisma.SelectSubset<T, GraphNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many GraphNodes and returns the data saved in the database.
   * @param {GraphNodeCreateManyAndReturnArgs} args - Arguments to create many GraphNodes.
   * @example
   * // Create many GraphNodes
   * const graphNode = await prisma.graphNode.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many GraphNodes and only return the `id`
   * const graphNodeWithIdOnly = await prisma.graphNode.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends GraphNodeCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, GraphNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a GraphNode.
   * @param {GraphNodeDeleteArgs} args - Arguments to delete one GraphNode.
   * @example
   * // Delete one GraphNode
   * const GraphNode = await prisma.graphNode.delete({
   *   where: {
   *     // ... filter to delete one GraphNode
   *   }
   * })
   * 
   */
  delete<T extends GraphNodeDeleteArgs>(args: Prisma.SelectSubset<T, GraphNodeDeleteArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one GraphNode.
   * @param {GraphNodeUpdateArgs} args - Arguments to update one GraphNode.
   * @example
   * // Update one GraphNode
   * const graphNode = await prisma.graphNode.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends GraphNodeUpdateArgs>(args: Prisma.SelectSubset<T, GraphNodeUpdateArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more GraphNodes.
   * @param {GraphNodeDeleteManyArgs} args - Arguments to filter GraphNodes to delete.
   * @example
   * // Delete a few GraphNodes
   * const { count } = await prisma.graphNode.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends GraphNodeDeleteManyArgs>(args?: Prisma.SelectSubset<T, GraphNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more GraphNodes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphNodeUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many GraphNodes
   * const graphNode = await prisma.graphNode.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends GraphNodeUpdateManyArgs>(args: Prisma.SelectSubset<T, GraphNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more GraphNodes and returns the data updated in the database.
   * @param {GraphNodeUpdateManyAndReturnArgs} args - Arguments to update many GraphNodes.
   * @example
   * // Update many GraphNodes
   * const graphNode = await prisma.graphNode.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more GraphNodes and only return the `id`
   * const graphNodeWithIdOnly = await prisma.graphNode.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends GraphNodeUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, GraphNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one GraphNode.
   * @param {GraphNodeUpsertArgs} args - Arguments to update or create a GraphNode.
   * @example
   * // Update or create a GraphNode
   * const graphNode = await prisma.graphNode.upsert({
   *   create: {
   *     // ... data to create a GraphNode
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the GraphNode we want to update
   *   }
   * })
   */
  upsert<T extends GraphNodeUpsertArgs>(args: Prisma.SelectSubset<T, GraphNodeUpsertArgs<ExtArgs>>): Prisma.Prisma__GraphNodeClient<runtime.Types.Result.GetResult<Prisma.$GraphNodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of GraphNodes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphNodeCountArgs} args - Arguments to filter GraphNodes to count.
   * @example
   * // Count the number of GraphNodes
   * const count = await prisma.graphNode.count({
   *   where: {
   *     // ... the filter for the GraphNodes we want to count
   *   }
   * })
  **/
  count<T extends GraphNodeCountArgs>(
    args?: Prisma.Subset<T, GraphNodeCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], GraphNodeCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a GraphNode.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends GraphNodeAggregateArgs>(args: Prisma.Subset<T, GraphNodeAggregateArgs>): Prisma.PrismaPromise<GetGraphNodeAggregateType<T>>

  /**
   * Group by GraphNode.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GraphNodeGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends GraphNodeGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: GraphNodeGroupByArgs['orderBy'] }
      : { orderBy?: GraphNodeGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, GraphNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGraphNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the GraphNode model
 */
readonly fields: GraphNodeFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for GraphNode.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__GraphNodeClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  outgoing<T extends Prisma.GraphNode$outgoingArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.GraphNode$outgoingArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  incoming<T extends Prisma.GraphNode$incomingArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.GraphNode$incomingArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GraphEdgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the GraphNode model
 */
export interface GraphNodeFieldRefs {
  readonly id: Prisma.FieldRef<"GraphNode", 'String'>
  readonly osmId: Prisma.FieldRef<"GraphNode", 'String'>
  readonly latitude: Prisma.FieldRef<"GraphNode", 'Float'>
  readonly longitude: Prisma.FieldRef<"GraphNode", 'Float'>
}
    

// Custom InputTypes
/**
 * GraphNode findUnique
 */
export type GraphNodeFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * Filter, which GraphNode to fetch.
   */
  where: Prisma.GraphNodeWhereUniqueInput
}

/**
 * GraphNode findUniqueOrThrow
 */
export type GraphNodeFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * Filter, which GraphNode to fetch.
   */
  where: Prisma.GraphNodeWhereUniqueInput
}

/**
 * GraphNode findFirst
 */
export type GraphNodeFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * Filter, which GraphNode to fetch.
   */
  where?: Prisma.GraphNodeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GraphNodes to fetch.
   */
  orderBy?: Prisma.GraphNodeOrderByWithRelationInput | Prisma.GraphNodeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for GraphNodes.
   */
  cursor?: Prisma.GraphNodeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GraphNodes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GraphNodes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of GraphNodes.
   */
  distinct?: Prisma.GraphNodeScalarFieldEnum | Prisma.GraphNodeScalarFieldEnum[]
}

/**
 * GraphNode findFirstOrThrow
 */
export type GraphNodeFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * Filter, which GraphNode to fetch.
   */
  where?: Prisma.GraphNodeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GraphNodes to fetch.
   */
  orderBy?: Prisma.GraphNodeOrderByWithRelationInput | Prisma.GraphNodeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for GraphNodes.
   */
  cursor?: Prisma.GraphNodeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GraphNodes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GraphNodes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of GraphNodes.
   */
  distinct?: Prisma.GraphNodeScalarFieldEnum | Prisma.GraphNodeScalarFieldEnum[]
}

/**
 * GraphNode findMany
 */
export type GraphNodeFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * Filter, which GraphNodes to fetch.
   */
  where?: Prisma.GraphNodeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GraphNodes to fetch.
   */
  orderBy?: Prisma.GraphNodeOrderByWithRelationInput | Prisma.GraphNodeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing GraphNodes.
   */
  cursor?: Prisma.GraphNodeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GraphNodes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GraphNodes.
   */
  skip?: number
  distinct?: Prisma.GraphNodeScalarFieldEnum | Prisma.GraphNodeScalarFieldEnum[]
}

/**
 * GraphNode create
 */
export type GraphNodeCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * The data needed to create a GraphNode.
   */
  data: Prisma.XOR<Prisma.GraphNodeCreateInput, Prisma.GraphNodeUncheckedCreateInput>
}

/**
 * GraphNode createMany
 */
export type GraphNodeCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many GraphNodes.
   */
  data: Prisma.GraphNodeCreateManyInput | Prisma.GraphNodeCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * GraphNode createManyAndReturn
 */
export type GraphNodeCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * The data used to create many GraphNodes.
   */
  data: Prisma.GraphNodeCreateManyInput | Prisma.GraphNodeCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * GraphNode update
 */
export type GraphNodeUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * The data needed to update a GraphNode.
   */
  data: Prisma.XOR<Prisma.GraphNodeUpdateInput, Prisma.GraphNodeUncheckedUpdateInput>
  /**
   * Choose, which GraphNode to update.
   */
  where: Prisma.GraphNodeWhereUniqueInput
}

/**
 * GraphNode updateMany
 */
export type GraphNodeUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update GraphNodes.
   */
  data: Prisma.XOR<Prisma.GraphNodeUpdateManyMutationInput, Prisma.GraphNodeUncheckedUpdateManyInput>
  /**
   * Filter which GraphNodes to update
   */
  where?: Prisma.GraphNodeWhereInput
  /**
   * Limit how many GraphNodes to update.
   */
  limit?: number
}

/**
 * GraphNode updateManyAndReturn
 */
export type GraphNodeUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * The data used to update GraphNodes.
   */
  data: Prisma.XOR<Prisma.GraphNodeUpdateManyMutationInput, Prisma.GraphNodeUncheckedUpdateManyInput>
  /**
   * Filter which GraphNodes to update
   */
  where?: Prisma.GraphNodeWhereInput
  /**
   * Limit how many GraphNodes to update.
   */
  limit?: number
}

/**
 * GraphNode upsert
 */
export type GraphNodeUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * The filter to search for the GraphNode to update in case it exists.
   */
  where: Prisma.GraphNodeWhereUniqueInput
  /**
   * In case the GraphNode found by the `where` argument doesn't exist, create a new GraphNode with this data.
   */
  create: Prisma.XOR<Prisma.GraphNodeCreateInput, Prisma.GraphNodeUncheckedCreateInput>
  /**
   * In case the GraphNode was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.GraphNodeUpdateInput, Prisma.GraphNodeUncheckedUpdateInput>
}

/**
 * GraphNode delete
 */
export type GraphNodeDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
  /**
   * Filter which GraphNode to delete.
   */
  where: Prisma.GraphNodeWhereUniqueInput
}

/**
 * GraphNode deleteMany
 */
export type GraphNodeDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which GraphNodes to delete
   */
  where?: Prisma.GraphNodeWhereInput
  /**
   * Limit how many GraphNodes to delete.
   */
  limit?: number
}

/**
 * GraphNode.outgoing
 */
export type GraphNode$outgoingArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  where?: Prisma.GraphEdgeWhereInput
  orderBy?: Prisma.GraphEdgeOrderByWithRelationInput | Prisma.GraphEdgeOrderByWithRelationInput[]
  cursor?: Prisma.GraphEdgeWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.GraphEdgeScalarFieldEnum | Prisma.GraphEdgeScalarFieldEnum[]
}

/**
 * GraphNode.incoming
 */
export type GraphNode$incomingArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphEdge
   */
  select?: Prisma.GraphEdgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphEdge
   */
  omit?: Prisma.GraphEdgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphEdgeInclude<ExtArgs> | null
  where?: Prisma.GraphEdgeWhereInput
  orderBy?: Prisma.GraphEdgeOrderByWithRelationInput | Prisma.GraphEdgeOrderByWithRelationInput[]
  cursor?: Prisma.GraphEdgeWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.GraphEdgeScalarFieldEnum | Prisma.GraphEdgeScalarFieldEnum[]
}

/**
 * GraphNode without action
 */
export type GraphNodeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GraphNode
   */
  select?: Prisma.GraphNodeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GraphNode
   */
  omit?: Prisma.GraphNodeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GraphNodeInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\GuestToken.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `GuestToken` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model GuestToken
 * 
 */
export type GuestTokenModel = runtime.Types.Result.DefaultSelection<Prisma.$GuestTokenPayload>

export type AggregateGuestToken = {
  _count: GuestTokenCountAggregateOutputType | null
  _avg: GuestTokenAvgAggregateOutputType | null
  _sum: GuestTokenSumAggregateOutputType | null
  _min: GuestTokenMinAggregateOutputType | null
  _max: GuestTokenMaxAggregateOutputType | null
}

export type GuestTokenAvgAggregateOutputType = {
  id: number | null
}

export type GuestTokenSumAggregateOutputType = {
  id: number | null
}

export type GuestTokenMinAggregateOutputType = {
  id: number | null
  token: string | null
  createdAt: Date | null
}

export type GuestTokenMaxAggregateOutputType = {
  id: number | null
  token: string | null
  createdAt: Date | null
}

export type GuestTokenCountAggregateOutputType = {
  id: number
  token: number
  createdAt: number
  _all: number
}


export type GuestTokenAvgAggregateInputType = {
  id?: true
}

export type GuestTokenSumAggregateInputType = {
  id?: true
}

export type GuestTokenMinAggregateInputType = {
  id?: true
  token?: true
  createdAt?: true
}

export type GuestTokenMaxAggregateInputType = {
  id?: true
  token?: true
  createdAt?: true
}

export type GuestTokenCountAggregateInputType = {
  id?: true
  token?: true
  createdAt?: true
  _all?: true
}

export type GuestTokenAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which GuestToken to aggregate.
   */
  where?: Prisma.GuestTokenWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GuestTokens to fetch.
   */
  orderBy?: Prisma.GuestTokenOrderByWithRelationInput | Prisma.GuestTokenOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.GuestTokenWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GuestTokens from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GuestTokens.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned GuestTokens
  **/
  _count?: true | GuestTokenCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: GuestTokenAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: GuestTokenSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: GuestTokenMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: GuestTokenMaxAggregateInputType
}

export type GetGuestTokenAggregateType<T extends GuestTokenAggregateArgs> = {
      [P in keyof T & keyof AggregateGuestToken]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateGuestToken[P]>
    : Prisma.GetScalarType<T[P], AggregateGuestToken[P]>
}




export type GuestTokenGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.GuestTokenWhereInput
  orderBy?: Prisma.GuestTokenOrderByWithAggregationInput | Prisma.GuestTokenOrderByWithAggregationInput[]
  by: Prisma.GuestTokenScalarFieldEnum[] | Prisma.GuestTokenScalarFieldEnum
  having?: Prisma.GuestTokenScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: GuestTokenCountAggregateInputType | true
  _avg?: GuestTokenAvgAggregateInputType
  _sum?: GuestTokenSumAggregateInputType
  _min?: GuestTokenMinAggregateInputType
  _max?: GuestTokenMaxAggregateInputType
}

export type GuestTokenGroupByOutputType = {
  id: number
  token: string
  createdAt: Date
  _count: GuestTokenCountAggregateOutputType | null
  _avg: GuestTokenAvgAggregateOutputType | null
  _sum: GuestTokenSumAggregateOutputType | null
  _min: GuestTokenMinAggregateOutputType | null
  _max: GuestTokenMaxAggregateOutputType | null
}

type GetGuestTokenGroupByPayload<T extends GuestTokenGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<GuestTokenGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof GuestTokenGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], GuestTokenGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], GuestTokenGroupByOutputType[P]>
      }
    >
  >



export type GuestTokenWhereInput = {
  AND?: Prisma.GuestTokenWhereInput | Prisma.GuestTokenWhereInput[]
  OR?: Prisma.GuestTokenWhereInput[]
  NOT?: Prisma.GuestTokenWhereInput | Prisma.GuestTokenWhereInput[]
  id?: Prisma.IntFilter<"GuestToken"> | number
  token?: Prisma.StringFilter<"GuestToken"> | string
  createdAt?: Prisma.DateTimeFilter<"GuestToken"> | Date | string
  issues?: Prisma.IssueListRelationFilter
}

export type GuestTokenOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  token?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issues?: Prisma.IssueOrderByRelationAggregateInput
}

export type GuestTokenWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  token?: string
  AND?: Prisma.GuestTokenWhereInput | Prisma.GuestTokenWhereInput[]
  OR?: Prisma.GuestTokenWhereInput[]
  NOT?: Prisma.GuestTokenWhereInput | Prisma.GuestTokenWhereInput[]
  createdAt?: Prisma.DateTimeFilter<"GuestToken"> | Date | string
  issues?: Prisma.IssueListRelationFilter
}, "id" | "token">

export type GuestTokenOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  token?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.GuestTokenCountOrderByAggregateInput
  _avg?: Prisma.GuestTokenAvgOrderByAggregateInput
  _max?: Prisma.GuestTokenMaxOrderByAggregateInput
  _min?: Prisma.GuestTokenMinOrderByAggregateInput
  _sum?: Prisma.GuestTokenSumOrderByAggregateInput
}

export type GuestTokenScalarWhereWithAggregatesInput = {
  AND?: Prisma.GuestTokenScalarWhereWithAggregatesInput | Prisma.GuestTokenScalarWhereWithAggregatesInput[]
  OR?: Prisma.GuestTokenScalarWhereWithAggregatesInput[]
  NOT?: Prisma.GuestTokenScalarWhereWithAggregatesInput | Prisma.GuestTokenScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"GuestToken"> | number
  token?: Prisma.StringWithAggregatesFilter<"GuestToken"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"GuestToken"> | Date | string
}

export type GuestTokenCreateInput = {
  token: string
  createdAt?: Date | string
  issues?: Prisma.IssueCreateNestedManyWithoutGuestTokenInput
}

export type GuestTokenUncheckedCreateInput = {
  id?: number
  token: string
  createdAt?: Date | string
  issues?: Prisma.IssueUncheckedCreateNestedManyWithoutGuestTokenInput
}

export type GuestTokenUpdateInput = {
  token?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issues?: Prisma.IssueUpdateManyWithoutGuestTokenNestedInput
}

export type GuestTokenUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  token?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issues?: Prisma.IssueUncheckedUpdateManyWithoutGuestTokenNestedInput
}

export type GuestTokenCreateManyInput = {
  id?: number
  token: string
  createdAt?: Date | string
}

export type GuestTokenUpdateManyMutationInput = {
  token?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type GuestTokenUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  token?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type GuestTokenCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  token?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type GuestTokenAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
}

export type GuestTokenMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  token?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type GuestTokenMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  token?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type GuestTokenSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
}

export type GuestTokenNullableScalarRelationFilter = {
  is?: Prisma.GuestTokenWhereInput | null
  isNot?: Prisma.GuestTokenWhereInput | null
}

export type GuestTokenCreateNestedOneWithoutIssuesInput = {
  create?: Prisma.XOR<Prisma.GuestTokenCreateWithoutIssuesInput, Prisma.GuestTokenUncheckedCreateWithoutIssuesInput>
  connectOrCreate?: Prisma.GuestTokenCreateOrConnectWithoutIssuesInput
  connect?: Prisma.GuestTokenWhereUniqueInput
}

export type GuestTokenUpdateOneWithoutIssuesNestedInput = {
  create?: Prisma.XOR<Prisma.GuestTokenCreateWithoutIssuesInput, Prisma.GuestTokenUncheckedCreateWithoutIssuesInput>
  connectOrCreate?: Prisma.GuestTokenCreateOrConnectWithoutIssuesInput
  upsert?: Prisma.GuestTokenUpsertWithoutIssuesInput
  disconnect?: Prisma.GuestTokenWhereInput | boolean
  delete?: Prisma.GuestTokenWhereInput | boolean
  connect?: Prisma.GuestTokenWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.GuestTokenUpdateToOneWithWhereWithoutIssuesInput, Prisma.GuestTokenUpdateWithoutIssuesInput>, Prisma.GuestTokenUncheckedUpdateWithoutIssuesInput>
}

export type GuestTokenCreateWithoutIssuesInput = {
  token: string
  createdAt?: Date | string
}

export type GuestTokenUncheckedCreateWithoutIssuesInput = {
  id?: number
  token: string
  createdAt?: Date | string
}

export type GuestTokenCreateOrConnectWithoutIssuesInput = {
  where: Prisma.GuestTokenWhereUniqueInput
  create: Prisma.XOR<Prisma.GuestTokenCreateWithoutIssuesInput, Prisma.GuestTokenUncheckedCreateWithoutIssuesInput>
}

export type GuestTokenUpsertWithoutIssuesInput = {
  update: Prisma.XOR<Prisma.GuestTokenUpdateWithoutIssuesInput, Prisma.GuestTokenUncheckedUpdateWithoutIssuesInput>
  create: Prisma.XOR<Prisma.GuestTokenCreateWithoutIssuesInput, Prisma.GuestTokenUncheckedCreateWithoutIssuesInput>
  where?: Prisma.GuestTokenWhereInput
}

export type GuestTokenUpdateToOneWithWhereWithoutIssuesInput = {
  where?: Prisma.GuestTokenWhereInput
  data: Prisma.XOR<Prisma.GuestTokenUpdateWithoutIssuesInput, Prisma.GuestTokenUncheckedUpdateWithoutIssuesInput>
}

export type GuestTokenUpdateWithoutIssuesInput = {
  token?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type GuestTokenUncheckedUpdateWithoutIssuesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  token?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}


/**
 * Count Type GuestTokenCountOutputType
 */

export type GuestTokenCountOutputType = {
  issues: number
}

export type GuestTokenCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issues?: boolean | GuestTokenCountOutputTypeCountIssuesArgs
}

/**
 * GuestTokenCountOutputType without action
 */
export type GuestTokenCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestTokenCountOutputType
   */
  select?: Prisma.GuestTokenCountOutputTypeSelect<ExtArgs> | null
}

/**
 * GuestTokenCountOutputType without action
 */
export type GuestTokenCountOutputTypeCountIssuesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueWhereInput
}


export type GuestTokenSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  token?: boolean
  createdAt?: boolean
  issues?: boolean | Prisma.GuestToken$issuesArgs<ExtArgs>
  _count?: boolean | Prisma.GuestTokenCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["guestToken"]>

export type GuestTokenSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  token?: boolean
  createdAt?: boolean
}, ExtArgs["result"]["guestToken"]>

export type GuestTokenSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  token?: boolean
  createdAt?: boolean
}, ExtArgs["result"]["guestToken"]>

export type GuestTokenSelectScalar = {
  id?: boolean
  token?: boolean
  createdAt?: boolean
}

export type GuestTokenOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "token" | "createdAt", ExtArgs["result"]["guestToken"]>
export type GuestTokenInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issues?: boolean | Prisma.GuestToken$issuesArgs<ExtArgs>
  _count?: boolean | Prisma.GuestTokenCountOutputTypeDefaultArgs<ExtArgs>
}
export type GuestTokenIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}
export type GuestTokenIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $GuestTokenPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "GuestToken"
  objects: {
    issues: Prisma.$IssuePayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    token: string
    createdAt: Date
  }, ExtArgs["result"]["guestToken"]>
  composites: {}
}

export type GuestTokenGetPayload<S extends boolean | null | undefined | GuestTokenDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload, S>

export type GuestTokenCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<GuestTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: GuestTokenCountAggregateInputType | true
  }

export interface GuestTokenDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GuestToken'], meta: { name: 'GuestToken' } }
  /**
   * Find zero or one GuestToken that matches the filter.
   * @param {GuestTokenFindUniqueArgs} args - Arguments to find a GuestToken
   * @example
   * // Get one GuestToken
   * const guestToken = await prisma.guestToken.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends GuestTokenFindUniqueArgs>(args: Prisma.SelectSubset<T, GuestTokenFindUniqueArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one GuestToken that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {GuestTokenFindUniqueOrThrowArgs} args - Arguments to find a GuestToken
   * @example
   * // Get one GuestToken
   * const guestToken = await prisma.guestToken.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends GuestTokenFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, GuestTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first GuestToken that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GuestTokenFindFirstArgs} args - Arguments to find a GuestToken
   * @example
   * // Get one GuestToken
   * const guestToken = await prisma.guestToken.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends GuestTokenFindFirstArgs>(args?: Prisma.SelectSubset<T, GuestTokenFindFirstArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first GuestToken that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GuestTokenFindFirstOrThrowArgs} args - Arguments to find a GuestToken
   * @example
   * // Get one GuestToken
   * const guestToken = await prisma.guestToken.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends GuestTokenFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, GuestTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more GuestTokens that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GuestTokenFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all GuestTokens
   * const guestTokens = await prisma.guestToken.findMany()
   * 
   * // Get first 10 GuestTokens
   * const guestTokens = await prisma.guestToken.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const guestTokenWithIdOnly = await prisma.guestToken.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends GuestTokenFindManyArgs>(args?: Prisma.SelectSubset<T, GuestTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a GuestToken.
   * @param {GuestTokenCreateArgs} args - Arguments to create a GuestToken.
   * @example
   * // Create one GuestToken
   * const GuestToken = await prisma.guestToken.create({
   *   data: {
   *     // ... data to create a GuestToken
   *   }
   * })
   * 
   */
  create<T extends GuestTokenCreateArgs>(args: Prisma.SelectSubset<T, GuestTokenCreateArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many GuestTokens.
   * @param {GuestTokenCreateManyArgs} args - Arguments to create many GuestTokens.
   * @example
   * // Create many GuestTokens
   * const guestToken = await prisma.guestToken.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends GuestTokenCreateManyArgs>(args?: Prisma.SelectSubset<T, GuestTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many GuestTokens and returns the data saved in the database.
   * @param {GuestTokenCreateManyAndReturnArgs} args - Arguments to create many GuestTokens.
   * @example
   * // Create many GuestTokens
   * const guestToken = await prisma.guestToken.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many GuestTokens and only return the `id`
   * const guestTokenWithIdOnly = await prisma.guestToken.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends GuestTokenCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, GuestTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a GuestToken.
   * @param {GuestTokenDeleteArgs} args - Arguments to delete one GuestToken.
   * @example
   * // Delete one GuestToken
   * const GuestToken = await prisma.guestToken.delete({
   *   where: {
   *     // ... filter to delete one GuestToken
   *   }
   * })
   * 
   */
  delete<T extends GuestTokenDeleteArgs>(args: Prisma.SelectSubset<T, GuestTokenDeleteArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one GuestToken.
   * @param {GuestTokenUpdateArgs} args - Arguments to update one GuestToken.
   * @example
   * // Update one GuestToken
   * const guestToken = await prisma.guestToken.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends GuestTokenUpdateArgs>(args: Prisma.SelectSubset<T, GuestTokenUpdateArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more GuestTokens.
   * @param {GuestTokenDeleteManyArgs} args - Arguments to filter GuestTokens to delete.
   * @example
   * // Delete a few GuestTokens
   * const { count } = await prisma.guestToken.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends GuestTokenDeleteManyArgs>(args?: Prisma.SelectSubset<T, GuestTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more GuestTokens.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GuestTokenUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many GuestTokens
   * const guestToken = await prisma.guestToken.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends GuestTokenUpdateManyArgs>(args: Prisma.SelectSubset<T, GuestTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more GuestTokens and returns the data updated in the database.
   * @param {GuestTokenUpdateManyAndReturnArgs} args - Arguments to update many GuestTokens.
   * @example
   * // Update many GuestTokens
   * const guestToken = await prisma.guestToken.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more GuestTokens and only return the `id`
   * const guestTokenWithIdOnly = await prisma.guestToken.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends GuestTokenUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, GuestTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one GuestToken.
   * @param {GuestTokenUpsertArgs} args - Arguments to update or create a GuestToken.
   * @example
   * // Update or create a GuestToken
   * const guestToken = await prisma.guestToken.upsert({
   *   create: {
   *     // ... data to create a GuestToken
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the GuestToken we want to update
   *   }
   * })
   */
  upsert<T extends GuestTokenUpsertArgs>(args: Prisma.SelectSubset<T, GuestTokenUpsertArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of GuestTokens.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GuestTokenCountArgs} args - Arguments to filter GuestTokens to count.
   * @example
   * // Count the number of GuestTokens
   * const count = await prisma.guestToken.count({
   *   where: {
   *     // ... the filter for the GuestTokens we want to count
   *   }
   * })
  **/
  count<T extends GuestTokenCountArgs>(
    args?: Prisma.Subset<T, GuestTokenCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], GuestTokenCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a GuestToken.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GuestTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends GuestTokenAggregateArgs>(args: Prisma.Subset<T, GuestTokenAggregateArgs>): Prisma.PrismaPromise<GetGuestTokenAggregateType<T>>

  /**
   * Group by GuestToken.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {GuestTokenGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends GuestTokenGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: GuestTokenGroupByArgs['orderBy'] }
      : { orderBy?: GuestTokenGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, GuestTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the GuestToken model
 */
readonly fields: GuestTokenFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for GuestToken.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__GuestTokenClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  issues<T extends Prisma.GuestToken$issuesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.GuestToken$issuesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the GuestToken model
 */
export interface GuestTokenFieldRefs {
  readonly id: Prisma.FieldRef<"GuestToken", 'Int'>
  readonly token: Prisma.FieldRef<"GuestToken", 'String'>
  readonly createdAt: Prisma.FieldRef<"GuestToken", 'DateTime'>
}
    

// Custom InputTypes
/**
 * GuestToken findUnique
 */
export type GuestTokenFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * Filter, which GuestToken to fetch.
   */
  where: Prisma.GuestTokenWhereUniqueInput
}

/**
 * GuestToken findUniqueOrThrow
 */
export type GuestTokenFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * Filter, which GuestToken to fetch.
   */
  where: Prisma.GuestTokenWhereUniqueInput
}

/**
 * GuestToken findFirst
 */
export type GuestTokenFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * Filter, which GuestToken to fetch.
   */
  where?: Prisma.GuestTokenWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GuestTokens to fetch.
   */
  orderBy?: Prisma.GuestTokenOrderByWithRelationInput | Prisma.GuestTokenOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for GuestTokens.
   */
  cursor?: Prisma.GuestTokenWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GuestTokens from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GuestTokens.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of GuestTokens.
   */
  distinct?: Prisma.GuestTokenScalarFieldEnum | Prisma.GuestTokenScalarFieldEnum[]
}

/**
 * GuestToken findFirstOrThrow
 */
export type GuestTokenFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * Filter, which GuestToken to fetch.
   */
  where?: Prisma.GuestTokenWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GuestTokens to fetch.
   */
  orderBy?: Prisma.GuestTokenOrderByWithRelationInput | Prisma.GuestTokenOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for GuestTokens.
   */
  cursor?: Prisma.GuestTokenWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GuestTokens from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GuestTokens.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of GuestTokens.
   */
  distinct?: Prisma.GuestTokenScalarFieldEnum | Prisma.GuestTokenScalarFieldEnum[]
}

/**
 * GuestToken findMany
 */
export type GuestTokenFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * Filter, which GuestTokens to fetch.
   */
  where?: Prisma.GuestTokenWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of GuestTokens to fetch.
   */
  orderBy?: Prisma.GuestTokenOrderByWithRelationInput | Prisma.GuestTokenOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing GuestTokens.
   */
  cursor?: Prisma.GuestTokenWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` GuestTokens from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` GuestTokens.
   */
  skip?: number
  distinct?: Prisma.GuestTokenScalarFieldEnum | Prisma.GuestTokenScalarFieldEnum[]
}

/**
 * GuestToken create
 */
export type GuestTokenCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * The data needed to create a GuestToken.
   */
  data: Prisma.XOR<Prisma.GuestTokenCreateInput, Prisma.GuestTokenUncheckedCreateInput>
}

/**
 * GuestToken createMany
 */
export type GuestTokenCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many GuestTokens.
   */
  data: Prisma.GuestTokenCreateManyInput | Prisma.GuestTokenCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * GuestToken createManyAndReturn
 */
export type GuestTokenCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * The data used to create many GuestTokens.
   */
  data: Prisma.GuestTokenCreateManyInput | Prisma.GuestTokenCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * GuestToken update
 */
export type GuestTokenUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * The data needed to update a GuestToken.
   */
  data: Prisma.XOR<Prisma.GuestTokenUpdateInput, Prisma.GuestTokenUncheckedUpdateInput>
  /**
   * Choose, which GuestToken to update.
   */
  where: Prisma.GuestTokenWhereUniqueInput
}

/**
 * GuestToken updateMany
 */
export type GuestTokenUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update GuestTokens.
   */
  data: Prisma.XOR<Prisma.GuestTokenUpdateManyMutationInput, Prisma.GuestTokenUncheckedUpdateManyInput>
  /**
   * Filter which GuestTokens to update
   */
  where?: Prisma.GuestTokenWhereInput
  /**
   * Limit how many GuestTokens to update.
   */
  limit?: number
}

/**
 * GuestToken updateManyAndReturn
 */
export type GuestTokenUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * The data used to update GuestTokens.
   */
  data: Prisma.XOR<Prisma.GuestTokenUpdateManyMutationInput, Prisma.GuestTokenUncheckedUpdateManyInput>
  /**
   * Filter which GuestTokens to update
   */
  where?: Prisma.GuestTokenWhereInput
  /**
   * Limit how many GuestTokens to update.
   */
  limit?: number
}

/**
 * GuestToken upsert
 */
export type GuestTokenUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * The filter to search for the GuestToken to update in case it exists.
   */
  where: Prisma.GuestTokenWhereUniqueInput
  /**
   * In case the GuestToken found by the `where` argument doesn't exist, create a new GuestToken with this data.
   */
  create: Prisma.XOR<Prisma.GuestTokenCreateInput, Prisma.GuestTokenUncheckedCreateInput>
  /**
   * In case the GuestToken was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.GuestTokenUpdateInput, Prisma.GuestTokenUncheckedUpdateInput>
}

/**
 * GuestToken delete
 */
export type GuestTokenDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  /**
   * Filter which GuestToken to delete.
   */
  where: Prisma.GuestTokenWhereUniqueInput
}

/**
 * GuestToken deleteMany
 */
export type GuestTokenDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which GuestTokens to delete
   */
  where?: Prisma.GuestTokenWhereInput
  /**
   * Limit how many GuestTokens to delete.
   */
  limit?: number
}

/**
 * GuestToken.issues
 */
export type GuestToken$issuesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  where?: Prisma.IssueWhereInput
  orderBy?: Prisma.IssueOrderByWithRelationInput | Prisma.IssueOrderByWithRelationInput[]
  cursor?: Prisma.IssueWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.IssueScalarFieldEnum | Prisma.IssueScalarFieldEnum[]
}

/**
 * GuestToken without action
 */
export type GuestTokenDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\Issue.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Issue` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Issue
 * 
 */
export type IssueModel = runtime.Types.Result.DefaultSelection<Prisma.$IssuePayload>

export type AggregateIssue = {
  _count: IssueCountAggregateOutputType | null
  _avg: IssueAvgAggregateOutputType | null
  _sum: IssueSumAggregateOutputType | null
  _min: IssueMinAggregateOutputType | null
  _max: IssueMaxAggregateOutputType | null
}

export type IssueAvgAggregateOutputType = {
  id: number | null
  severity: number | null
  userId: number | null
  guestTokenId: number | null
}

export type IssueSumAggregateOutputType = {
  id: number | null
  severity: number | null
  userId: number | null
  guestTokenId: number | null
}

export type IssueMinAggregateOutputType = {
  id: number | null
  title: string | null
  description: string | null
  status: $Enums.IssueStatus | null
  authorized: $Enums.IssueAuthorized | null
  error: $Enums.IssueError | null
  createdAt: Date | null
  updatedAt: Date | null
  severity: number | null
  imageBlobId: string | null
  userId: number | null
  guestTokenId: number | null
  issueType: $Enums.IssueType | null
}

export type IssueMaxAggregateOutputType = {
  id: number | null
  title: string | null
  description: string | null
  status: $Enums.IssueStatus | null
  authorized: $Enums.IssueAuthorized | null
  error: $Enums.IssueError | null
  createdAt: Date | null
  updatedAt: Date | null
  severity: number | null
  imageBlobId: string | null
  userId: number | null
  guestTokenId: number | null
  issueType: $Enums.IssueType | null
}

export type IssueCountAggregateOutputType = {
  id: number
  title: number
  description: number
  status: number
  authorized: number
  error: number
  createdAt: number
  updatedAt: number
  severity: number
  imageBlobId: number
  userId: number
  guestTokenId: number
  issueType: number
  _all: number
}


export type IssueAvgAggregateInputType = {
  id?: true
  severity?: true
  userId?: true
  guestTokenId?: true
}

export type IssueSumAggregateInputType = {
  id?: true
  severity?: true
  userId?: true
  guestTokenId?: true
}

export type IssueMinAggregateInputType = {
  id?: true
  title?: true
  description?: true
  status?: true
  authorized?: true
  error?: true
  createdAt?: true
  updatedAt?: true
  severity?: true
  imageBlobId?: true
  userId?: true
  guestTokenId?: true
  issueType?: true
}

export type IssueMaxAggregateInputType = {
  id?: true
  title?: true
  description?: true
  status?: true
  authorized?: true
  error?: true
  createdAt?: true
  updatedAt?: true
  severity?: true
  imageBlobId?: true
  userId?: true
  guestTokenId?: true
  issueType?: true
}

export type IssueCountAggregateInputType = {
  id?: true
  title?: true
  description?: true
  status?: true
  authorized?: true
  error?: true
  createdAt?: true
  updatedAt?: true
  severity?: true
  imageBlobId?: true
  userId?: true
  guestTokenId?: true
  issueType?: true
  _all?: true
}

export type IssueAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Issue to aggregate.
   */
  where?: Prisma.IssueWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Issues to fetch.
   */
  orderBy?: Prisma.IssueOrderByWithRelationInput | Prisma.IssueOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.IssueWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Issues from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Issues.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Issues
  **/
  _count?: true | IssueCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: IssueAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: IssueSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: IssueMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: IssueMaxAggregateInputType
}

export type GetIssueAggregateType<T extends IssueAggregateArgs> = {
      [P in keyof T & keyof AggregateIssue]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateIssue[P]>
    : Prisma.GetScalarType<T[P], AggregateIssue[P]>
}




export type IssueGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueWhereInput
  orderBy?: Prisma.IssueOrderByWithAggregationInput | Prisma.IssueOrderByWithAggregationInput[]
  by: Prisma.IssueScalarFieldEnum[] | Prisma.IssueScalarFieldEnum
  having?: Prisma.IssueScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: IssueCountAggregateInputType | true
  _avg?: IssueAvgAggregateInputType
  _sum?: IssueSumAggregateInputType
  _min?: IssueMinAggregateInputType
  _max?: IssueMaxAggregateInputType
}

export type IssueGroupByOutputType = {
  id: number
  title: string
  description: string
  status: $Enums.IssueStatus
  authorized: $Enums.IssueAuthorized
  error: $Enums.IssueError
  createdAt: Date
  updatedAt: Date
  severity: number | null
  imageBlobId: string | null
  userId: number
  guestTokenId: number | null
  issueType: $Enums.IssueType
  _count: IssueCountAggregateOutputType | null
  _avg: IssueAvgAggregateOutputType | null
  _sum: IssueSumAggregateOutputType | null
  _min: IssueMinAggregateOutputType | null
  _max: IssueMaxAggregateOutputType | null
}

type GetIssueGroupByPayload<T extends IssueGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<IssueGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof IssueGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], IssueGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], IssueGroupByOutputType[P]>
      }
    >
  >



export type IssueWhereInput = {
  AND?: Prisma.IssueWhereInput | Prisma.IssueWhereInput[]
  OR?: Prisma.IssueWhereInput[]
  NOT?: Prisma.IssueWhereInput | Prisma.IssueWhereInput[]
  id?: Prisma.IntFilter<"Issue"> | number
  title?: Prisma.StringFilter<"Issue"> | string
  description?: Prisma.StringFilter<"Issue"> | string
  status?: Prisma.EnumIssueStatusFilter<"Issue"> | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFilter<"Issue"> | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFilter<"Issue"> | $Enums.IssueError
  createdAt?: Prisma.DateTimeFilter<"Issue"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Issue"> | Date | string
  severity?: Prisma.IntNullableFilter<"Issue"> | number | null
  imageBlobId?: Prisma.StringNullableFilter<"Issue"> | string | null
  userId?: Prisma.IntFilter<"Issue"> | number
  guestTokenId?: Prisma.IntNullableFilter<"Issue"> | number | null
  issueType?: Prisma.EnumIssueTypeFilter<"Issue"> | $Enums.IssueType
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  comments?: Prisma.CommentListRelationFilter
  guestToken?: Prisma.XOR<Prisma.GuestTokenNullableScalarRelationFilter, Prisma.GuestTokenWhereInput> | null
  upvotes?: Prisma.IssueUpvoteListRelationFilter
  resolutionVotes?: Prisma.IssueResolutionVoteListRelationFilter
}

export type IssueOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  status?: Prisma.SortOrder
  authorized?: Prisma.SortOrder
  error?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  severity?: Prisma.SortOrderInput | Prisma.SortOrder
  imageBlobId?: Prisma.SortOrderInput | Prisma.SortOrder
  userId?: Prisma.SortOrder
  guestTokenId?: Prisma.SortOrderInput | Prisma.SortOrder
  issueType?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
  comments?: Prisma.CommentOrderByRelationAggregateInput
  guestToken?: Prisma.GuestTokenOrderByWithRelationInput
  upvotes?: Prisma.IssueUpvoteOrderByRelationAggregateInput
  resolutionVotes?: Prisma.IssueResolutionVoteOrderByRelationAggregateInput
}

export type IssueWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  AND?: Prisma.IssueWhereInput | Prisma.IssueWhereInput[]
  OR?: Prisma.IssueWhereInput[]
  NOT?: Prisma.IssueWhereInput | Prisma.IssueWhereInput[]
  title?: Prisma.StringFilter<"Issue"> | string
  description?: Prisma.StringFilter<"Issue"> | string
  status?: Prisma.EnumIssueStatusFilter<"Issue"> | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFilter<"Issue"> | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFilter<"Issue"> | $Enums.IssueError
  createdAt?: Prisma.DateTimeFilter<"Issue"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Issue"> | Date | string
  severity?: Prisma.IntNullableFilter<"Issue"> | number | null
  imageBlobId?: Prisma.StringNullableFilter<"Issue"> | string | null
  userId?: Prisma.IntFilter<"Issue"> | number
  guestTokenId?: Prisma.IntNullableFilter<"Issue"> | number | null
  issueType?: Prisma.EnumIssueTypeFilter<"Issue"> | $Enums.IssueType
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
  comments?: Prisma.CommentListRelationFilter
  guestToken?: Prisma.XOR<Prisma.GuestTokenNullableScalarRelationFilter, Prisma.GuestTokenWhereInput> | null
  upvotes?: Prisma.IssueUpvoteListRelationFilter
  resolutionVotes?: Prisma.IssueResolutionVoteListRelationFilter
}, "id">

export type IssueOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  status?: Prisma.SortOrder
  authorized?: Prisma.SortOrder
  error?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  severity?: Prisma.SortOrderInput | Prisma.SortOrder
  imageBlobId?: Prisma.SortOrderInput | Prisma.SortOrder
  userId?: Prisma.SortOrder
  guestTokenId?: Prisma.SortOrderInput | Prisma.SortOrder
  issueType?: Prisma.SortOrder
  _count?: Prisma.IssueCountOrderByAggregateInput
  _avg?: Prisma.IssueAvgOrderByAggregateInput
  _max?: Prisma.IssueMaxOrderByAggregateInput
  _min?: Prisma.IssueMinOrderByAggregateInput
  _sum?: Prisma.IssueSumOrderByAggregateInput
}

export type IssueScalarWhereWithAggregatesInput = {
  AND?: Prisma.IssueScalarWhereWithAggregatesInput | Prisma.IssueScalarWhereWithAggregatesInput[]
  OR?: Prisma.IssueScalarWhereWithAggregatesInput[]
  NOT?: Prisma.IssueScalarWhereWithAggregatesInput | Prisma.IssueScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"Issue"> | number
  title?: Prisma.StringWithAggregatesFilter<"Issue"> | string
  description?: Prisma.StringWithAggregatesFilter<"Issue"> | string
  status?: Prisma.EnumIssueStatusWithAggregatesFilter<"Issue"> | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedWithAggregatesFilter<"Issue"> | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorWithAggregatesFilter<"Issue"> | $Enums.IssueError
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Issue"> | Date | string
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Issue"> | Date | string
  severity?: Prisma.IntNullableWithAggregatesFilter<"Issue"> | number | null
  imageBlobId?: Prisma.StringNullableWithAggregatesFilter<"Issue"> | string | null
  userId?: Prisma.IntWithAggregatesFilter<"Issue"> | number
  guestTokenId?: Prisma.IntNullableWithAggregatesFilter<"Issue"> | number | null
  issueType?: Prisma.EnumIssueTypeWithAggregatesFilter<"Issue"> | $Enums.IssueType
}

export type IssueCreateInput = {
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  issueType: $Enums.IssueType
  user: Prisma.UserCreateNestedOneWithoutIssuesInput
  comments?: Prisma.CommentCreateNestedManyWithoutIssueInput
  guestToken?: Prisma.GuestTokenCreateNestedOneWithoutIssuesInput
  upvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutIssueInput
}

export type IssueUncheckedCreateInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  userId: number
  guestTokenId?: number | null
  issueType: $Enums.IssueType
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutIssueInput
  upvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutIssueInput
}

export type IssueUpdateInput = {
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  user?: Prisma.UserUpdateOneRequiredWithoutIssuesNestedInput
  comments?: Prisma.CommentUpdateManyWithoutIssueNestedInput
  guestToken?: Prisma.GuestTokenUpdateOneWithoutIssuesNestedInput
  upvotes?: Prisma.IssueUpvoteUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutIssueNestedInput
}

export type IssueUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  guestTokenId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  comments?: Prisma.CommentUncheckedUpdateManyWithoutIssueNestedInput
  upvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutIssueNestedInput
}

export type IssueCreateManyInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  userId: number
  guestTokenId?: number | null
  issueType: $Enums.IssueType
}

export type IssueUpdateManyMutationInput = {
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
}

export type IssueUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  guestTokenId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
}

export type IssueListRelationFilter = {
  every?: Prisma.IssueWhereInput
  some?: Prisma.IssueWhereInput
  none?: Prisma.IssueWhereInput
}

export type IssueOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type IssueCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  status?: Prisma.SortOrder
  authorized?: Prisma.SortOrder
  error?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  severity?: Prisma.SortOrder
  imageBlobId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  guestTokenId?: Prisma.SortOrder
  issueType?: Prisma.SortOrder
}

export type IssueAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  severity?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  guestTokenId?: Prisma.SortOrder
}

export type IssueMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  status?: Prisma.SortOrder
  authorized?: Prisma.SortOrder
  error?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  severity?: Prisma.SortOrder
  imageBlobId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  guestTokenId?: Prisma.SortOrder
  issueType?: Prisma.SortOrder
}

export type IssueMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  title?: Prisma.SortOrder
  description?: Prisma.SortOrder
  status?: Prisma.SortOrder
  authorized?: Prisma.SortOrder
  error?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  updatedAt?: Prisma.SortOrder
  severity?: Prisma.SortOrder
  imageBlobId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  guestTokenId?: Prisma.SortOrder
  issueType?: Prisma.SortOrder
}

export type IssueSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  severity?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  guestTokenId?: Prisma.SortOrder
}

export type IssueScalarRelationFilter = {
  is?: Prisma.IssueWhereInput
  isNot?: Prisma.IssueWhereInput
}

export type IssueCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutUserInput, Prisma.IssueUncheckedCreateWithoutUserInput> | Prisma.IssueCreateWithoutUserInput[] | Prisma.IssueUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutUserInput | Prisma.IssueCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.IssueCreateManyUserInputEnvelope
  connect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
}

export type IssueUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutUserInput, Prisma.IssueUncheckedCreateWithoutUserInput> | Prisma.IssueCreateWithoutUserInput[] | Prisma.IssueUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutUserInput | Prisma.IssueCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.IssueCreateManyUserInputEnvelope
  connect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
}

export type IssueUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutUserInput, Prisma.IssueUncheckedCreateWithoutUserInput> | Prisma.IssueCreateWithoutUserInput[] | Prisma.IssueUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutUserInput | Prisma.IssueCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.IssueUpsertWithWhereUniqueWithoutUserInput | Prisma.IssueUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.IssueCreateManyUserInputEnvelope
  set?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  disconnect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  delete?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  connect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  update?: Prisma.IssueUpdateWithWhereUniqueWithoutUserInput | Prisma.IssueUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.IssueUpdateManyWithWhereWithoutUserInput | Prisma.IssueUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.IssueScalarWhereInput | Prisma.IssueScalarWhereInput[]
}

export type IssueUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutUserInput, Prisma.IssueUncheckedCreateWithoutUserInput> | Prisma.IssueCreateWithoutUserInput[] | Prisma.IssueUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutUserInput | Prisma.IssueCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.IssueUpsertWithWhereUniqueWithoutUserInput | Prisma.IssueUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.IssueCreateManyUserInputEnvelope
  set?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  disconnect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  delete?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  connect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  update?: Prisma.IssueUpdateWithWhereUniqueWithoutUserInput | Prisma.IssueUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.IssueUpdateManyWithWhereWithoutUserInput | Prisma.IssueUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.IssueScalarWhereInput | Prisma.IssueScalarWhereInput[]
}

export type IssueCreateNestedManyWithoutGuestTokenInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutGuestTokenInput, Prisma.IssueUncheckedCreateWithoutGuestTokenInput> | Prisma.IssueCreateWithoutGuestTokenInput[] | Prisma.IssueUncheckedCreateWithoutGuestTokenInput[]
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutGuestTokenInput | Prisma.IssueCreateOrConnectWithoutGuestTokenInput[]
  createMany?: Prisma.IssueCreateManyGuestTokenInputEnvelope
  connect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
}

export type IssueUncheckedCreateNestedManyWithoutGuestTokenInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutGuestTokenInput, Prisma.IssueUncheckedCreateWithoutGuestTokenInput> | Prisma.IssueCreateWithoutGuestTokenInput[] | Prisma.IssueUncheckedCreateWithoutGuestTokenInput[]
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutGuestTokenInput | Prisma.IssueCreateOrConnectWithoutGuestTokenInput[]
  createMany?: Prisma.IssueCreateManyGuestTokenInputEnvelope
  connect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
}

export type IssueUpdateManyWithoutGuestTokenNestedInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutGuestTokenInput, Prisma.IssueUncheckedCreateWithoutGuestTokenInput> | Prisma.IssueCreateWithoutGuestTokenInput[] | Prisma.IssueUncheckedCreateWithoutGuestTokenInput[]
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutGuestTokenInput | Prisma.IssueCreateOrConnectWithoutGuestTokenInput[]
  upsert?: Prisma.IssueUpsertWithWhereUniqueWithoutGuestTokenInput | Prisma.IssueUpsertWithWhereUniqueWithoutGuestTokenInput[]
  createMany?: Prisma.IssueCreateManyGuestTokenInputEnvelope
  set?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  disconnect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  delete?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  connect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  update?: Prisma.IssueUpdateWithWhereUniqueWithoutGuestTokenInput | Prisma.IssueUpdateWithWhereUniqueWithoutGuestTokenInput[]
  updateMany?: Prisma.IssueUpdateManyWithWhereWithoutGuestTokenInput | Prisma.IssueUpdateManyWithWhereWithoutGuestTokenInput[]
  deleteMany?: Prisma.IssueScalarWhereInput | Prisma.IssueScalarWhereInput[]
}

export type IssueUncheckedUpdateManyWithoutGuestTokenNestedInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutGuestTokenInput, Prisma.IssueUncheckedCreateWithoutGuestTokenInput> | Prisma.IssueCreateWithoutGuestTokenInput[] | Prisma.IssueUncheckedCreateWithoutGuestTokenInput[]
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutGuestTokenInput | Prisma.IssueCreateOrConnectWithoutGuestTokenInput[]
  upsert?: Prisma.IssueUpsertWithWhereUniqueWithoutGuestTokenInput | Prisma.IssueUpsertWithWhereUniqueWithoutGuestTokenInput[]
  createMany?: Prisma.IssueCreateManyGuestTokenInputEnvelope
  set?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  disconnect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  delete?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  connect?: Prisma.IssueWhereUniqueInput | Prisma.IssueWhereUniqueInput[]
  update?: Prisma.IssueUpdateWithWhereUniqueWithoutGuestTokenInput | Prisma.IssueUpdateWithWhereUniqueWithoutGuestTokenInput[]
  updateMany?: Prisma.IssueUpdateManyWithWhereWithoutGuestTokenInput | Prisma.IssueUpdateManyWithWhereWithoutGuestTokenInput[]
  deleteMany?: Prisma.IssueScalarWhereInput | Prisma.IssueScalarWhereInput[]
}

export type EnumIssueStatusFieldUpdateOperationsInput = {
  set?: $Enums.IssueStatus
}

export type EnumIssueAuthorizedFieldUpdateOperationsInput = {
  set?: $Enums.IssueAuthorized
}

export type EnumIssueErrorFieldUpdateOperationsInput = {
  set?: $Enums.IssueError
}

export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type EnumIssueTypeFieldUpdateOperationsInput = {
  set?: $Enums.IssueType
}

export type IssueCreateNestedOneWithoutUpvotesInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutUpvotesInput, Prisma.IssueUncheckedCreateWithoutUpvotesInput>
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutUpvotesInput
  connect?: Prisma.IssueWhereUniqueInput
}

export type IssueUpdateOneRequiredWithoutUpvotesNestedInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutUpvotesInput, Prisma.IssueUncheckedCreateWithoutUpvotesInput>
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutUpvotesInput
  upsert?: Prisma.IssueUpsertWithoutUpvotesInput
  connect?: Prisma.IssueWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.IssueUpdateToOneWithWhereWithoutUpvotesInput, Prisma.IssueUpdateWithoutUpvotesInput>, Prisma.IssueUncheckedUpdateWithoutUpvotesInput>
}

export type IssueCreateNestedOneWithoutResolutionVotesInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutResolutionVotesInput, Prisma.IssueUncheckedCreateWithoutResolutionVotesInput>
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutResolutionVotesInput
  connect?: Prisma.IssueWhereUniqueInput
}

export type IssueUpdateOneRequiredWithoutResolutionVotesNestedInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutResolutionVotesInput, Prisma.IssueUncheckedCreateWithoutResolutionVotesInput>
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutResolutionVotesInput
  upsert?: Prisma.IssueUpsertWithoutResolutionVotesInput
  connect?: Prisma.IssueWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.IssueUpdateToOneWithWhereWithoutResolutionVotesInput, Prisma.IssueUpdateWithoutResolutionVotesInput>, Prisma.IssueUncheckedUpdateWithoutResolutionVotesInput>
}

export type IssueCreateNestedOneWithoutCommentsInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutCommentsInput, Prisma.IssueUncheckedCreateWithoutCommentsInput>
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutCommentsInput
  connect?: Prisma.IssueWhereUniqueInput
}

export type IssueUpdateOneRequiredWithoutCommentsNestedInput = {
  create?: Prisma.XOR<Prisma.IssueCreateWithoutCommentsInput, Prisma.IssueUncheckedCreateWithoutCommentsInput>
  connectOrCreate?: Prisma.IssueCreateOrConnectWithoutCommentsInput
  upsert?: Prisma.IssueUpsertWithoutCommentsInput
  connect?: Prisma.IssueWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.IssueUpdateToOneWithWhereWithoutCommentsInput, Prisma.IssueUpdateWithoutCommentsInput>, Prisma.IssueUncheckedUpdateWithoutCommentsInput>
}

export type IssueCreateWithoutUserInput = {
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  issueType: $Enums.IssueType
  comments?: Prisma.CommentCreateNestedManyWithoutIssueInput
  guestToken?: Prisma.GuestTokenCreateNestedOneWithoutIssuesInput
  upvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutIssueInput
}

export type IssueUncheckedCreateWithoutUserInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  guestTokenId?: number | null
  issueType: $Enums.IssueType
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutIssueInput
  upvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutIssueInput
}

export type IssueCreateOrConnectWithoutUserInput = {
  where: Prisma.IssueWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueCreateWithoutUserInput, Prisma.IssueUncheckedCreateWithoutUserInput>
}

export type IssueCreateManyUserInputEnvelope = {
  data: Prisma.IssueCreateManyUserInput | Prisma.IssueCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type IssueUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.IssueWhereUniqueInput
  update: Prisma.XOR<Prisma.IssueUpdateWithoutUserInput, Prisma.IssueUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.IssueCreateWithoutUserInput, Prisma.IssueUncheckedCreateWithoutUserInput>
}

export type IssueUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.IssueWhereUniqueInput
  data: Prisma.XOR<Prisma.IssueUpdateWithoutUserInput, Prisma.IssueUncheckedUpdateWithoutUserInput>
}

export type IssueUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.IssueScalarWhereInput
  data: Prisma.XOR<Prisma.IssueUpdateManyMutationInput, Prisma.IssueUncheckedUpdateManyWithoutUserInput>
}

export type IssueScalarWhereInput = {
  AND?: Prisma.IssueScalarWhereInput | Prisma.IssueScalarWhereInput[]
  OR?: Prisma.IssueScalarWhereInput[]
  NOT?: Prisma.IssueScalarWhereInput | Prisma.IssueScalarWhereInput[]
  id?: Prisma.IntFilter<"Issue"> | number
  title?: Prisma.StringFilter<"Issue"> | string
  description?: Prisma.StringFilter<"Issue"> | string
  status?: Prisma.EnumIssueStatusFilter<"Issue"> | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFilter<"Issue"> | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFilter<"Issue"> | $Enums.IssueError
  createdAt?: Prisma.DateTimeFilter<"Issue"> | Date | string
  updatedAt?: Prisma.DateTimeFilter<"Issue"> | Date | string
  severity?: Prisma.IntNullableFilter<"Issue"> | number | null
  imageBlobId?: Prisma.StringNullableFilter<"Issue"> | string | null
  userId?: Prisma.IntFilter<"Issue"> | number
  guestTokenId?: Prisma.IntNullableFilter<"Issue"> | number | null
  issueType?: Prisma.EnumIssueTypeFilter<"Issue"> | $Enums.IssueType
}

export type IssueCreateWithoutGuestTokenInput = {
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  issueType: $Enums.IssueType
  user: Prisma.UserCreateNestedOneWithoutIssuesInput
  comments?: Prisma.CommentCreateNestedManyWithoutIssueInput
  upvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutIssueInput
}

export type IssueUncheckedCreateWithoutGuestTokenInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  userId: number
  issueType: $Enums.IssueType
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutIssueInput
  upvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutIssueInput
}

export type IssueCreateOrConnectWithoutGuestTokenInput = {
  where: Prisma.IssueWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueCreateWithoutGuestTokenInput, Prisma.IssueUncheckedCreateWithoutGuestTokenInput>
}

export type IssueCreateManyGuestTokenInputEnvelope = {
  data: Prisma.IssueCreateManyGuestTokenInput | Prisma.IssueCreateManyGuestTokenInput[]
  skipDuplicates?: boolean
}

export type IssueUpsertWithWhereUniqueWithoutGuestTokenInput = {
  where: Prisma.IssueWhereUniqueInput
  update: Prisma.XOR<Prisma.IssueUpdateWithoutGuestTokenInput, Prisma.IssueUncheckedUpdateWithoutGuestTokenInput>
  create: Prisma.XOR<Prisma.IssueCreateWithoutGuestTokenInput, Prisma.IssueUncheckedCreateWithoutGuestTokenInput>
}

export type IssueUpdateWithWhereUniqueWithoutGuestTokenInput = {
  where: Prisma.IssueWhereUniqueInput
  data: Prisma.XOR<Prisma.IssueUpdateWithoutGuestTokenInput, Prisma.IssueUncheckedUpdateWithoutGuestTokenInput>
}

export type IssueUpdateManyWithWhereWithoutGuestTokenInput = {
  where: Prisma.IssueScalarWhereInput
  data: Prisma.XOR<Prisma.IssueUpdateManyMutationInput, Prisma.IssueUncheckedUpdateManyWithoutGuestTokenInput>
}

export type IssueCreateWithoutUpvotesInput = {
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  issueType: $Enums.IssueType
  user: Prisma.UserCreateNestedOneWithoutIssuesInput
  comments?: Prisma.CommentCreateNestedManyWithoutIssueInput
  guestToken?: Prisma.GuestTokenCreateNestedOneWithoutIssuesInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutIssueInput
}

export type IssueUncheckedCreateWithoutUpvotesInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  userId: number
  guestTokenId?: number | null
  issueType: $Enums.IssueType
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutIssueInput
}

export type IssueCreateOrConnectWithoutUpvotesInput = {
  where: Prisma.IssueWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueCreateWithoutUpvotesInput, Prisma.IssueUncheckedCreateWithoutUpvotesInput>
}

export type IssueUpsertWithoutUpvotesInput = {
  update: Prisma.XOR<Prisma.IssueUpdateWithoutUpvotesInput, Prisma.IssueUncheckedUpdateWithoutUpvotesInput>
  create: Prisma.XOR<Prisma.IssueCreateWithoutUpvotesInput, Prisma.IssueUncheckedCreateWithoutUpvotesInput>
  where?: Prisma.IssueWhereInput
}

export type IssueUpdateToOneWithWhereWithoutUpvotesInput = {
  where?: Prisma.IssueWhereInput
  data: Prisma.XOR<Prisma.IssueUpdateWithoutUpvotesInput, Prisma.IssueUncheckedUpdateWithoutUpvotesInput>
}

export type IssueUpdateWithoutUpvotesInput = {
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  user?: Prisma.UserUpdateOneRequiredWithoutIssuesNestedInput
  comments?: Prisma.CommentUpdateManyWithoutIssueNestedInput
  guestToken?: Prisma.GuestTokenUpdateOneWithoutIssuesNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutIssueNestedInput
}

export type IssueUncheckedUpdateWithoutUpvotesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  guestTokenId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  comments?: Prisma.CommentUncheckedUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutIssueNestedInput
}

export type IssueCreateWithoutResolutionVotesInput = {
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  issueType: $Enums.IssueType
  user: Prisma.UserCreateNestedOneWithoutIssuesInput
  comments?: Prisma.CommentCreateNestedManyWithoutIssueInput
  guestToken?: Prisma.GuestTokenCreateNestedOneWithoutIssuesInput
  upvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutIssueInput
}

export type IssueUncheckedCreateWithoutResolutionVotesInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  userId: number
  guestTokenId?: number | null
  issueType: $Enums.IssueType
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutIssueInput
  upvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutIssueInput
}

export type IssueCreateOrConnectWithoutResolutionVotesInput = {
  where: Prisma.IssueWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueCreateWithoutResolutionVotesInput, Prisma.IssueUncheckedCreateWithoutResolutionVotesInput>
}

export type IssueUpsertWithoutResolutionVotesInput = {
  update: Prisma.XOR<Prisma.IssueUpdateWithoutResolutionVotesInput, Prisma.IssueUncheckedUpdateWithoutResolutionVotesInput>
  create: Prisma.XOR<Prisma.IssueCreateWithoutResolutionVotesInput, Prisma.IssueUncheckedCreateWithoutResolutionVotesInput>
  where?: Prisma.IssueWhereInput
}

export type IssueUpdateToOneWithWhereWithoutResolutionVotesInput = {
  where?: Prisma.IssueWhereInput
  data: Prisma.XOR<Prisma.IssueUpdateWithoutResolutionVotesInput, Prisma.IssueUncheckedUpdateWithoutResolutionVotesInput>
}

export type IssueUpdateWithoutResolutionVotesInput = {
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  user?: Prisma.UserUpdateOneRequiredWithoutIssuesNestedInput
  comments?: Prisma.CommentUpdateManyWithoutIssueNestedInput
  guestToken?: Prisma.GuestTokenUpdateOneWithoutIssuesNestedInput
  upvotes?: Prisma.IssueUpvoteUpdateManyWithoutIssueNestedInput
}

export type IssueUncheckedUpdateWithoutResolutionVotesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  guestTokenId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  comments?: Prisma.CommentUncheckedUpdateManyWithoutIssueNestedInput
  upvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutIssueNestedInput
}

export type IssueCreateWithoutCommentsInput = {
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  issueType: $Enums.IssueType
  user: Prisma.UserCreateNestedOneWithoutIssuesInput
  guestToken?: Prisma.GuestTokenCreateNestedOneWithoutIssuesInput
  upvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutIssueInput
}

export type IssueUncheckedCreateWithoutCommentsInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  userId: number
  guestTokenId?: number | null
  issueType: $Enums.IssueType
  upvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutIssueInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutIssueInput
}

export type IssueCreateOrConnectWithoutCommentsInput = {
  where: Prisma.IssueWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueCreateWithoutCommentsInput, Prisma.IssueUncheckedCreateWithoutCommentsInput>
}

export type IssueUpsertWithoutCommentsInput = {
  update: Prisma.XOR<Prisma.IssueUpdateWithoutCommentsInput, Prisma.IssueUncheckedUpdateWithoutCommentsInput>
  create: Prisma.XOR<Prisma.IssueCreateWithoutCommentsInput, Prisma.IssueUncheckedCreateWithoutCommentsInput>
  where?: Prisma.IssueWhereInput
}

export type IssueUpdateToOneWithWhereWithoutCommentsInput = {
  where?: Prisma.IssueWhereInput
  data: Prisma.XOR<Prisma.IssueUpdateWithoutCommentsInput, Prisma.IssueUncheckedUpdateWithoutCommentsInput>
}

export type IssueUpdateWithoutCommentsInput = {
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  user?: Prisma.UserUpdateOneRequiredWithoutIssuesNestedInput
  guestToken?: Prisma.GuestTokenUpdateOneWithoutIssuesNestedInput
  upvotes?: Prisma.IssueUpvoteUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutIssueNestedInput
}

export type IssueUncheckedUpdateWithoutCommentsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  guestTokenId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  upvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutIssueNestedInput
}

export type IssueCreateManyUserInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  guestTokenId?: number | null
  issueType: $Enums.IssueType
}

export type IssueUpdateWithoutUserInput = {
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  comments?: Prisma.CommentUpdateManyWithoutIssueNestedInput
  guestToken?: Prisma.GuestTokenUpdateOneWithoutIssuesNestedInput
  upvotes?: Prisma.IssueUpvoteUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutIssueNestedInput
}

export type IssueUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  guestTokenId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  comments?: Prisma.CommentUncheckedUpdateManyWithoutIssueNestedInput
  upvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutIssueNestedInput
}

export type IssueUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  guestTokenId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
}

export type IssueCreateManyGuestTokenInput = {
  id?: number
  title: string
  description: string
  status?: $Enums.IssueStatus
  authorized?: $Enums.IssueAuthorized
  error?: $Enums.IssueError
  createdAt?: Date | string
  updatedAt?: Date | string
  severity?: number | null
  imageBlobId?: string | null
  userId: number
  issueType: $Enums.IssueType
}

export type IssueUpdateWithoutGuestTokenInput = {
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  user?: Prisma.UserUpdateOneRequiredWithoutIssuesNestedInput
  comments?: Prisma.CommentUpdateManyWithoutIssueNestedInput
  upvotes?: Prisma.IssueUpvoteUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutIssueNestedInput
}

export type IssueUncheckedUpdateWithoutGuestTokenInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
  comments?: Prisma.CommentUncheckedUpdateManyWithoutIssueNestedInput
  upvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutIssueNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutIssueNestedInput
}

export type IssueUncheckedUpdateManyWithoutGuestTokenInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  title?: Prisma.StringFieldUpdateOperationsInput | string
  description?: Prisma.StringFieldUpdateOperationsInput | string
  status?: Prisma.EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
  authorized?: Prisma.EnumIssueAuthorizedFieldUpdateOperationsInput | $Enums.IssueAuthorized
  error?: Prisma.EnumIssueErrorFieldUpdateOperationsInput | $Enums.IssueError
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  severity?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
  imageBlobId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  userId?: Prisma.IntFieldUpdateOperationsInput | number
  issueType?: Prisma.EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType
}


/**
 * Count Type IssueCountOutputType
 */

export type IssueCountOutputType = {
  comments: number
  upvotes: number
  resolutionVotes: number
}

export type IssueCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  comments?: boolean | IssueCountOutputTypeCountCommentsArgs
  upvotes?: boolean | IssueCountOutputTypeCountUpvotesArgs
  resolutionVotes?: boolean | IssueCountOutputTypeCountResolutionVotesArgs
}

/**
 * IssueCountOutputType without action
 */
export type IssueCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueCountOutputType
   */
  select?: Prisma.IssueCountOutputTypeSelect<ExtArgs> | null
}

/**
 * IssueCountOutputType without action
 */
export type IssueCountOutputTypeCountCommentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommentWhereInput
}

/**
 * IssueCountOutputType without action
 */
export type IssueCountOutputTypeCountUpvotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueUpvoteWhereInput
}

/**
 * IssueCountOutputType without action
 */
export type IssueCountOutputTypeCountResolutionVotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueResolutionVoteWhereInput
}


export type IssueSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  title?: boolean
  description?: boolean
  status?: boolean
  authorized?: boolean
  error?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  severity?: boolean
  imageBlobId?: boolean
  userId?: boolean
  guestTokenId?: boolean
  issueType?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  comments?: boolean | Prisma.Issue$commentsArgs<ExtArgs>
  guestToken?: boolean | Prisma.Issue$guestTokenArgs<ExtArgs>
  upvotes?: boolean | Prisma.Issue$upvotesArgs<ExtArgs>
  resolutionVotes?: boolean | Prisma.Issue$resolutionVotesArgs<ExtArgs>
  _count?: boolean | Prisma.IssueCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["issue"]>

export type IssueSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  title?: boolean
  description?: boolean
  status?: boolean
  authorized?: boolean
  error?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  severity?: boolean
  imageBlobId?: boolean
  userId?: boolean
  guestTokenId?: boolean
  issueType?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  guestToken?: boolean | Prisma.Issue$guestTokenArgs<ExtArgs>
}, ExtArgs["result"]["issue"]>

export type IssueSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  title?: boolean
  description?: boolean
  status?: boolean
  authorized?: boolean
  error?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  severity?: boolean
  imageBlobId?: boolean
  userId?: boolean
  guestTokenId?: boolean
  issueType?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  guestToken?: boolean | Prisma.Issue$guestTokenArgs<ExtArgs>
}, ExtArgs["result"]["issue"]>

export type IssueSelectScalar = {
  id?: boolean
  title?: boolean
  description?: boolean
  status?: boolean
  authorized?: boolean
  error?: boolean
  createdAt?: boolean
  updatedAt?: boolean
  severity?: boolean
  imageBlobId?: boolean
  userId?: boolean
  guestTokenId?: boolean
  issueType?: boolean
}

export type IssueOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "title" | "description" | "status" | "authorized" | "error" | "createdAt" | "updatedAt" | "severity" | "imageBlobId" | "userId" | "guestTokenId" | "issueType", ExtArgs["result"]["issue"]>
export type IssueInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  comments?: boolean | Prisma.Issue$commentsArgs<ExtArgs>
  guestToken?: boolean | Prisma.Issue$guestTokenArgs<ExtArgs>
  upvotes?: boolean | Prisma.Issue$upvotesArgs<ExtArgs>
  resolutionVotes?: boolean | Prisma.Issue$resolutionVotesArgs<ExtArgs>
  _count?: boolean | Prisma.IssueCountOutputTypeDefaultArgs<ExtArgs>
}
export type IssueIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  guestToken?: boolean | Prisma.Issue$guestTokenArgs<ExtArgs>
}
export type IssueIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
  guestToken?: boolean | Prisma.Issue$guestTokenArgs<ExtArgs>
}

export type $IssuePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Issue"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
    comments: Prisma.$CommentPayload<ExtArgs>[]
    guestToken: Prisma.$GuestTokenPayload<ExtArgs> | null
    upvotes: Prisma.$IssueUpvotePayload<ExtArgs>[]
    resolutionVotes: Prisma.$IssueResolutionVotePayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    title: string
    description: string
    status: $Enums.IssueStatus
    authorized: $Enums.IssueAuthorized
    error: $Enums.IssueError
    createdAt: Date
    updatedAt: Date
    severity: number | null
    imageBlobId: string | null
    userId: number
    guestTokenId: number | null
    issueType: $Enums.IssueType
  }, ExtArgs["result"]["issue"]>
  composites: {}
}

export type IssueGetPayload<S extends boolean | null | undefined | IssueDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$IssuePayload, S>

export type IssueCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<IssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: IssueCountAggregateInputType | true
  }

export interface IssueDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Issue'], meta: { name: 'Issue' } }
  /**
   * Find zero or one Issue that matches the filter.
   * @param {IssueFindUniqueArgs} args - Arguments to find a Issue
   * @example
   * // Get one Issue
   * const issue = await prisma.issue.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends IssueFindUniqueArgs>(args: Prisma.SelectSubset<T, IssueFindUniqueArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Issue that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {IssueFindUniqueOrThrowArgs} args - Arguments to find a Issue
   * @example
   * // Get one Issue
   * const issue = await prisma.issue.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends IssueFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, IssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Issue that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueFindFirstArgs} args - Arguments to find a Issue
   * @example
   * // Get one Issue
   * const issue = await prisma.issue.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends IssueFindFirstArgs>(args?: Prisma.SelectSubset<T, IssueFindFirstArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Issue that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueFindFirstOrThrowArgs} args - Arguments to find a Issue
   * @example
   * // Get one Issue
   * const issue = await prisma.issue.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends IssueFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, IssueFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Issues that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Issues
   * const issues = await prisma.issue.findMany()
   * 
   * // Get first 10 Issues
   * const issues = await prisma.issue.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const issueWithIdOnly = await prisma.issue.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends IssueFindManyArgs>(args?: Prisma.SelectSubset<T, IssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Issue.
   * @param {IssueCreateArgs} args - Arguments to create a Issue.
   * @example
   * // Create one Issue
   * const Issue = await prisma.issue.create({
   *   data: {
   *     // ... data to create a Issue
   *   }
   * })
   * 
   */
  create<T extends IssueCreateArgs>(args: Prisma.SelectSubset<T, IssueCreateArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Issues.
   * @param {IssueCreateManyArgs} args - Arguments to create many Issues.
   * @example
   * // Create many Issues
   * const issue = await prisma.issue.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends IssueCreateManyArgs>(args?: Prisma.SelectSubset<T, IssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Issues and returns the data saved in the database.
   * @param {IssueCreateManyAndReturnArgs} args - Arguments to create many Issues.
   * @example
   * // Create many Issues
   * const issue = await prisma.issue.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Issues and only return the `id`
   * const issueWithIdOnly = await prisma.issue.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends IssueCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, IssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Issue.
   * @param {IssueDeleteArgs} args - Arguments to delete one Issue.
   * @example
   * // Delete one Issue
   * const Issue = await prisma.issue.delete({
   *   where: {
   *     // ... filter to delete one Issue
   *   }
   * })
   * 
   */
  delete<T extends IssueDeleteArgs>(args: Prisma.SelectSubset<T, IssueDeleteArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Issue.
   * @param {IssueUpdateArgs} args - Arguments to update one Issue.
   * @example
   * // Update one Issue
   * const issue = await prisma.issue.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends IssueUpdateArgs>(args: Prisma.SelectSubset<T, IssueUpdateArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Issues.
   * @param {IssueDeleteManyArgs} args - Arguments to filter Issues to delete.
   * @example
   * // Delete a few Issues
   * const { count } = await prisma.issue.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends IssueDeleteManyArgs>(args?: Prisma.SelectSubset<T, IssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Issues.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Issues
   * const issue = await prisma.issue.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends IssueUpdateManyArgs>(args: Prisma.SelectSubset<T, IssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Issues and returns the data updated in the database.
   * @param {IssueUpdateManyAndReturnArgs} args - Arguments to update many Issues.
   * @example
   * // Update many Issues
   * const issue = await prisma.issue.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Issues and only return the `id`
   * const issueWithIdOnly = await prisma.issue.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends IssueUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, IssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Issue.
   * @param {IssueUpsertArgs} args - Arguments to update or create a Issue.
   * @example
   * // Update or create a Issue
   * const issue = await prisma.issue.upsert({
   *   create: {
   *     // ... data to create a Issue
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Issue we want to update
   *   }
   * })
   */
  upsert<T extends IssueUpsertArgs>(args: Prisma.SelectSubset<T, IssueUpsertArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Issues.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueCountArgs} args - Arguments to filter Issues to count.
   * @example
   * // Count the number of Issues
   * const count = await prisma.issue.count({
   *   where: {
   *     // ... the filter for the Issues we want to count
   *   }
   * })
  **/
  count<T extends IssueCountArgs>(
    args?: Prisma.Subset<T, IssueCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], IssueCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Issue.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends IssueAggregateArgs>(args: Prisma.Subset<T, IssueAggregateArgs>): Prisma.PrismaPromise<GetIssueAggregateType<T>>

  /**
   * Group by Issue.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends IssueGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: IssueGroupByArgs['orderBy'] }
      : { orderBy?: IssueGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, IssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Issue model
 */
readonly fields: IssueFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Issue.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__IssueClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  comments<T extends Prisma.Issue$commentsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Issue$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  guestToken<T extends Prisma.Issue$guestTokenArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Issue$guestTokenArgs<ExtArgs>>): Prisma.Prisma__GuestTokenClient<runtime.Types.Result.GetResult<Prisma.$GuestTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  upvotes<T extends Prisma.Issue$upvotesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Issue$upvotesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  resolutionVotes<T extends Prisma.Issue$resolutionVotesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Issue$resolutionVotesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Issue model
 */
export interface IssueFieldRefs {
  readonly id: Prisma.FieldRef<"Issue", 'Int'>
  readonly title: Prisma.FieldRef<"Issue", 'String'>
  readonly description: Prisma.FieldRef<"Issue", 'String'>
  readonly status: Prisma.FieldRef<"Issue", 'IssueStatus'>
  readonly authorized: Prisma.FieldRef<"Issue", 'IssueAuthorized'>
  readonly error: Prisma.FieldRef<"Issue", 'IssueError'>
  readonly createdAt: Prisma.FieldRef<"Issue", 'DateTime'>
  readonly updatedAt: Prisma.FieldRef<"Issue", 'DateTime'>
  readonly severity: Prisma.FieldRef<"Issue", 'Int'>
  readonly imageBlobId: Prisma.FieldRef<"Issue", 'String'>
  readonly userId: Prisma.FieldRef<"Issue", 'Int'>
  readonly guestTokenId: Prisma.FieldRef<"Issue", 'Int'>
  readonly issueType: Prisma.FieldRef<"Issue", 'IssueType'>
}
    

// Custom InputTypes
/**
 * Issue findUnique
 */
export type IssueFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * Filter, which Issue to fetch.
   */
  where: Prisma.IssueWhereUniqueInput
}

/**
 * Issue findUniqueOrThrow
 */
export type IssueFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * Filter, which Issue to fetch.
   */
  where: Prisma.IssueWhereUniqueInput
}

/**
 * Issue findFirst
 */
export type IssueFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * Filter, which Issue to fetch.
   */
  where?: Prisma.IssueWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Issues to fetch.
   */
  orderBy?: Prisma.IssueOrderByWithRelationInput | Prisma.IssueOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Issues.
   */
  cursor?: Prisma.IssueWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Issues from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Issues.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Issues.
   */
  distinct?: Prisma.IssueScalarFieldEnum | Prisma.IssueScalarFieldEnum[]
}

/**
 * Issue findFirstOrThrow
 */
export type IssueFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * Filter, which Issue to fetch.
   */
  where?: Prisma.IssueWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Issues to fetch.
   */
  orderBy?: Prisma.IssueOrderByWithRelationInput | Prisma.IssueOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Issues.
   */
  cursor?: Prisma.IssueWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Issues from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Issues.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Issues.
   */
  distinct?: Prisma.IssueScalarFieldEnum | Prisma.IssueScalarFieldEnum[]
}

/**
 * Issue findMany
 */
export type IssueFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * Filter, which Issues to fetch.
   */
  where?: Prisma.IssueWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Issues to fetch.
   */
  orderBy?: Prisma.IssueOrderByWithRelationInput | Prisma.IssueOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Issues.
   */
  cursor?: Prisma.IssueWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Issues from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Issues.
   */
  skip?: number
  distinct?: Prisma.IssueScalarFieldEnum | Prisma.IssueScalarFieldEnum[]
}

/**
 * Issue create
 */
export type IssueCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * The data needed to create a Issue.
   */
  data: Prisma.XOR<Prisma.IssueCreateInput, Prisma.IssueUncheckedCreateInput>
}

/**
 * Issue createMany
 */
export type IssueCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Issues.
   */
  data: Prisma.IssueCreateManyInput | Prisma.IssueCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Issue createManyAndReturn
 */
export type IssueCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * The data used to create many Issues.
   */
  data: Prisma.IssueCreateManyInput | Prisma.IssueCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Issue update
 */
export type IssueUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * The data needed to update a Issue.
   */
  data: Prisma.XOR<Prisma.IssueUpdateInput, Prisma.IssueUncheckedUpdateInput>
  /**
   * Choose, which Issue to update.
   */
  where: Prisma.IssueWhereUniqueInput
}

/**
 * Issue updateMany
 */
export type IssueUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Issues.
   */
  data: Prisma.XOR<Prisma.IssueUpdateManyMutationInput, Prisma.IssueUncheckedUpdateManyInput>
  /**
   * Filter which Issues to update
   */
  where?: Prisma.IssueWhereInput
  /**
   * Limit how many Issues to update.
   */
  limit?: number
}

/**
 * Issue updateManyAndReturn
 */
export type IssueUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * The data used to update Issues.
   */
  data: Prisma.XOR<Prisma.IssueUpdateManyMutationInput, Prisma.IssueUncheckedUpdateManyInput>
  /**
   * Filter which Issues to update
   */
  where?: Prisma.IssueWhereInput
  /**
   * Limit how many Issues to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Issue upsert
 */
export type IssueUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * The filter to search for the Issue to update in case it exists.
   */
  where: Prisma.IssueWhereUniqueInput
  /**
   * In case the Issue found by the `where` argument doesn't exist, create a new Issue with this data.
   */
  create: Prisma.XOR<Prisma.IssueCreateInput, Prisma.IssueUncheckedCreateInput>
  /**
   * In case the Issue was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.IssueUpdateInput, Prisma.IssueUncheckedUpdateInput>
}

/**
 * Issue delete
 */
export type IssueDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  /**
   * Filter which Issue to delete.
   */
  where: Prisma.IssueWhereUniqueInput
}

/**
 * Issue deleteMany
 */
export type IssueDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Issues to delete
   */
  where?: Prisma.IssueWhereInput
  /**
   * Limit how many Issues to delete.
   */
  limit?: number
}

/**
 * Issue.comments
 */
export type Issue$commentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  where?: Prisma.CommentWhereInput
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  cursor?: Prisma.CommentWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * Issue.guestToken
 */
export type Issue$guestTokenArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the GuestToken
   */
  select?: Prisma.GuestTokenSelect<ExtArgs> | null
  /**
   * Omit specific fields from the GuestToken
   */
  omit?: Prisma.GuestTokenOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.GuestTokenInclude<ExtArgs> | null
  where?: Prisma.GuestTokenWhereInput
}

/**
 * Issue.upvotes
 */
export type Issue$upvotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  where?: Prisma.IssueUpvoteWhereInput
  orderBy?: Prisma.IssueUpvoteOrderByWithRelationInput | Prisma.IssueUpvoteOrderByWithRelationInput[]
  cursor?: Prisma.IssueUpvoteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.IssueUpvoteScalarFieldEnum | Prisma.IssueUpvoteScalarFieldEnum[]
}

/**
 * Issue.resolutionVotes
 */
export type Issue$resolutionVotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  where?: Prisma.IssueResolutionVoteWhereInput
  orderBy?: Prisma.IssueResolutionVoteOrderByWithRelationInput | Prisma.IssueResolutionVoteOrderByWithRelationInput[]
  cursor?: Prisma.IssueResolutionVoteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.IssueResolutionVoteScalarFieldEnum | Prisma.IssueResolutionVoteScalarFieldEnum[]
}

/**
 * Issue without action
 */
export type IssueDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\IssueResolutionVote.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `IssueResolutionVote` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model IssueResolutionVote
 * 
 */
export type IssueResolutionVoteModel = runtime.Types.Result.DefaultSelection<Prisma.$IssueResolutionVotePayload>

export type AggregateIssueResolutionVote = {
  _count: IssueResolutionVoteCountAggregateOutputType | null
  _avg: IssueResolutionVoteAvgAggregateOutputType | null
  _sum: IssueResolutionVoteSumAggregateOutputType | null
  _min: IssueResolutionVoteMinAggregateOutputType | null
  _max: IssueResolutionVoteMaxAggregateOutputType | null
}

export type IssueResolutionVoteAvgAggregateOutputType = {
  id: number | null
  issueId: number | null
  userId: number | null
}

export type IssueResolutionVoteSumAggregateOutputType = {
  id: number | null
  issueId: number | null
  userId: number | null
}

export type IssueResolutionVoteMinAggregateOutputType = {
  id: number | null
  createdAt: Date | null
  isResolved: boolean | null
  issueId: number | null
  userId: number | null
}

export type IssueResolutionVoteMaxAggregateOutputType = {
  id: number | null
  createdAt: Date | null
  isResolved: boolean | null
  issueId: number | null
  userId: number | null
}

export type IssueResolutionVoteCountAggregateOutputType = {
  id: number
  createdAt: number
  isResolved: number
  issueId: number
  userId: number
  _all: number
}


export type IssueResolutionVoteAvgAggregateInputType = {
  id?: true
  issueId?: true
  userId?: true
}

export type IssueResolutionVoteSumAggregateInputType = {
  id?: true
  issueId?: true
  userId?: true
}

export type IssueResolutionVoteMinAggregateInputType = {
  id?: true
  createdAt?: true
  isResolved?: true
  issueId?: true
  userId?: true
}

export type IssueResolutionVoteMaxAggregateInputType = {
  id?: true
  createdAt?: true
  isResolved?: true
  issueId?: true
  userId?: true
}

export type IssueResolutionVoteCountAggregateInputType = {
  id?: true
  createdAt?: true
  isResolved?: true
  issueId?: true
  userId?: true
  _all?: true
}

export type IssueResolutionVoteAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which IssueResolutionVote to aggregate.
   */
  where?: Prisma.IssueResolutionVoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of IssueResolutionVotes to fetch.
   */
  orderBy?: Prisma.IssueResolutionVoteOrderByWithRelationInput | Prisma.IssueResolutionVoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.IssueResolutionVoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` IssueResolutionVotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` IssueResolutionVotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned IssueResolutionVotes
  **/
  _count?: true | IssueResolutionVoteCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: IssueResolutionVoteAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: IssueResolutionVoteSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: IssueResolutionVoteMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: IssueResolutionVoteMaxAggregateInputType
}

export type GetIssueResolutionVoteAggregateType<T extends IssueResolutionVoteAggregateArgs> = {
      [P in keyof T & keyof AggregateIssueResolutionVote]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateIssueResolutionVote[P]>
    : Prisma.GetScalarType<T[P], AggregateIssueResolutionVote[P]>
}




export type IssueResolutionVoteGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueResolutionVoteWhereInput
  orderBy?: Prisma.IssueResolutionVoteOrderByWithAggregationInput | Prisma.IssueResolutionVoteOrderByWithAggregationInput[]
  by: Prisma.IssueResolutionVoteScalarFieldEnum[] | Prisma.IssueResolutionVoteScalarFieldEnum
  having?: Prisma.IssueResolutionVoteScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: IssueResolutionVoteCountAggregateInputType | true
  _avg?: IssueResolutionVoteAvgAggregateInputType
  _sum?: IssueResolutionVoteSumAggregateInputType
  _min?: IssueResolutionVoteMinAggregateInputType
  _max?: IssueResolutionVoteMaxAggregateInputType
}

export type IssueResolutionVoteGroupByOutputType = {
  id: number
  createdAt: Date
  isResolved: boolean
  issueId: number
  userId: number
  _count: IssueResolutionVoteCountAggregateOutputType | null
  _avg: IssueResolutionVoteAvgAggregateOutputType | null
  _sum: IssueResolutionVoteSumAggregateOutputType | null
  _min: IssueResolutionVoteMinAggregateOutputType | null
  _max: IssueResolutionVoteMaxAggregateOutputType | null
}

type GetIssueResolutionVoteGroupByPayload<T extends IssueResolutionVoteGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<IssueResolutionVoteGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof IssueResolutionVoteGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], IssueResolutionVoteGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], IssueResolutionVoteGroupByOutputType[P]>
      }
    >
  >



export type IssueResolutionVoteWhereInput = {
  AND?: Prisma.IssueResolutionVoteWhereInput | Prisma.IssueResolutionVoteWhereInput[]
  OR?: Prisma.IssueResolutionVoteWhereInput[]
  NOT?: Prisma.IssueResolutionVoteWhereInput | Prisma.IssueResolutionVoteWhereInput[]
  id?: Prisma.IntFilter<"IssueResolutionVote"> | number
  createdAt?: Prisma.DateTimeFilter<"IssueResolutionVote"> | Date | string
  isResolved?: Prisma.BoolFilter<"IssueResolutionVote"> | boolean
  issueId?: Prisma.IntFilter<"IssueResolutionVote"> | number
  userId?: Prisma.IntFilter<"IssueResolutionVote"> | number
  issue?: Prisma.XOR<Prisma.IssueScalarRelationFilter, Prisma.IssueWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}

export type IssueResolutionVoteOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  isResolved?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  issue?: Prisma.IssueOrderByWithRelationInput
  user?: Prisma.UserOrderByWithRelationInput
}

export type IssueResolutionVoteWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  issueId_userId?: Prisma.IssueResolutionVoteIssueIdUserIdCompoundUniqueInput
  AND?: Prisma.IssueResolutionVoteWhereInput | Prisma.IssueResolutionVoteWhereInput[]
  OR?: Prisma.IssueResolutionVoteWhereInput[]
  NOT?: Prisma.IssueResolutionVoteWhereInput | Prisma.IssueResolutionVoteWhereInput[]
  createdAt?: Prisma.DateTimeFilter<"IssueResolutionVote"> | Date | string
  isResolved?: Prisma.BoolFilter<"IssueResolutionVote"> | boolean
  issueId?: Prisma.IntFilter<"IssueResolutionVote"> | number
  userId?: Prisma.IntFilter<"IssueResolutionVote"> | number
  issue?: Prisma.XOR<Prisma.IssueScalarRelationFilter, Prisma.IssueWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}, "id" | "issueId_userId">

export type IssueResolutionVoteOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  isResolved?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  _count?: Prisma.IssueResolutionVoteCountOrderByAggregateInput
  _avg?: Prisma.IssueResolutionVoteAvgOrderByAggregateInput
  _max?: Prisma.IssueResolutionVoteMaxOrderByAggregateInput
  _min?: Prisma.IssueResolutionVoteMinOrderByAggregateInput
  _sum?: Prisma.IssueResolutionVoteSumOrderByAggregateInput
}

export type IssueResolutionVoteScalarWhereWithAggregatesInput = {
  AND?: Prisma.IssueResolutionVoteScalarWhereWithAggregatesInput | Prisma.IssueResolutionVoteScalarWhereWithAggregatesInput[]
  OR?: Prisma.IssueResolutionVoteScalarWhereWithAggregatesInput[]
  NOT?: Prisma.IssueResolutionVoteScalarWhereWithAggregatesInput | Prisma.IssueResolutionVoteScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"IssueResolutionVote"> | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"IssueResolutionVote"> | Date | string
  isResolved?: Prisma.BoolWithAggregatesFilter<"IssueResolutionVote"> | boolean
  issueId?: Prisma.IntWithAggregatesFilter<"IssueResolutionVote"> | number
  userId?: Prisma.IntWithAggregatesFilter<"IssueResolutionVote"> | number
}

export type IssueResolutionVoteCreateInput = {
  createdAt?: Date | string
  isResolved: boolean
  issue: Prisma.IssueCreateNestedOneWithoutResolutionVotesInput
  user: Prisma.UserCreateNestedOneWithoutResolutionVotesInput
}

export type IssueResolutionVoteUncheckedCreateInput = {
  id?: number
  createdAt?: Date | string
  isResolved: boolean
  issueId: number
  userId: number
}

export type IssueResolutionVoteUpdateInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issue?: Prisma.IssueUpdateOneRequiredWithoutResolutionVotesNestedInput
  user?: Prisma.UserUpdateOneRequiredWithoutResolutionVotesNestedInput
}

export type IssueResolutionVoteUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueResolutionVoteCreateManyInput = {
  id?: number
  createdAt?: Date | string
  isResolved: boolean
  issueId: number
  userId: number
}

export type IssueResolutionVoteUpdateManyMutationInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type IssueResolutionVoteUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueResolutionVoteListRelationFilter = {
  every?: Prisma.IssueResolutionVoteWhereInput
  some?: Prisma.IssueResolutionVoteWhereInput
  none?: Prisma.IssueResolutionVoteWhereInput
}

export type IssueResolutionVoteOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type IssueResolutionVoteIssueIdUserIdCompoundUniqueInput = {
  issueId: number
  userId: number
}

export type IssueResolutionVoteCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  isResolved?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueResolutionVoteAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueResolutionVoteMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  isResolved?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueResolutionVoteMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  isResolved?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueResolutionVoteSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueResolutionVoteCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutUserInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput> | Prisma.IssueResolutionVoteCreateWithoutUserInput[] | Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueResolutionVoteCreateOrConnectWithoutUserInput | Prisma.IssueResolutionVoteCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.IssueResolutionVoteCreateManyUserInputEnvelope
  connect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
}

export type IssueResolutionVoteUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutUserInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput> | Prisma.IssueResolutionVoteCreateWithoutUserInput[] | Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueResolutionVoteCreateOrConnectWithoutUserInput | Prisma.IssueResolutionVoteCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.IssueResolutionVoteCreateManyUserInputEnvelope
  connect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
}

export type IssueResolutionVoteUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutUserInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput> | Prisma.IssueResolutionVoteCreateWithoutUserInput[] | Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueResolutionVoteCreateOrConnectWithoutUserInput | Prisma.IssueResolutionVoteCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.IssueResolutionVoteUpsertWithWhereUniqueWithoutUserInput | Prisma.IssueResolutionVoteUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.IssueResolutionVoteCreateManyUserInputEnvelope
  set?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  disconnect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  delete?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  connect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  update?: Prisma.IssueResolutionVoteUpdateWithWhereUniqueWithoutUserInput | Prisma.IssueResolutionVoteUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.IssueResolutionVoteUpdateManyWithWhereWithoutUserInput | Prisma.IssueResolutionVoteUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.IssueResolutionVoteScalarWhereInput | Prisma.IssueResolutionVoteScalarWhereInput[]
}

export type IssueResolutionVoteUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutUserInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput> | Prisma.IssueResolutionVoteCreateWithoutUserInput[] | Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueResolutionVoteCreateOrConnectWithoutUserInput | Prisma.IssueResolutionVoteCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.IssueResolutionVoteUpsertWithWhereUniqueWithoutUserInput | Prisma.IssueResolutionVoteUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.IssueResolutionVoteCreateManyUserInputEnvelope
  set?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  disconnect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  delete?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  connect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  update?: Prisma.IssueResolutionVoteUpdateWithWhereUniqueWithoutUserInput | Prisma.IssueResolutionVoteUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.IssueResolutionVoteUpdateManyWithWhereWithoutUserInput | Prisma.IssueResolutionVoteUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.IssueResolutionVoteScalarWhereInput | Prisma.IssueResolutionVoteScalarWhereInput[]
}

export type IssueResolutionVoteCreateNestedManyWithoutIssueInput = {
  create?: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutIssueInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput> | Prisma.IssueResolutionVoteCreateWithoutIssueInput[] | Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.IssueResolutionVoteCreateOrConnectWithoutIssueInput | Prisma.IssueResolutionVoteCreateOrConnectWithoutIssueInput[]
  createMany?: Prisma.IssueResolutionVoteCreateManyIssueInputEnvelope
  connect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
}

export type IssueResolutionVoteUncheckedCreateNestedManyWithoutIssueInput = {
  create?: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutIssueInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput> | Prisma.IssueResolutionVoteCreateWithoutIssueInput[] | Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.IssueResolutionVoteCreateOrConnectWithoutIssueInput | Prisma.IssueResolutionVoteCreateOrConnectWithoutIssueInput[]
  createMany?: Prisma.IssueResolutionVoteCreateManyIssueInputEnvelope
  connect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
}

export type IssueResolutionVoteUpdateManyWithoutIssueNestedInput = {
  create?: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutIssueInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput> | Prisma.IssueResolutionVoteCreateWithoutIssueInput[] | Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.IssueResolutionVoteCreateOrConnectWithoutIssueInput | Prisma.IssueResolutionVoteCreateOrConnectWithoutIssueInput[]
  upsert?: Prisma.IssueResolutionVoteUpsertWithWhereUniqueWithoutIssueInput | Prisma.IssueResolutionVoteUpsertWithWhereUniqueWithoutIssueInput[]
  createMany?: Prisma.IssueResolutionVoteCreateManyIssueInputEnvelope
  set?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  disconnect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  delete?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  connect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  update?: Prisma.IssueResolutionVoteUpdateWithWhereUniqueWithoutIssueInput | Prisma.IssueResolutionVoteUpdateWithWhereUniqueWithoutIssueInput[]
  updateMany?: Prisma.IssueResolutionVoteUpdateManyWithWhereWithoutIssueInput | Prisma.IssueResolutionVoteUpdateManyWithWhereWithoutIssueInput[]
  deleteMany?: Prisma.IssueResolutionVoteScalarWhereInput | Prisma.IssueResolutionVoteScalarWhereInput[]
}

export type IssueResolutionVoteUncheckedUpdateManyWithoutIssueNestedInput = {
  create?: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutIssueInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput> | Prisma.IssueResolutionVoteCreateWithoutIssueInput[] | Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.IssueResolutionVoteCreateOrConnectWithoutIssueInput | Prisma.IssueResolutionVoteCreateOrConnectWithoutIssueInput[]
  upsert?: Prisma.IssueResolutionVoteUpsertWithWhereUniqueWithoutIssueInput | Prisma.IssueResolutionVoteUpsertWithWhereUniqueWithoutIssueInput[]
  createMany?: Prisma.IssueResolutionVoteCreateManyIssueInputEnvelope
  set?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  disconnect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  delete?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  connect?: Prisma.IssueResolutionVoteWhereUniqueInput | Prisma.IssueResolutionVoteWhereUniqueInput[]
  update?: Prisma.IssueResolutionVoteUpdateWithWhereUniqueWithoutIssueInput | Prisma.IssueResolutionVoteUpdateWithWhereUniqueWithoutIssueInput[]
  updateMany?: Prisma.IssueResolutionVoteUpdateManyWithWhereWithoutIssueInput | Prisma.IssueResolutionVoteUpdateManyWithWhereWithoutIssueInput[]
  deleteMany?: Prisma.IssueResolutionVoteScalarWhereInput | Prisma.IssueResolutionVoteScalarWhereInput[]
}

export type IssueResolutionVoteCreateWithoutUserInput = {
  createdAt?: Date | string
  isResolved: boolean
  issue: Prisma.IssueCreateNestedOneWithoutResolutionVotesInput
}

export type IssueResolutionVoteUncheckedCreateWithoutUserInput = {
  id?: number
  createdAt?: Date | string
  isResolved: boolean
  issueId: number
}

export type IssueResolutionVoteCreateOrConnectWithoutUserInput = {
  where: Prisma.IssueResolutionVoteWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutUserInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput>
}

export type IssueResolutionVoteCreateManyUserInputEnvelope = {
  data: Prisma.IssueResolutionVoteCreateManyUserInput | Prisma.IssueResolutionVoteCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type IssueResolutionVoteUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.IssueResolutionVoteWhereUniqueInput
  update: Prisma.XOR<Prisma.IssueResolutionVoteUpdateWithoutUserInput, Prisma.IssueResolutionVoteUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutUserInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutUserInput>
}

export type IssueResolutionVoteUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.IssueResolutionVoteWhereUniqueInput
  data: Prisma.XOR<Prisma.IssueResolutionVoteUpdateWithoutUserInput, Prisma.IssueResolutionVoteUncheckedUpdateWithoutUserInput>
}

export type IssueResolutionVoteUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.IssueResolutionVoteScalarWhereInput
  data: Prisma.XOR<Prisma.IssueResolutionVoteUpdateManyMutationInput, Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutUserInput>
}

export type IssueResolutionVoteScalarWhereInput = {
  AND?: Prisma.IssueResolutionVoteScalarWhereInput | Prisma.IssueResolutionVoteScalarWhereInput[]
  OR?: Prisma.IssueResolutionVoteScalarWhereInput[]
  NOT?: Prisma.IssueResolutionVoteScalarWhereInput | Prisma.IssueResolutionVoteScalarWhereInput[]
  id?: Prisma.IntFilter<"IssueResolutionVote"> | number
  createdAt?: Prisma.DateTimeFilter<"IssueResolutionVote"> | Date | string
  isResolved?: Prisma.BoolFilter<"IssueResolutionVote"> | boolean
  issueId?: Prisma.IntFilter<"IssueResolutionVote"> | number
  userId?: Prisma.IntFilter<"IssueResolutionVote"> | number
}

export type IssueResolutionVoteCreateWithoutIssueInput = {
  createdAt?: Date | string
  isResolved: boolean
  user: Prisma.UserCreateNestedOneWithoutResolutionVotesInput
}

export type IssueResolutionVoteUncheckedCreateWithoutIssueInput = {
  id?: number
  createdAt?: Date | string
  isResolved: boolean
  userId: number
}

export type IssueResolutionVoteCreateOrConnectWithoutIssueInput = {
  where: Prisma.IssueResolutionVoteWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutIssueInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput>
}

export type IssueResolutionVoteCreateManyIssueInputEnvelope = {
  data: Prisma.IssueResolutionVoteCreateManyIssueInput | Prisma.IssueResolutionVoteCreateManyIssueInput[]
  skipDuplicates?: boolean
}

export type IssueResolutionVoteUpsertWithWhereUniqueWithoutIssueInput = {
  where: Prisma.IssueResolutionVoteWhereUniqueInput
  update: Prisma.XOR<Prisma.IssueResolutionVoteUpdateWithoutIssueInput, Prisma.IssueResolutionVoteUncheckedUpdateWithoutIssueInput>
  create: Prisma.XOR<Prisma.IssueResolutionVoteCreateWithoutIssueInput, Prisma.IssueResolutionVoteUncheckedCreateWithoutIssueInput>
}

export type IssueResolutionVoteUpdateWithWhereUniqueWithoutIssueInput = {
  where: Prisma.IssueResolutionVoteWhereUniqueInput
  data: Prisma.XOR<Prisma.IssueResolutionVoteUpdateWithoutIssueInput, Prisma.IssueResolutionVoteUncheckedUpdateWithoutIssueInput>
}

export type IssueResolutionVoteUpdateManyWithWhereWithoutIssueInput = {
  where: Prisma.IssueResolutionVoteScalarWhereInput
  data: Prisma.XOR<Prisma.IssueResolutionVoteUpdateManyMutationInput, Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutIssueInput>
}

export type IssueResolutionVoteCreateManyUserInput = {
  id?: number
  createdAt?: Date | string
  isResolved: boolean
  issueId: number
}

export type IssueResolutionVoteUpdateWithoutUserInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issue?: Prisma.IssueUpdateOneRequiredWithoutResolutionVotesNestedInput
}

export type IssueResolutionVoteUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueResolutionVoteUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueResolutionVoteCreateManyIssueInput = {
  id?: number
  createdAt?: Date | string
  isResolved: boolean
  userId: number
}

export type IssueResolutionVoteUpdateWithoutIssueInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  user?: Prisma.UserUpdateOneRequiredWithoutResolutionVotesNestedInput
}

export type IssueResolutionVoteUncheckedUpdateWithoutIssueInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueResolutionVoteUncheckedUpdateManyWithoutIssueInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  isResolved?: Prisma.BoolFieldUpdateOperationsInput | boolean
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}



export type IssueResolutionVoteSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  isResolved?: boolean
  issueId?: boolean
  userId?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["issueResolutionVote"]>

export type IssueResolutionVoteSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  isResolved?: boolean
  issueId?: boolean
  userId?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["issueResolutionVote"]>

export type IssueResolutionVoteSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  isResolved?: boolean
  issueId?: boolean
  userId?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["issueResolutionVote"]>

export type IssueResolutionVoteSelectScalar = {
  id?: boolean
  createdAt?: boolean
  isResolved?: boolean
  issueId?: boolean
  userId?: boolean
}

export type IssueResolutionVoteOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "createdAt" | "isResolved" | "issueId" | "userId", ExtArgs["result"]["issueResolutionVote"]>
export type IssueResolutionVoteInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type IssueResolutionVoteIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type IssueResolutionVoteIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $IssueResolutionVotePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "IssueResolutionVote"
  objects: {
    issue: Prisma.$IssuePayload<ExtArgs>
    user: Prisma.$UserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    createdAt: Date
    isResolved: boolean
    issueId: number
    userId: number
  }, ExtArgs["result"]["issueResolutionVote"]>
  composites: {}
}

export type IssueResolutionVoteGetPayload<S extends boolean | null | undefined | IssueResolutionVoteDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload, S>

export type IssueResolutionVoteCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<IssueResolutionVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: IssueResolutionVoteCountAggregateInputType | true
  }

export interface IssueResolutionVoteDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IssueResolutionVote'], meta: { name: 'IssueResolutionVote' } }
  /**
   * Find zero or one IssueResolutionVote that matches the filter.
   * @param {IssueResolutionVoteFindUniqueArgs} args - Arguments to find a IssueResolutionVote
   * @example
   * // Get one IssueResolutionVote
   * const issueResolutionVote = await prisma.issueResolutionVote.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends IssueResolutionVoteFindUniqueArgs>(args: Prisma.SelectSubset<T, IssueResolutionVoteFindUniqueArgs<ExtArgs>>): Prisma.Prisma__IssueResolutionVoteClient<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one IssueResolutionVote that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {IssueResolutionVoteFindUniqueOrThrowArgs} args - Arguments to find a IssueResolutionVote
   * @example
   * // Get one IssueResolutionVote
   * const issueResolutionVote = await prisma.issueResolutionVote.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends IssueResolutionVoteFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, IssueResolutionVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__IssueResolutionVoteClient<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first IssueResolutionVote that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueResolutionVoteFindFirstArgs} args - Arguments to find a IssueResolutionVote
   * @example
   * // Get one IssueResolutionVote
   * const issueResolutionVote = await prisma.issueResolutionVote.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends IssueResolutionVoteFindFirstArgs>(args?: Prisma.SelectSubset<T, IssueResolutionVoteFindFirstArgs<ExtArgs>>): Prisma.Prisma__IssueResolutionVoteClient<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first IssueResolutionVote that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueResolutionVoteFindFirstOrThrowArgs} args - Arguments to find a IssueResolutionVote
   * @example
   * // Get one IssueResolutionVote
   * const issueResolutionVote = await prisma.issueResolutionVote.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends IssueResolutionVoteFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, IssueResolutionVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__IssueResolutionVoteClient<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more IssueResolutionVotes that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueResolutionVoteFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all IssueResolutionVotes
   * const issueResolutionVotes = await prisma.issueResolutionVote.findMany()
   * 
   * // Get first 10 IssueResolutionVotes
   * const issueResolutionVotes = await prisma.issueResolutionVote.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const issueResolutionVoteWithIdOnly = await prisma.issueResolutionVote.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends IssueResolutionVoteFindManyArgs>(args?: Prisma.SelectSubset<T, IssueResolutionVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a IssueResolutionVote.
   * @param {IssueResolutionVoteCreateArgs} args - Arguments to create a IssueResolutionVote.
   * @example
   * // Create one IssueResolutionVote
   * const IssueResolutionVote = await prisma.issueResolutionVote.create({
   *   data: {
   *     // ... data to create a IssueResolutionVote
   *   }
   * })
   * 
   */
  create<T extends IssueResolutionVoteCreateArgs>(args: Prisma.SelectSubset<T, IssueResolutionVoteCreateArgs<ExtArgs>>): Prisma.Prisma__IssueResolutionVoteClient<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many IssueResolutionVotes.
   * @param {IssueResolutionVoteCreateManyArgs} args - Arguments to create many IssueResolutionVotes.
   * @example
   * // Create many IssueResolutionVotes
   * const issueResolutionVote = await prisma.issueResolutionVote.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends IssueResolutionVoteCreateManyArgs>(args?: Prisma.SelectSubset<T, IssueResolutionVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many IssueResolutionVotes and returns the data saved in the database.
   * @param {IssueResolutionVoteCreateManyAndReturnArgs} args - Arguments to create many IssueResolutionVotes.
   * @example
   * // Create many IssueResolutionVotes
   * const issueResolutionVote = await prisma.issueResolutionVote.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many IssueResolutionVotes and only return the `id`
   * const issueResolutionVoteWithIdOnly = await prisma.issueResolutionVote.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends IssueResolutionVoteCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, IssueResolutionVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a IssueResolutionVote.
   * @param {IssueResolutionVoteDeleteArgs} args - Arguments to delete one IssueResolutionVote.
   * @example
   * // Delete one IssueResolutionVote
   * const IssueResolutionVote = await prisma.issueResolutionVote.delete({
   *   where: {
   *     // ... filter to delete one IssueResolutionVote
   *   }
   * })
   * 
   */
  delete<T extends IssueResolutionVoteDeleteArgs>(args: Prisma.SelectSubset<T, IssueResolutionVoteDeleteArgs<ExtArgs>>): Prisma.Prisma__IssueResolutionVoteClient<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one IssueResolutionVote.
   * @param {IssueResolutionVoteUpdateArgs} args - Arguments to update one IssueResolutionVote.
   * @example
   * // Update one IssueResolutionVote
   * const issueResolutionVote = await prisma.issueResolutionVote.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends IssueResolutionVoteUpdateArgs>(args: Prisma.SelectSubset<T, IssueResolutionVoteUpdateArgs<ExtArgs>>): Prisma.Prisma__IssueResolutionVoteClient<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more IssueResolutionVotes.
   * @param {IssueResolutionVoteDeleteManyArgs} args - Arguments to filter IssueResolutionVotes to delete.
   * @example
   * // Delete a few IssueResolutionVotes
   * const { count } = await prisma.issueResolutionVote.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends IssueResolutionVoteDeleteManyArgs>(args?: Prisma.SelectSubset<T, IssueResolutionVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more IssueResolutionVotes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueResolutionVoteUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many IssueResolutionVotes
   * const issueResolutionVote = await prisma.issueResolutionVote.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends IssueResolutionVoteUpdateManyArgs>(args: Prisma.SelectSubset<T, IssueResolutionVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more IssueResolutionVotes and returns the data updated in the database.
   * @param {IssueResolutionVoteUpdateManyAndReturnArgs} args - Arguments to update many IssueResolutionVotes.
   * @example
   * // Update many IssueResolutionVotes
   * const issueResolutionVote = await prisma.issueResolutionVote.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more IssueResolutionVotes and only return the `id`
   * const issueResolutionVoteWithIdOnly = await prisma.issueResolutionVote.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends IssueResolutionVoteUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, IssueResolutionVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one IssueResolutionVote.
   * @param {IssueResolutionVoteUpsertArgs} args - Arguments to update or create a IssueResolutionVote.
   * @example
   * // Update or create a IssueResolutionVote
   * const issueResolutionVote = await prisma.issueResolutionVote.upsert({
   *   create: {
   *     // ... data to create a IssueResolutionVote
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the IssueResolutionVote we want to update
   *   }
   * })
   */
  upsert<T extends IssueResolutionVoteUpsertArgs>(args: Prisma.SelectSubset<T, IssueResolutionVoteUpsertArgs<ExtArgs>>): Prisma.Prisma__IssueResolutionVoteClient<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of IssueResolutionVotes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueResolutionVoteCountArgs} args - Arguments to filter IssueResolutionVotes to count.
   * @example
   * // Count the number of IssueResolutionVotes
   * const count = await prisma.issueResolutionVote.count({
   *   where: {
   *     // ... the filter for the IssueResolutionVotes we want to count
   *   }
   * })
  **/
  count<T extends IssueResolutionVoteCountArgs>(
    args?: Prisma.Subset<T, IssueResolutionVoteCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], IssueResolutionVoteCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a IssueResolutionVote.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueResolutionVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends IssueResolutionVoteAggregateArgs>(args: Prisma.Subset<T, IssueResolutionVoteAggregateArgs>): Prisma.PrismaPromise<GetIssueResolutionVoteAggregateType<T>>

  /**
   * Group by IssueResolutionVote.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueResolutionVoteGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends IssueResolutionVoteGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: IssueResolutionVoteGroupByArgs['orderBy'] }
      : { orderBy?: IssueResolutionVoteGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, IssueResolutionVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueResolutionVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the IssueResolutionVote model
 */
readonly fields: IssueResolutionVoteFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for IssueResolutionVote.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__IssueResolutionVoteClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  issue<T extends Prisma.IssueDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.IssueDefaultArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the IssueResolutionVote model
 */
export interface IssueResolutionVoteFieldRefs {
  readonly id: Prisma.FieldRef<"IssueResolutionVote", 'Int'>
  readonly createdAt: Prisma.FieldRef<"IssueResolutionVote", 'DateTime'>
  readonly isResolved: Prisma.FieldRef<"IssueResolutionVote", 'Boolean'>
  readonly issueId: Prisma.FieldRef<"IssueResolutionVote", 'Int'>
  readonly userId: Prisma.FieldRef<"IssueResolutionVote", 'Int'>
}
    

// Custom InputTypes
/**
 * IssueResolutionVote findUnique
 */
export type IssueResolutionVoteFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueResolutionVote to fetch.
   */
  where: Prisma.IssueResolutionVoteWhereUniqueInput
}

/**
 * IssueResolutionVote findUniqueOrThrow
 */
export type IssueResolutionVoteFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueResolutionVote to fetch.
   */
  where: Prisma.IssueResolutionVoteWhereUniqueInput
}

/**
 * IssueResolutionVote findFirst
 */
export type IssueResolutionVoteFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueResolutionVote to fetch.
   */
  where?: Prisma.IssueResolutionVoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of IssueResolutionVotes to fetch.
   */
  orderBy?: Prisma.IssueResolutionVoteOrderByWithRelationInput | Prisma.IssueResolutionVoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for IssueResolutionVotes.
   */
  cursor?: Prisma.IssueResolutionVoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` IssueResolutionVotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` IssueResolutionVotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of IssueResolutionVotes.
   */
  distinct?: Prisma.IssueResolutionVoteScalarFieldEnum | Prisma.IssueResolutionVoteScalarFieldEnum[]
}

/**
 * IssueResolutionVote findFirstOrThrow
 */
export type IssueResolutionVoteFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueResolutionVote to fetch.
   */
  where?: Prisma.IssueResolutionVoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of IssueResolutionVotes to fetch.
   */
  orderBy?: Prisma.IssueResolutionVoteOrderByWithRelationInput | Prisma.IssueResolutionVoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for IssueResolutionVotes.
   */
  cursor?: Prisma.IssueResolutionVoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` IssueResolutionVotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` IssueResolutionVotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of IssueResolutionVotes.
   */
  distinct?: Prisma.IssueResolutionVoteScalarFieldEnum | Prisma.IssueResolutionVoteScalarFieldEnum[]
}

/**
 * IssueResolutionVote findMany
 */
export type IssueResolutionVoteFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueResolutionVotes to fetch.
   */
  where?: Prisma.IssueResolutionVoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of IssueResolutionVotes to fetch.
   */
  orderBy?: Prisma.IssueResolutionVoteOrderByWithRelationInput | Prisma.IssueResolutionVoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing IssueResolutionVotes.
   */
  cursor?: Prisma.IssueResolutionVoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` IssueResolutionVotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` IssueResolutionVotes.
   */
  skip?: number
  distinct?: Prisma.IssueResolutionVoteScalarFieldEnum | Prisma.IssueResolutionVoteScalarFieldEnum[]
}

/**
 * IssueResolutionVote create
 */
export type IssueResolutionVoteCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * The data needed to create a IssueResolutionVote.
   */
  data: Prisma.XOR<Prisma.IssueResolutionVoteCreateInput, Prisma.IssueResolutionVoteUncheckedCreateInput>
}

/**
 * IssueResolutionVote createMany
 */
export type IssueResolutionVoteCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many IssueResolutionVotes.
   */
  data: Prisma.IssueResolutionVoteCreateManyInput | Prisma.IssueResolutionVoteCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * IssueResolutionVote createManyAndReturn
 */
export type IssueResolutionVoteCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * The data used to create many IssueResolutionVotes.
   */
  data: Prisma.IssueResolutionVoteCreateManyInput | Prisma.IssueResolutionVoteCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * IssueResolutionVote update
 */
export type IssueResolutionVoteUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * The data needed to update a IssueResolutionVote.
   */
  data: Prisma.XOR<Prisma.IssueResolutionVoteUpdateInput, Prisma.IssueResolutionVoteUncheckedUpdateInput>
  /**
   * Choose, which IssueResolutionVote to update.
   */
  where: Prisma.IssueResolutionVoteWhereUniqueInput
}

/**
 * IssueResolutionVote updateMany
 */
export type IssueResolutionVoteUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update IssueResolutionVotes.
   */
  data: Prisma.XOR<Prisma.IssueResolutionVoteUpdateManyMutationInput, Prisma.IssueResolutionVoteUncheckedUpdateManyInput>
  /**
   * Filter which IssueResolutionVotes to update
   */
  where?: Prisma.IssueResolutionVoteWhereInput
  /**
   * Limit how many IssueResolutionVotes to update.
   */
  limit?: number
}

/**
 * IssueResolutionVote updateManyAndReturn
 */
export type IssueResolutionVoteUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * The data used to update IssueResolutionVotes.
   */
  data: Prisma.XOR<Prisma.IssueResolutionVoteUpdateManyMutationInput, Prisma.IssueResolutionVoteUncheckedUpdateManyInput>
  /**
   * Filter which IssueResolutionVotes to update
   */
  where?: Prisma.IssueResolutionVoteWhereInput
  /**
   * Limit how many IssueResolutionVotes to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * IssueResolutionVote upsert
 */
export type IssueResolutionVoteUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * The filter to search for the IssueResolutionVote to update in case it exists.
   */
  where: Prisma.IssueResolutionVoteWhereUniqueInput
  /**
   * In case the IssueResolutionVote found by the `where` argument doesn't exist, create a new IssueResolutionVote with this data.
   */
  create: Prisma.XOR<Prisma.IssueResolutionVoteCreateInput, Prisma.IssueResolutionVoteUncheckedCreateInput>
  /**
   * In case the IssueResolutionVote was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.IssueResolutionVoteUpdateInput, Prisma.IssueResolutionVoteUncheckedUpdateInput>
}

/**
 * IssueResolutionVote delete
 */
export type IssueResolutionVoteDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  /**
   * Filter which IssueResolutionVote to delete.
   */
  where: Prisma.IssueResolutionVoteWhereUniqueInput
}

/**
 * IssueResolutionVote deleteMany
 */
export type IssueResolutionVoteDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which IssueResolutionVotes to delete
   */
  where?: Prisma.IssueResolutionVoteWhereInput
  /**
   * Limit how many IssueResolutionVotes to delete.
   */
  limit?: number
}

/**
 * IssueResolutionVote without action
 */
export type IssueResolutionVoteDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\IssueUpvote.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `IssueUpvote` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model IssueUpvote
 * 
 */
export type IssueUpvoteModel = runtime.Types.Result.DefaultSelection<Prisma.$IssueUpvotePayload>

export type AggregateIssueUpvote = {
  _count: IssueUpvoteCountAggregateOutputType | null
  _avg: IssueUpvoteAvgAggregateOutputType | null
  _sum: IssueUpvoteSumAggregateOutputType | null
  _min: IssueUpvoteMinAggregateOutputType | null
  _max: IssueUpvoteMaxAggregateOutputType | null
}

export type IssueUpvoteAvgAggregateOutputType = {
  id: number | null
  issueId: number | null
  userId: number | null
}

export type IssueUpvoteSumAggregateOutputType = {
  id: number | null
  issueId: number | null
  userId: number | null
}

export type IssueUpvoteMinAggregateOutputType = {
  id: number | null
  createdAt: Date | null
  issueId: number | null
  userId: number | null
}

export type IssueUpvoteMaxAggregateOutputType = {
  id: number | null
  createdAt: Date | null
  issueId: number | null
  userId: number | null
}

export type IssueUpvoteCountAggregateOutputType = {
  id: number
  createdAt: number
  issueId: number
  userId: number
  _all: number
}


export type IssueUpvoteAvgAggregateInputType = {
  id?: true
  issueId?: true
  userId?: true
}

export type IssueUpvoteSumAggregateInputType = {
  id?: true
  issueId?: true
  userId?: true
}

export type IssueUpvoteMinAggregateInputType = {
  id?: true
  createdAt?: true
  issueId?: true
  userId?: true
}

export type IssueUpvoteMaxAggregateInputType = {
  id?: true
  createdAt?: true
  issueId?: true
  userId?: true
}

export type IssueUpvoteCountAggregateInputType = {
  id?: true
  createdAt?: true
  issueId?: true
  userId?: true
  _all?: true
}

export type IssueUpvoteAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which IssueUpvote to aggregate.
   */
  where?: Prisma.IssueUpvoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of IssueUpvotes to fetch.
   */
  orderBy?: Prisma.IssueUpvoteOrderByWithRelationInput | Prisma.IssueUpvoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.IssueUpvoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` IssueUpvotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` IssueUpvotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned IssueUpvotes
  **/
  _count?: true | IssueUpvoteCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: IssueUpvoteAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: IssueUpvoteSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: IssueUpvoteMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: IssueUpvoteMaxAggregateInputType
}

export type GetIssueUpvoteAggregateType<T extends IssueUpvoteAggregateArgs> = {
      [P in keyof T & keyof AggregateIssueUpvote]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateIssueUpvote[P]>
    : Prisma.GetScalarType<T[P], AggregateIssueUpvote[P]>
}




export type IssueUpvoteGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueUpvoteWhereInput
  orderBy?: Prisma.IssueUpvoteOrderByWithAggregationInput | Prisma.IssueUpvoteOrderByWithAggregationInput[]
  by: Prisma.IssueUpvoteScalarFieldEnum[] | Prisma.IssueUpvoteScalarFieldEnum
  having?: Prisma.IssueUpvoteScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: IssueUpvoteCountAggregateInputType | true
  _avg?: IssueUpvoteAvgAggregateInputType
  _sum?: IssueUpvoteSumAggregateInputType
  _min?: IssueUpvoteMinAggregateInputType
  _max?: IssueUpvoteMaxAggregateInputType
}

export type IssueUpvoteGroupByOutputType = {
  id: number
  createdAt: Date
  issueId: number
  userId: number
  _count: IssueUpvoteCountAggregateOutputType | null
  _avg: IssueUpvoteAvgAggregateOutputType | null
  _sum: IssueUpvoteSumAggregateOutputType | null
  _min: IssueUpvoteMinAggregateOutputType | null
  _max: IssueUpvoteMaxAggregateOutputType | null
}

type GetIssueUpvoteGroupByPayload<T extends IssueUpvoteGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<IssueUpvoteGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof IssueUpvoteGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], IssueUpvoteGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], IssueUpvoteGroupByOutputType[P]>
      }
    >
  >



export type IssueUpvoteWhereInput = {
  AND?: Prisma.IssueUpvoteWhereInput | Prisma.IssueUpvoteWhereInput[]
  OR?: Prisma.IssueUpvoteWhereInput[]
  NOT?: Prisma.IssueUpvoteWhereInput | Prisma.IssueUpvoteWhereInput[]
  id?: Prisma.IntFilter<"IssueUpvote"> | number
  createdAt?: Prisma.DateTimeFilter<"IssueUpvote"> | Date | string
  issueId?: Prisma.IntFilter<"IssueUpvote"> | number
  userId?: Prisma.IntFilter<"IssueUpvote"> | number
  issue?: Prisma.XOR<Prisma.IssueScalarRelationFilter, Prisma.IssueWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}

export type IssueUpvoteOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  issue?: Prisma.IssueOrderByWithRelationInput
  user?: Prisma.UserOrderByWithRelationInput
}

export type IssueUpvoteWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  issueId_userId?: Prisma.IssueUpvoteIssueIdUserIdCompoundUniqueInput
  AND?: Prisma.IssueUpvoteWhereInput | Prisma.IssueUpvoteWhereInput[]
  OR?: Prisma.IssueUpvoteWhereInput[]
  NOT?: Prisma.IssueUpvoteWhereInput | Prisma.IssueUpvoteWhereInput[]
  createdAt?: Prisma.DateTimeFilter<"IssueUpvote"> | Date | string
  issueId?: Prisma.IntFilter<"IssueUpvote"> | number
  userId?: Prisma.IntFilter<"IssueUpvote"> | number
  issue?: Prisma.XOR<Prisma.IssueScalarRelationFilter, Prisma.IssueWhereInput>
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}, "id" | "issueId_userId">

export type IssueUpvoteOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  _count?: Prisma.IssueUpvoteCountOrderByAggregateInput
  _avg?: Prisma.IssueUpvoteAvgOrderByAggregateInput
  _max?: Prisma.IssueUpvoteMaxOrderByAggregateInput
  _min?: Prisma.IssueUpvoteMinOrderByAggregateInput
  _sum?: Prisma.IssueUpvoteSumOrderByAggregateInput
}

export type IssueUpvoteScalarWhereWithAggregatesInput = {
  AND?: Prisma.IssueUpvoteScalarWhereWithAggregatesInput | Prisma.IssueUpvoteScalarWhereWithAggregatesInput[]
  OR?: Prisma.IssueUpvoteScalarWhereWithAggregatesInput[]
  NOT?: Prisma.IssueUpvoteScalarWhereWithAggregatesInput | Prisma.IssueUpvoteScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"IssueUpvote"> | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"IssueUpvote"> | Date | string
  issueId?: Prisma.IntWithAggregatesFilter<"IssueUpvote"> | number
  userId?: Prisma.IntWithAggregatesFilter<"IssueUpvote"> | number
}

export type IssueUpvoteCreateInput = {
  createdAt?: Date | string
  issue: Prisma.IssueCreateNestedOneWithoutUpvotesInput
  user: Prisma.UserCreateNestedOneWithoutIssueUpvotesInput
}

export type IssueUpvoteUncheckedCreateInput = {
  id?: number
  createdAt?: Date | string
  issueId: number
  userId: number
}

export type IssueUpvoteUpdateInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issue?: Prisma.IssueUpdateOneRequiredWithoutUpvotesNestedInput
  user?: Prisma.UserUpdateOneRequiredWithoutIssueUpvotesNestedInput
}

export type IssueUpvoteUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueUpvoteCreateManyInput = {
  id?: number
  createdAt?: Date | string
  issueId: number
  userId: number
}

export type IssueUpvoteUpdateManyMutationInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type IssueUpvoteUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueUpvoteListRelationFilter = {
  every?: Prisma.IssueUpvoteWhereInput
  some?: Prisma.IssueUpvoteWhereInput
  none?: Prisma.IssueUpvoteWhereInput
}

export type IssueUpvoteOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type IssueUpvoteIssueIdUserIdCompoundUniqueInput = {
  issueId: number
  userId: number
}

export type IssueUpvoteCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueUpvoteAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueUpvoteMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueUpvoteMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueUpvoteSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  issueId?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type IssueUpvoteCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutUserInput, Prisma.IssueUpvoteUncheckedCreateWithoutUserInput> | Prisma.IssueUpvoteCreateWithoutUserInput[] | Prisma.IssueUpvoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueUpvoteCreateOrConnectWithoutUserInput | Prisma.IssueUpvoteCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.IssueUpvoteCreateManyUserInputEnvelope
  connect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
}

export type IssueUpvoteUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutUserInput, Prisma.IssueUpvoteUncheckedCreateWithoutUserInput> | Prisma.IssueUpvoteCreateWithoutUserInput[] | Prisma.IssueUpvoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueUpvoteCreateOrConnectWithoutUserInput | Prisma.IssueUpvoteCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.IssueUpvoteCreateManyUserInputEnvelope
  connect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
}

export type IssueUpvoteUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutUserInput, Prisma.IssueUpvoteUncheckedCreateWithoutUserInput> | Prisma.IssueUpvoteCreateWithoutUserInput[] | Prisma.IssueUpvoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueUpvoteCreateOrConnectWithoutUserInput | Prisma.IssueUpvoteCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.IssueUpvoteUpsertWithWhereUniqueWithoutUserInput | Prisma.IssueUpvoteUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.IssueUpvoteCreateManyUserInputEnvelope
  set?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  disconnect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  delete?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  connect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  update?: Prisma.IssueUpvoteUpdateWithWhereUniqueWithoutUserInput | Prisma.IssueUpvoteUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.IssueUpvoteUpdateManyWithWhereWithoutUserInput | Prisma.IssueUpvoteUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.IssueUpvoteScalarWhereInput | Prisma.IssueUpvoteScalarWhereInput[]
}

export type IssueUpvoteUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutUserInput, Prisma.IssueUpvoteUncheckedCreateWithoutUserInput> | Prisma.IssueUpvoteCreateWithoutUserInput[] | Prisma.IssueUpvoteUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.IssueUpvoteCreateOrConnectWithoutUserInput | Prisma.IssueUpvoteCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.IssueUpvoteUpsertWithWhereUniqueWithoutUserInput | Prisma.IssueUpvoteUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.IssueUpvoteCreateManyUserInputEnvelope
  set?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  disconnect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  delete?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  connect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  update?: Prisma.IssueUpvoteUpdateWithWhereUniqueWithoutUserInput | Prisma.IssueUpvoteUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.IssueUpvoteUpdateManyWithWhereWithoutUserInput | Prisma.IssueUpvoteUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.IssueUpvoteScalarWhereInput | Prisma.IssueUpvoteScalarWhereInput[]
}

export type IssueUpvoteCreateNestedManyWithoutIssueInput = {
  create?: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutIssueInput, Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput> | Prisma.IssueUpvoteCreateWithoutIssueInput[] | Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.IssueUpvoteCreateOrConnectWithoutIssueInput | Prisma.IssueUpvoteCreateOrConnectWithoutIssueInput[]
  createMany?: Prisma.IssueUpvoteCreateManyIssueInputEnvelope
  connect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
}

export type IssueUpvoteUncheckedCreateNestedManyWithoutIssueInput = {
  create?: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutIssueInput, Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput> | Prisma.IssueUpvoteCreateWithoutIssueInput[] | Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.IssueUpvoteCreateOrConnectWithoutIssueInput | Prisma.IssueUpvoteCreateOrConnectWithoutIssueInput[]
  createMany?: Prisma.IssueUpvoteCreateManyIssueInputEnvelope
  connect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
}

export type IssueUpvoteUpdateManyWithoutIssueNestedInput = {
  create?: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutIssueInput, Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput> | Prisma.IssueUpvoteCreateWithoutIssueInput[] | Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.IssueUpvoteCreateOrConnectWithoutIssueInput | Prisma.IssueUpvoteCreateOrConnectWithoutIssueInput[]
  upsert?: Prisma.IssueUpvoteUpsertWithWhereUniqueWithoutIssueInput | Prisma.IssueUpvoteUpsertWithWhereUniqueWithoutIssueInput[]
  createMany?: Prisma.IssueUpvoteCreateManyIssueInputEnvelope
  set?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  disconnect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  delete?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  connect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  update?: Prisma.IssueUpvoteUpdateWithWhereUniqueWithoutIssueInput | Prisma.IssueUpvoteUpdateWithWhereUniqueWithoutIssueInput[]
  updateMany?: Prisma.IssueUpvoteUpdateManyWithWhereWithoutIssueInput | Prisma.IssueUpvoteUpdateManyWithWhereWithoutIssueInput[]
  deleteMany?: Prisma.IssueUpvoteScalarWhereInput | Prisma.IssueUpvoteScalarWhereInput[]
}

export type IssueUpvoteUncheckedUpdateManyWithoutIssueNestedInput = {
  create?: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutIssueInput, Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput> | Prisma.IssueUpvoteCreateWithoutIssueInput[] | Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput[]
  connectOrCreate?: Prisma.IssueUpvoteCreateOrConnectWithoutIssueInput | Prisma.IssueUpvoteCreateOrConnectWithoutIssueInput[]
  upsert?: Prisma.IssueUpvoteUpsertWithWhereUniqueWithoutIssueInput | Prisma.IssueUpvoteUpsertWithWhereUniqueWithoutIssueInput[]
  createMany?: Prisma.IssueUpvoteCreateManyIssueInputEnvelope
  set?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  disconnect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  delete?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  connect?: Prisma.IssueUpvoteWhereUniqueInput | Prisma.IssueUpvoteWhereUniqueInput[]
  update?: Prisma.IssueUpvoteUpdateWithWhereUniqueWithoutIssueInput | Prisma.IssueUpvoteUpdateWithWhereUniqueWithoutIssueInput[]
  updateMany?: Prisma.IssueUpvoteUpdateManyWithWhereWithoutIssueInput | Prisma.IssueUpvoteUpdateManyWithWhereWithoutIssueInput[]
  deleteMany?: Prisma.IssueUpvoteScalarWhereInput | Prisma.IssueUpvoteScalarWhereInput[]
}

export type IssueUpvoteCreateWithoutUserInput = {
  createdAt?: Date | string
  issue: Prisma.IssueCreateNestedOneWithoutUpvotesInput
}

export type IssueUpvoteUncheckedCreateWithoutUserInput = {
  id?: number
  createdAt?: Date | string
  issueId: number
}

export type IssueUpvoteCreateOrConnectWithoutUserInput = {
  where: Prisma.IssueUpvoteWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutUserInput, Prisma.IssueUpvoteUncheckedCreateWithoutUserInput>
}

export type IssueUpvoteCreateManyUserInputEnvelope = {
  data: Prisma.IssueUpvoteCreateManyUserInput | Prisma.IssueUpvoteCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type IssueUpvoteUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.IssueUpvoteWhereUniqueInput
  update: Prisma.XOR<Prisma.IssueUpvoteUpdateWithoutUserInput, Prisma.IssueUpvoteUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutUserInput, Prisma.IssueUpvoteUncheckedCreateWithoutUserInput>
}

export type IssueUpvoteUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.IssueUpvoteWhereUniqueInput
  data: Prisma.XOR<Prisma.IssueUpvoteUpdateWithoutUserInput, Prisma.IssueUpvoteUncheckedUpdateWithoutUserInput>
}

export type IssueUpvoteUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.IssueUpvoteScalarWhereInput
  data: Prisma.XOR<Prisma.IssueUpvoteUpdateManyMutationInput, Prisma.IssueUpvoteUncheckedUpdateManyWithoutUserInput>
}

export type IssueUpvoteScalarWhereInput = {
  AND?: Prisma.IssueUpvoteScalarWhereInput | Prisma.IssueUpvoteScalarWhereInput[]
  OR?: Prisma.IssueUpvoteScalarWhereInput[]
  NOT?: Prisma.IssueUpvoteScalarWhereInput | Prisma.IssueUpvoteScalarWhereInput[]
  id?: Prisma.IntFilter<"IssueUpvote"> | number
  createdAt?: Prisma.DateTimeFilter<"IssueUpvote"> | Date | string
  issueId?: Prisma.IntFilter<"IssueUpvote"> | number
  userId?: Prisma.IntFilter<"IssueUpvote"> | number
}

export type IssueUpvoteCreateWithoutIssueInput = {
  createdAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutIssueUpvotesInput
}

export type IssueUpvoteUncheckedCreateWithoutIssueInput = {
  id?: number
  createdAt?: Date | string
  userId: number
}

export type IssueUpvoteCreateOrConnectWithoutIssueInput = {
  where: Prisma.IssueUpvoteWhereUniqueInput
  create: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutIssueInput, Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput>
}

export type IssueUpvoteCreateManyIssueInputEnvelope = {
  data: Prisma.IssueUpvoteCreateManyIssueInput | Prisma.IssueUpvoteCreateManyIssueInput[]
  skipDuplicates?: boolean
}

export type IssueUpvoteUpsertWithWhereUniqueWithoutIssueInput = {
  where: Prisma.IssueUpvoteWhereUniqueInput
  update: Prisma.XOR<Prisma.IssueUpvoteUpdateWithoutIssueInput, Prisma.IssueUpvoteUncheckedUpdateWithoutIssueInput>
  create: Prisma.XOR<Prisma.IssueUpvoteCreateWithoutIssueInput, Prisma.IssueUpvoteUncheckedCreateWithoutIssueInput>
}

export type IssueUpvoteUpdateWithWhereUniqueWithoutIssueInput = {
  where: Prisma.IssueUpvoteWhereUniqueInput
  data: Prisma.XOR<Prisma.IssueUpvoteUpdateWithoutIssueInput, Prisma.IssueUpvoteUncheckedUpdateWithoutIssueInput>
}

export type IssueUpvoteUpdateManyWithWhereWithoutIssueInput = {
  where: Prisma.IssueUpvoteScalarWhereInput
  data: Prisma.XOR<Prisma.IssueUpvoteUpdateManyMutationInput, Prisma.IssueUpvoteUncheckedUpdateManyWithoutIssueInput>
}

export type IssueUpvoteCreateManyUserInput = {
  id?: number
  createdAt?: Date | string
  issueId: number
}

export type IssueUpvoteUpdateWithoutUserInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issue?: Prisma.IssueUpdateOneRequiredWithoutUpvotesNestedInput
}

export type IssueUpvoteUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueUpvoteUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  issueId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueUpvoteCreateManyIssueInput = {
  id?: number
  createdAt?: Date | string
  userId: number
}

export type IssueUpvoteUpdateWithoutIssueInput = {
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutIssueUpvotesNestedInput
}

export type IssueUpvoteUncheckedUpdateWithoutIssueInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type IssueUpvoteUncheckedUpdateManyWithoutIssueInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}



export type IssueUpvoteSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  issueId?: boolean
  userId?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["issueUpvote"]>

export type IssueUpvoteSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  issueId?: boolean
  userId?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["issueUpvote"]>

export type IssueUpvoteSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  createdAt?: boolean
  issueId?: boolean
  userId?: boolean
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["issueUpvote"]>

export type IssueUpvoteSelectScalar = {
  id?: boolean
  createdAt?: boolean
  issueId?: boolean
  userId?: boolean
}

export type IssueUpvoteOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "createdAt" | "issueId" | "userId", ExtArgs["result"]["issueUpvote"]>
export type IssueUpvoteInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type IssueUpvoteIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type IssueUpvoteIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issue?: boolean | Prisma.IssueDefaultArgs<ExtArgs>
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $IssueUpvotePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "IssueUpvote"
  objects: {
    issue: Prisma.$IssuePayload<ExtArgs>
    user: Prisma.$UserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    createdAt: Date
    issueId: number
    userId: number
  }, ExtArgs["result"]["issueUpvote"]>
  composites: {}
}

export type IssueUpvoteGetPayload<S extends boolean | null | undefined | IssueUpvoteDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload, S>

export type IssueUpvoteCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<IssueUpvoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: IssueUpvoteCountAggregateInputType | true
  }

export interface IssueUpvoteDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IssueUpvote'], meta: { name: 'IssueUpvote' } }
  /**
   * Find zero or one IssueUpvote that matches the filter.
   * @param {IssueUpvoteFindUniqueArgs} args - Arguments to find a IssueUpvote
   * @example
   * // Get one IssueUpvote
   * const issueUpvote = await prisma.issueUpvote.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends IssueUpvoteFindUniqueArgs>(args: Prisma.SelectSubset<T, IssueUpvoteFindUniqueArgs<ExtArgs>>): Prisma.Prisma__IssueUpvoteClient<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one IssueUpvote that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {IssueUpvoteFindUniqueOrThrowArgs} args - Arguments to find a IssueUpvote
   * @example
   * // Get one IssueUpvote
   * const issueUpvote = await prisma.issueUpvote.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends IssueUpvoteFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, IssueUpvoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__IssueUpvoteClient<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first IssueUpvote that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueUpvoteFindFirstArgs} args - Arguments to find a IssueUpvote
   * @example
   * // Get one IssueUpvote
   * const issueUpvote = await prisma.issueUpvote.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends IssueUpvoteFindFirstArgs>(args?: Prisma.SelectSubset<T, IssueUpvoteFindFirstArgs<ExtArgs>>): Prisma.Prisma__IssueUpvoteClient<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first IssueUpvote that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueUpvoteFindFirstOrThrowArgs} args - Arguments to find a IssueUpvote
   * @example
   * // Get one IssueUpvote
   * const issueUpvote = await prisma.issueUpvote.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends IssueUpvoteFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, IssueUpvoteFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__IssueUpvoteClient<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more IssueUpvotes that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueUpvoteFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all IssueUpvotes
   * const issueUpvotes = await prisma.issueUpvote.findMany()
   * 
   * // Get first 10 IssueUpvotes
   * const issueUpvotes = await prisma.issueUpvote.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const issueUpvoteWithIdOnly = await prisma.issueUpvote.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends IssueUpvoteFindManyArgs>(args?: Prisma.SelectSubset<T, IssueUpvoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a IssueUpvote.
   * @param {IssueUpvoteCreateArgs} args - Arguments to create a IssueUpvote.
   * @example
   * // Create one IssueUpvote
   * const IssueUpvote = await prisma.issueUpvote.create({
   *   data: {
   *     // ... data to create a IssueUpvote
   *   }
   * })
   * 
   */
  create<T extends IssueUpvoteCreateArgs>(args: Prisma.SelectSubset<T, IssueUpvoteCreateArgs<ExtArgs>>): Prisma.Prisma__IssueUpvoteClient<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many IssueUpvotes.
   * @param {IssueUpvoteCreateManyArgs} args - Arguments to create many IssueUpvotes.
   * @example
   * // Create many IssueUpvotes
   * const issueUpvote = await prisma.issueUpvote.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends IssueUpvoteCreateManyArgs>(args?: Prisma.SelectSubset<T, IssueUpvoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many IssueUpvotes and returns the data saved in the database.
   * @param {IssueUpvoteCreateManyAndReturnArgs} args - Arguments to create many IssueUpvotes.
   * @example
   * // Create many IssueUpvotes
   * const issueUpvote = await prisma.issueUpvote.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many IssueUpvotes and only return the `id`
   * const issueUpvoteWithIdOnly = await prisma.issueUpvote.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends IssueUpvoteCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, IssueUpvoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a IssueUpvote.
   * @param {IssueUpvoteDeleteArgs} args - Arguments to delete one IssueUpvote.
   * @example
   * // Delete one IssueUpvote
   * const IssueUpvote = await prisma.issueUpvote.delete({
   *   where: {
   *     // ... filter to delete one IssueUpvote
   *   }
   * })
   * 
   */
  delete<T extends IssueUpvoteDeleteArgs>(args: Prisma.SelectSubset<T, IssueUpvoteDeleteArgs<ExtArgs>>): Prisma.Prisma__IssueUpvoteClient<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one IssueUpvote.
   * @param {IssueUpvoteUpdateArgs} args - Arguments to update one IssueUpvote.
   * @example
   * // Update one IssueUpvote
   * const issueUpvote = await prisma.issueUpvote.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends IssueUpvoteUpdateArgs>(args: Prisma.SelectSubset<T, IssueUpvoteUpdateArgs<ExtArgs>>): Prisma.Prisma__IssueUpvoteClient<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more IssueUpvotes.
   * @param {IssueUpvoteDeleteManyArgs} args - Arguments to filter IssueUpvotes to delete.
   * @example
   * // Delete a few IssueUpvotes
   * const { count } = await prisma.issueUpvote.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends IssueUpvoteDeleteManyArgs>(args?: Prisma.SelectSubset<T, IssueUpvoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more IssueUpvotes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueUpvoteUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many IssueUpvotes
   * const issueUpvote = await prisma.issueUpvote.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends IssueUpvoteUpdateManyArgs>(args: Prisma.SelectSubset<T, IssueUpvoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more IssueUpvotes and returns the data updated in the database.
   * @param {IssueUpvoteUpdateManyAndReturnArgs} args - Arguments to update many IssueUpvotes.
   * @example
   * // Update many IssueUpvotes
   * const issueUpvote = await prisma.issueUpvote.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more IssueUpvotes and only return the `id`
   * const issueUpvoteWithIdOnly = await prisma.issueUpvote.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends IssueUpvoteUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, IssueUpvoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one IssueUpvote.
   * @param {IssueUpvoteUpsertArgs} args - Arguments to update or create a IssueUpvote.
   * @example
   * // Update or create a IssueUpvote
   * const issueUpvote = await prisma.issueUpvote.upsert({
   *   create: {
   *     // ... data to create a IssueUpvote
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the IssueUpvote we want to update
   *   }
   * })
   */
  upsert<T extends IssueUpvoteUpsertArgs>(args: Prisma.SelectSubset<T, IssueUpvoteUpsertArgs<ExtArgs>>): Prisma.Prisma__IssueUpvoteClient<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of IssueUpvotes.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueUpvoteCountArgs} args - Arguments to filter IssueUpvotes to count.
   * @example
   * // Count the number of IssueUpvotes
   * const count = await prisma.issueUpvote.count({
   *   where: {
   *     // ... the filter for the IssueUpvotes we want to count
   *   }
   * })
  **/
  count<T extends IssueUpvoteCountArgs>(
    args?: Prisma.Subset<T, IssueUpvoteCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], IssueUpvoteCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a IssueUpvote.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueUpvoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends IssueUpvoteAggregateArgs>(args: Prisma.Subset<T, IssueUpvoteAggregateArgs>): Prisma.PrismaPromise<GetIssueUpvoteAggregateType<T>>

  /**
   * Group by IssueUpvote.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {IssueUpvoteGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends IssueUpvoteGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: IssueUpvoteGroupByArgs['orderBy'] }
      : { orderBy?: IssueUpvoteGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, IssueUpvoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIssueUpvoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the IssueUpvote model
 */
readonly fields: IssueUpvoteFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for IssueUpvote.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__IssueUpvoteClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  issue<T extends Prisma.IssueDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.IssueDefaultArgs<ExtArgs>>): Prisma.Prisma__IssueClient<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the IssueUpvote model
 */
export interface IssueUpvoteFieldRefs {
  readonly id: Prisma.FieldRef<"IssueUpvote", 'Int'>
  readonly createdAt: Prisma.FieldRef<"IssueUpvote", 'DateTime'>
  readonly issueId: Prisma.FieldRef<"IssueUpvote", 'Int'>
  readonly userId: Prisma.FieldRef<"IssueUpvote", 'Int'>
}
    

// Custom InputTypes
/**
 * IssueUpvote findUnique
 */
export type IssueUpvoteFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueUpvote to fetch.
   */
  where: Prisma.IssueUpvoteWhereUniqueInput
}

/**
 * IssueUpvote findUniqueOrThrow
 */
export type IssueUpvoteFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueUpvote to fetch.
   */
  where: Prisma.IssueUpvoteWhereUniqueInput
}

/**
 * IssueUpvote findFirst
 */
export type IssueUpvoteFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueUpvote to fetch.
   */
  where?: Prisma.IssueUpvoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of IssueUpvotes to fetch.
   */
  orderBy?: Prisma.IssueUpvoteOrderByWithRelationInput | Prisma.IssueUpvoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for IssueUpvotes.
   */
  cursor?: Prisma.IssueUpvoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` IssueUpvotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` IssueUpvotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of IssueUpvotes.
   */
  distinct?: Prisma.IssueUpvoteScalarFieldEnum | Prisma.IssueUpvoteScalarFieldEnum[]
}

/**
 * IssueUpvote findFirstOrThrow
 */
export type IssueUpvoteFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueUpvote to fetch.
   */
  where?: Prisma.IssueUpvoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of IssueUpvotes to fetch.
   */
  orderBy?: Prisma.IssueUpvoteOrderByWithRelationInput | Prisma.IssueUpvoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for IssueUpvotes.
   */
  cursor?: Prisma.IssueUpvoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` IssueUpvotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` IssueUpvotes.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of IssueUpvotes.
   */
  distinct?: Prisma.IssueUpvoteScalarFieldEnum | Prisma.IssueUpvoteScalarFieldEnum[]
}

/**
 * IssueUpvote findMany
 */
export type IssueUpvoteFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * Filter, which IssueUpvotes to fetch.
   */
  where?: Prisma.IssueUpvoteWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of IssueUpvotes to fetch.
   */
  orderBy?: Prisma.IssueUpvoteOrderByWithRelationInput | Prisma.IssueUpvoteOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing IssueUpvotes.
   */
  cursor?: Prisma.IssueUpvoteWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` IssueUpvotes from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` IssueUpvotes.
   */
  skip?: number
  distinct?: Prisma.IssueUpvoteScalarFieldEnum | Prisma.IssueUpvoteScalarFieldEnum[]
}

/**
 * IssueUpvote create
 */
export type IssueUpvoteCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * The data needed to create a IssueUpvote.
   */
  data: Prisma.XOR<Prisma.IssueUpvoteCreateInput, Prisma.IssueUpvoteUncheckedCreateInput>
}

/**
 * IssueUpvote createMany
 */
export type IssueUpvoteCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many IssueUpvotes.
   */
  data: Prisma.IssueUpvoteCreateManyInput | Prisma.IssueUpvoteCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * IssueUpvote createManyAndReturn
 */
export type IssueUpvoteCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * The data used to create many IssueUpvotes.
   */
  data: Prisma.IssueUpvoteCreateManyInput | Prisma.IssueUpvoteCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * IssueUpvote update
 */
export type IssueUpvoteUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * The data needed to update a IssueUpvote.
   */
  data: Prisma.XOR<Prisma.IssueUpvoteUpdateInput, Prisma.IssueUpvoteUncheckedUpdateInput>
  /**
   * Choose, which IssueUpvote to update.
   */
  where: Prisma.IssueUpvoteWhereUniqueInput
}

/**
 * IssueUpvote updateMany
 */
export type IssueUpvoteUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update IssueUpvotes.
   */
  data: Prisma.XOR<Prisma.IssueUpvoteUpdateManyMutationInput, Prisma.IssueUpvoteUncheckedUpdateManyInput>
  /**
   * Filter which IssueUpvotes to update
   */
  where?: Prisma.IssueUpvoteWhereInput
  /**
   * Limit how many IssueUpvotes to update.
   */
  limit?: number
}

/**
 * IssueUpvote updateManyAndReturn
 */
export type IssueUpvoteUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * The data used to update IssueUpvotes.
   */
  data: Prisma.XOR<Prisma.IssueUpvoteUpdateManyMutationInput, Prisma.IssueUpvoteUncheckedUpdateManyInput>
  /**
   * Filter which IssueUpvotes to update
   */
  where?: Prisma.IssueUpvoteWhereInput
  /**
   * Limit how many IssueUpvotes to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * IssueUpvote upsert
 */
export type IssueUpvoteUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * The filter to search for the IssueUpvote to update in case it exists.
   */
  where: Prisma.IssueUpvoteWhereUniqueInput
  /**
   * In case the IssueUpvote found by the `where` argument doesn't exist, create a new IssueUpvote with this data.
   */
  create: Prisma.XOR<Prisma.IssueUpvoteCreateInput, Prisma.IssueUpvoteUncheckedCreateInput>
  /**
   * In case the IssueUpvote was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.IssueUpvoteUpdateInput, Prisma.IssueUpvoteUncheckedUpdateInput>
}

/**
 * IssueUpvote delete
 */
export type IssueUpvoteDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  /**
   * Filter which IssueUpvote to delete.
   */
  where: Prisma.IssueUpvoteWhereUniqueInput
}

/**
 * IssueUpvote deleteMany
 */
export type IssueUpvoteDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which IssueUpvotes to delete
   */
  where?: Prisma.IssueUpvoteWhereInput
  /**
   * Limit how many IssueUpvotes to delete.
   */
  limit?: number
}

/**
 * IssueUpvote without action
 */
export type IssueUpvoteDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\Notification.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Notification` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Notification
 * 
 */
export type NotificationModel = runtime.Types.Result.DefaultSelection<Prisma.$NotificationPayload>

export type AggregateNotification = {
  _count: NotificationCountAggregateOutputType | null
  _avg: NotificationAvgAggregateOutputType | null
  _sum: NotificationSumAggregateOutputType | null
  _min: NotificationMinAggregateOutputType | null
  _max: NotificationMaxAggregateOutputType | null
}

export type NotificationAvgAggregateOutputType = {
  id: number | null
  userId: number | null
}

export type NotificationSumAggregateOutputType = {
  id: number | null
  userId: number | null
}

export type NotificationMinAggregateOutputType = {
  id: number | null
  type: $Enums.NotificationType | null
  message: string | null
  createdAt: Date | null
  read: boolean | null
  userId: number | null
}

export type NotificationMaxAggregateOutputType = {
  id: number | null
  type: $Enums.NotificationType | null
  message: string | null
  createdAt: Date | null
  read: boolean | null
  userId: number | null
}

export type NotificationCountAggregateOutputType = {
  id: number
  type: number
  message: number
  createdAt: number
  read: number
  userId: number
  _all: number
}


export type NotificationAvgAggregateInputType = {
  id?: true
  userId?: true
}

export type NotificationSumAggregateInputType = {
  id?: true
  userId?: true
}

export type NotificationMinAggregateInputType = {
  id?: true
  type?: true
  message?: true
  createdAt?: true
  read?: true
  userId?: true
}

export type NotificationMaxAggregateInputType = {
  id?: true
  type?: true
  message?: true
  createdAt?: true
  read?: true
  userId?: true
}

export type NotificationCountAggregateInputType = {
  id?: true
  type?: true
  message?: true
  createdAt?: true
  read?: true
  userId?: true
  _all?: true
}

export type NotificationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Notification to aggregate.
   */
  where?: Prisma.NotificationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Notifications to fetch.
   */
  orderBy?: Prisma.NotificationOrderByWithRelationInput | Prisma.NotificationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.NotificationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Notifications from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Notifications.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Notifications
  **/
  _count?: true | NotificationCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: NotificationAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: NotificationSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: NotificationMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: NotificationMaxAggregateInputType
}

export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
      [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateNotification[P]>
    : Prisma.GetScalarType<T[P], AggregateNotification[P]>
}




export type NotificationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.NotificationWhereInput
  orderBy?: Prisma.NotificationOrderByWithAggregationInput | Prisma.NotificationOrderByWithAggregationInput[]
  by: Prisma.NotificationScalarFieldEnum[] | Prisma.NotificationScalarFieldEnum
  having?: Prisma.NotificationScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: NotificationCountAggregateInputType | true
  _avg?: NotificationAvgAggregateInputType
  _sum?: NotificationSumAggregateInputType
  _min?: NotificationMinAggregateInputType
  _max?: NotificationMaxAggregateInputType
}

export type NotificationGroupByOutputType = {
  id: number
  type: $Enums.NotificationType
  message: string
  createdAt: Date
  read: boolean
  userId: number | null
  _count: NotificationCountAggregateOutputType | null
  _avg: NotificationAvgAggregateOutputType | null
  _sum: NotificationSumAggregateOutputType | null
  _min: NotificationMinAggregateOutputType | null
  _max: NotificationMaxAggregateOutputType | null
}

type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<NotificationGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], NotificationGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], NotificationGroupByOutputType[P]>
      }
    >
  >



export type NotificationWhereInput = {
  AND?: Prisma.NotificationWhereInput | Prisma.NotificationWhereInput[]
  OR?: Prisma.NotificationWhereInput[]
  NOT?: Prisma.NotificationWhereInput | Prisma.NotificationWhereInput[]
  id?: Prisma.IntFilter<"Notification"> | number
  type?: Prisma.EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
  message?: Prisma.StringFilter<"Notification"> | string
  createdAt?: Prisma.DateTimeFilter<"Notification"> | Date | string
  read?: Prisma.BoolFilter<"Notification"> | boolean
  userId?: Prisma.IntNullableFilter<"Notification"> | number | null
  user?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}

export type NotificationOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  message?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  read?: Prisma.SortOrder
  userId?: Prisma.SortOrderInput | Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
}

export type NotificationWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  AND?: Prisma.NotificationWhereInput | Prisma.NotificationWhereInput[]
  OR?: Prisma.NotificationWhereInput[]
  NOT?: Prisma.NotificationWhereInput | Prisma.NotificationWhereInput[]
  type?: Prisma.EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
  message?: Prisma.StringFilter<"Notification"> | string
  createdAt?: Prisma.DateTimeFilter<"Notification"> | Date | string
  read?: Prisma.BoolFilter<"Notification"> | boolean
  userId?: Prisma.IntNullableFilter<"Notification"> | number | null
  user?: Prisma.XOR<Prisma.UserNullableScalarRelationFilter, Prisma.UserWhereInput> | null
}, "id">

export type NotificationOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  message?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  read?: Prisma.SortOrder
  userId?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.NotificationCountOrderByAggregateInput
  _avg?: Prisma.NotificationAvgOrderByAggregateInput
  _max?: Prisma.NotificationMaxOrderByAggregateInput
  _min?: Prisma.NotificationMinOrderByAggregateInput
  _sum?: Prisma.NotificationSumOrderByAggregateInput
}

export type NotificationScalarWhereWithAggregatesInput = {
  AND?: Prisma.NotificationScalarWhereWithAggregatesInput | Prisma.NotificationScalarWhereWithAggregatesInput[]
  OR?: Prisma.NotificationScalarWhereWithAggregatesInput[]
  NOT?: Prisma.NotificationScalarWhereWithAggregatesInput | Prisma.NotificationScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"Notification"> | number
  type?: Prisma.EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
  message?: Prisma.StringWithAggregatesFilter<"Notification"> | string
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Notification"> | Date | string
  read?: Prisma.BoolWithAggregatesFilter<"Notification"> | boolean
  userId?: Prisma.IntNullableWithAggregatesFilter<"Notification"> | number | null
}

export type NotificationCreateInput = {
  type?: $Enums.NotificationType
  message: string
  createdAt?: Date | string
  read?: boolean
  user?: Prisma.UserCreateNestedOneWithoutNotificationsInput
}

export type NotificationUncheckedCreateInput = {
  id?: number
  type?: $Enums.NotificationType
  message: string
  createdAt?: Date | string
  read?: boolean
  userId?: number | null
}

export type NotificationUpdateInput = {
  type?: Prisma.EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  message?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  read?: Prisma.BoolFieldUpdateOperationsInput | boolean
  user?: Prisma.UserUpdateOneWithoutNotificationsNestedInput
}

export type NotificationUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  type?: Prisma.EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  message?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  read?: Prisma.BoolFieldUpdateOperationsInput | boolean
  userId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type NotificationCreateManyInput = {
  id?: number
  type?: $Enums.NotificationType
  message: string
  createdAt?: Date | string
  read?: boolean
  userId?: number | null
}

export type NotificationUpdateManyMutationInput = {
  type?: Prisma.EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  message?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  read?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type NotificationUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  type?: Prisma.EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  message?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  read?: Prisma.BoolFieldUpdateOperationsInput | boolean
  userId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null
}

export type NotificationListRelationFilter = {
  every?: Prisma.NotificationWhereInput
  some?: Prisma.NotificationWhereInput
  none?: Prisma.NotificationWhereInput
}

export type NotificationOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type NotificationCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  message?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  read?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type NotificationAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type NotificationMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  message?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  read?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type NotificationMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  type?: Prisma.SortOrder
  message?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  read?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type NotificationSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type NotificationCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.NotificationCreateWithoutUserInput, Prisma.NotificationUncheckedCreateWithoutUserInput> | Prisma.NotificationCreateWithoutUserInput[] | Prisma.NotificationUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.NotificationCreateOrConnectWithoutUserInput | Prisma.NotificationCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.NotificationCreateManyUserInputEnvelope
  connect?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
}

export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.NotificationCreateWithoutUserInput, Prisma.NotificationUncheckedCreateWithoutUserInput> | Prisma.NotificationCreateWithoutUserInput[] | Prisma.NotificationUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.NotificationCreateOrConnectWithoutUserInput | Prisma.NotificationCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.NotificationCreateManyUserInputEnvelope
  connect?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
}

export type NotificationUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.NotificationCreateWithoutUserInput, Prisma.NotificationUncheckedCreateWithoutUserInput> | Prisma.NotificationCreateWithoutUserInput[] | Prisma.NotificationUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.NotificationCreateOrConnectWithoutUserInput | Prisma.NotificationCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.NotificationUpsertWithWhereUniqueWithoutUserInput | Prisma.NotificationUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.NotificationCreateManyUserInputEnvelope
  set?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
  disconnect?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
  delete?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
  connect?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
  update?: Prisma.NotificationUpdateWithWhereUniqueWithoutUserInput | Prisma.NotificationUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.NotificationUpdateManyWithWhereWithoutUserInput | Prisma.NotificationUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.NotificationScalarWhereInput | Prisma.NotificationScalarWhereInput[]
}

export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.NotificationCreateWithoutUserInput, Prisma.NotificationUncheckedCreateWithoutUserInput> | Prisma.NotificationCreateWithoutUserInput[] | Prisma.NotificationUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.NotificationCreateOrConnectWithoutUserInput | Prisma.NotificationCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.NotificationUpsertWithWhereUniqueWithoutUserInput | Prisma.NotificationUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.NotificationCreateManyUserInputEnvelope
  set?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
  disconnect?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
  delete?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
  connect?: Prisma.NotificationWhereUniqueInput | Prisma.NotificationWhereUniqueInput[]
  update?: Prisma.NotificationUpdateWithWhereUniqueWithoutUserInput | Prisma.NotificationUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.NotificationUpdateManyWithWhereWithoutUserInput | Prisma.NotificationUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.NotificationScalarWhereInput | Prisma.NotificationScalarWhereInput[]
}

export type EnumNotificationTypeFieldUpdateOperationsInput = {
  set?: $Enums.NotificationType
}

export type NotificationCreateWithoutUserInput = {
  type?: $Enums.NotificationType
  message: string
  createdAt?: Date | string
  read?: boolean
}

export type NotificationUncheckedCreateWithoutUserInput = {
  id?: number
  type?: $Enums.NotificationType
  message: string
  createdAt?: Date | string
  read?: boolean
}

export type NotificationCreateOrConnectWithoutUserInput = {
  where: Prisma.NotificationWhereUniqueInput
  create: Prisma.XOR<Prisma.NotificationCreateWithoutUserInput, Prisma.NotificationUncheckedCreateWithoutUserInput>
}

export type NotificationCreateManyUserInputEnvelope = {
  data: Prisma.NotificationCreateManyUserInput | Prisma.NotificationCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.NotificationWhereUniqueInput
  update: Prisma.XOR<Prisma.NotificationUpdateWithoutUserInput, Prisma.NotificationUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.NotificationCreateWithoutUserInput, Prisma.NotificationUncheckedCreateWithoutUserInput>
}

export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.NotificationWhereUniqueInput
  data: Prisma.XOR<Prisma.NotificationUpdateWithoutUserInput, Prisma.NotificationUncheckedUpdateWithoutUserInput>
}

export type NotificationUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.NotificationScalarWhereInput
  data: Prisma.XOR<Prisma.NotificationUpdateManyMutationInput, Prisma.NotificationUncheckedUpdateManyWithoutUserInput>
}

export type NotificationScalarWhereInput = {
  AND?: Prisma.NotificationScalarWhereInput | Prisma.NotificationScalarWhereInput[]
  OR?: Prisma.NotificationScalarWhereInput[]
  NOT?: Prisma.NotificationScalarWhereInput | Prisma.NotificationScalarWhereInput[]
  id?: Prisma.IntFilter<"Notification"> | number
  type?: Prisma.EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
  message?: Prisma.StringFilter<"Notification"> | string
  createdAt?: Prisma.DateTimeFilter<"Notification"> | Date | string
  read?: Prisma.BoolFilter<"Notification"> | boolean
  userId?: Prisma.IntNullableFilter<"Notification"> | number | null
}

export type NotificationCreateManyUserInput = {
  id?: number
  type?: $Enums.NotificationType
  message: string
  createdAt?: Date | string
  read?: boolean
}

export type NotificationUpdateWithoutUserInput = {
  type?: Prisma.EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  message?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  read?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type NotificationUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  type?: Prisma.EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  message?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  read?: Prisma.BoolFieldUpdateOperationsInput | boolean
}

export type NotificationUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  type?: Prisma.EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
  message?: Prisma.StringFieldUpdateOperationsInput | string
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  read?: Prisma.BoolFieldUpdateOperationsInput | boolean
}



export type NotificationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  type?: boolean
  message?: boolean
  createdAt?: boolean
  read?: boolean
  userId?: boolean
  user?: boolean | Prisma.Notification$userArgs<ExtArgs>
}, ExtArgs["result"]["notification"]>

export type NotificationSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  type?: boolean
  message?: boolean
  createdAt?: boolean
  read?: boolean
  userId?: boolean
  user?: boolean | Prisma.Notification$userArgs<ExtArgs>
}, ExtArgs["result"]["notification"]>

export type NotificationSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  type?: boolean
  message?: boolean
  createdAt?: boolean
  read?: boolean
  userId?: boolean
  user?: boolean | Prisma.Notification$userArgs<ExtArgs>
}, ExtArgs["result"]["notification"]>

export type NotificationSelectScalar = {
  id?: boolean
  type?: boolean
  message?: boolean
  createdAt?: boolean
  read?: boolean
  userId?: boolean
}

export type NotificationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "type" | "message" | "createdAt" | "read" | "userId", ExtArgs["result"]["notification"]>
export type NotificationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.Notification$userArgs<ExtArgs>
}
export type NotificationIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.Notification$userArgs<ExtArgs>
}
export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.Notification$userArgs<ExtArgs>
}

export type $NotificationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Notification"
  objects: {
    user: Prisma.$UserPayload<ExtArgs> | null
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    type: $Enums.NotificationType
    message: string
    createdAt: Date
    read: boolean
    userId: number | null
  }, ExtArgs["result"]["notification"]>
  composites: {}
}

export type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$NotificationPayload, S>

export type NotificationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: NotificationCountAggregateInputType | true
  }

export interface NotificationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
  /**
   * Find zero or one Notification that matches the filter.
   * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
   * @example
   * // Get one Notification
   * const notification = await prisma.notification.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends NotificationFindUniqueArgs>(args: Prisma.SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma.Prisma__NotificationClient<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
   * @example
   * // Get one Notification
   * const notification = await prisma.notification.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__NotificationClient<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Notification that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
   * @example
   * // Get one Notification
   * const notification = await prisma.notification.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends NotificationFindFirstArgs>(args?: Prisma.SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma.Prisma__NotificationClient<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Notification that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
   * @example
   * // Get one Notification
   * const notification = await prisma.notification.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__NotificationClient<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Notifications that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Notifications
   * const notifications = await prisma.notification.findMany()
   * 
   * // Get first 10 Notifications
   * const notifications = await prisma.notification.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends NotificationFindManyArgs>(args?: Prisma.SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Notification.
   * @param {NotificationCreateArgs} args - Arguments to create a Notification.
   * @example
   * // Create one Notification
   * const Notification = await prisma.notification.create({
   *   data: {
   *     // ... data to create a Notification
   *   }
   * })
   * 
   */
  create<T extends NotificationCreateArgs>(args: Prisma.SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma.Prisma__NotificationClient<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Notifications.
   * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
   * @example
   * // Create many Notifications
   * const notification = await prisma.notification.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends NotificationCreateManyArgs>(args?: Prisma.SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Notifications and returns the data saved in the database.
   * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
   * @example
   * // Create many Notifications
   * const notification = await prisma.notification.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Notifications and only return the `id`
   * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a Notification.
   * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
   * @example
   * // Delete one Notification
   * const Notification = await prisma.notification.delete({
   *   where: {
   *     // ... filter to delete one Notification
   *   }
   * })
   * 
   */
  delete<T extends NotificationDeleteArgs>(args: Prisma.SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma.Prisma__NotificationClient<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Notification.
   * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
   * @example
   * // Update one Notification
   * const notification = await prisma.notification.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends NotificationUpdateArgs>(args: Prisma.SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma.Prisma__NotificationClient<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Notifications.
   * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
   * @example
   * // Delete a few Notifications
   * const { count } = await prisma.notification.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends NotificationDeleteManyArgs>(args?: Prisma.SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Notifications.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Notifications
   * const notification = await prisma.notification.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends NotificationUpdateManyArgs>(args: Prisma.SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Notifications and returns the data updated in the database.
   * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
   * @example
   * // Update many Notifications
   * const notification = await prisma.notification.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Notifications and only return the `id`
   * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one Notification.
   * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
   * @example
   * // Update or create a Notification
   * const notification = await prisma.notification.upsert({
   *   create: {
   *     // ... data to create a Notification
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Notification we want to update
   *   }
   * })
   */
  upsert<T extends NotificationUpsertArgs>(args: Prisma.SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma.Prisma__NotificationClient<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Notifications.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
   * @example
   * // Count the number of Notifications
   * const count = await prisma.notification.count({
   *   where: {
   *     // ... the filter for the Notifications we want to count
   *   }
   * })
  **/
  count<T extends NotificationCountArgs>(
    args?: Prisma.Subset<T, NotificationCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], NotificationCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Notification.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends NotificationAggregateArgs>(args: Prisma.Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

  /**
   * Group by Notification.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {NotificationGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends NotificationGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: NotificationGroupByArgs['orderBy'] }
      : { orderBy?: NotificationGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Notification model
 */
readonly fields: NotificationFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Notification.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.Notification$userArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.Notification$userArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Notification model
 */
export interface NotificationFieldRefs {
  readonly id: Prisma.FieldRef<"Notification", 'Int'>
  readonly type: Prisma.FieldRef<"Notification", 'NotificationType'>
  readonly message: Prisma.FieldRef<"Notification", 'String'>
  readonly createdAt: Prisma.FieldRef<"Notification", 'DateTime'>
  readonly read: Prisma.FieldRef<"Notification", 'Boolean'>
  readonly userId: Prisma.FieldRef<"Notification", 'Int'>
}
    

// Custom InputTypes
/**
 * Notification findUnique
 */
export type NotificationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * Filter, which Notification to fetch.
   */
  where: Prisma.NotificationWhereUniqueInput
}

/**
 * Notification findUniqueOrThrow
 */
export type NotificationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * Filter, which Notification to fetch.
   */
  where: Prisma.NotificationWhereUniqueInput
}

/**
 * Notification findFirst
 */
export type NotificationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * Filter, which Notification to fetch.
   */
  where?: Prisma.NotificationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Notifications to fetch.
   */
  orderBy?: Prisma.NotificationOrderByWithRelationInput | Prisma.NotificationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Notifications.
   */
  cursor?: Prisma.NotificationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Notifications from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Notifications.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Notifications.
   */
  distinct?: Prisma.NotificationScalarFieldEnum | Prisma.NotificationScalarFieldEnum[]
}

/**
 * Notification findFirstOrThrow
 */
export type NotificationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * Filter, which Notification to fetch.
   */
  where?: Prisma.NotificationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Notifications to fetch.
   */
  orderBy?: Prisma.NotificationOrderByWithRelationInput | Prisma.NotificationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Notifications.
   */
  cursor?: Prisma.NotificationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Notifications from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Notifications.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Notifications.
   */
  distinct?: Prisma.NotificationScalarFieldEnum | Prisma.NotificationScalarFieldEnum[]
}

/**
 * Notification findMany
 */
export type NotificationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * Filter, which Notifications to fetch.
   */
  where?: Prisma.NotificationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Notifications to fetch.
   */
  orderBy?: Prisma.NotificationOrderByWithRelationInput | Prisma.NotificationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Notifications.
   */
  cursor?: Prisma.NotificationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Notifications from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Notifications.
   */
  skip?: number
  distinct?: Prisma.NotificationScalarFieldEnum | Prisma.NotificationScalarFieldEnum[]
}

/**
 * Notification create
 */
export type NotificationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * The data needed to create a Notification.
   */
  data: Prisma.XOR<Prisma.NotificationCreateInput, Prisma.NotificationUncheckedCreateInput>
}

/**
 * Notification createMany
 */
export type NotificationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Notifications.
   */
  data: Prisma.NotificationCreateManyInput | Prisma.NotificationCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Notification createManyAndReturn
 */
export type NotificationCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * The data used to create many Notifications.
   */
  data: Prisma.NotificationCreateManyInput | Prisma.NotificationCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * Notification update
 */
export type NotificationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * The data needed to update a Notification.
   */
  data: Prisma.XOR<Prisma.NotificationUpdateInput, Prisma.NotificationUncheckedUpdateInput>
  /**
   * Choose, which Notification to update.
   */
  where: Prisma.NotificationWhereUniqueInput
}

/**
 * Notification updateMany
 */
export type NotificationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Notifications.
   */
  data: Prisma.XOR<Prisma.NotificationUpdateManyMutationInput, Prisma.NotificationUncheckedUpdateManyInput>
  /**
   * Filter which Notifications to update
   */
  where?: Prisma.NotificationWhereInput
  /**
   * Limit how many Notifications to update.
   */
  limit?: number
}

/**
 * Notification updateManyAndReturn
 */
export type NotificationUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * The data used to update Notifications.
   */
  data: Prisma.XOR<Prisma.NotificationUpdateManyMutationInput, Prisma.NotificationUncheckedUpdateManyInput>
  /**
   * Filter which Notifications to update
   */
  where?: Prisma.NotificationWhereInput
  /**
   * Limit how many Notifications to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * Notification upsert
 */
export type NotificationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * The filter to search for the Notification to update in case it exists.
   */
  where: Prisma.NotificationWhereUniqueInput
  /**
   * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
   */
  create: Prisma.XOR<Prisma.NotificationCreateInput, Prisma.NotificationUncheckedCreateInput>
  /**
   * In case the Notification was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.NotificationUpdateInput, Prisma.NotificationUncheckedUpdateInput>
}

/**
 * Notification delete
 */
export type NotificationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  /**
   * Filter which Notification to delete.
   */
  where: Prisma.NotificationWhereUniqueInput
}

/**
 * Notification deleteMany
 */
export type NotificationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Notifications to delete
   */
  where?: Prisma.NotificationWhereInput
  /**
   * Limit how many Notifications to delete.
   */
  limit?: number
}

/**
 * Notification.user
 */
export type Notification$userArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  where?: Prisma.UserWhereInput
}

/**
 * Notification without action
 */
export type NotificationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\User.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `User` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model User
 * 
 */
export type UserModel = runtime.Types.Result.DefaultSelection<Prisma.$UserPayload>

export type AggregateUser = {
  _count: UserCountAggregateOutputType | null
  _avg: UserAvgAggregateOutputType | null
  _sum: UserSumAggregateOutputType | null
  _min: UserMinAggregateOutputType | null
  _max: UserMaxAggregateOutputType | null
}

export type UserAvgAggregateOutputType = {
  id: number | null
  credibility: number | null
}

export type UserSumAggregateOutputType = {
  id: number | null
  credibility: number | null
}

export type UserMinAggregateOutputType = {
  id: number | null
  email: string | null
  emailVerified: boolean | null
  password: string | null
  name: string | null
  picture: string | null
  createdAt: Date | null
  role: $Enums.UserRole | null
  isBanned: boolean | null
  banExpiresAt: Date | null
  banReason: string | null
  credibility: number | null
}

export type UserMaxAggregateOutputType = {
  id: number | null
  email: string | null
  emailVerified: boolean | null
  password: string | null
  name: string | null
  picture: string | null
  createdAt: Date | null
  role: $Enums.UserRole | null
  isBanned: boolean | null
  banExpiresAt: Date | null
  banReason: string | null
  credibility: number | null
}

export type UserCountAggregateOutputType = {
  id: number
  email: number
  emailVerified: number
  password: number
  name: number
  picture: number
  createdAt: number
  role: number
  isBanned: number
  banExpiresAt: number
  banReason: number
  credibility: number
  _all: number
}


export type UserAvgAggregateInputType = {
  id?: true
  credibility?: true
}

export type UserSumAggregateInputType = {
  id?: true
  credibility?: true
}

export type UserMinAggregateInputType = {
  id?: true
  email?: true
  emailVerified?: true
  password?: true
  name?: true
  picture?: true
  createdAt?: true
  role?: true
  isBanned?: true
  banExpiresAt?: true
  banReason?: true
  credibility?: true
}

export type UserMaxAggregateInputType = {
  id?: true
  email?: true
  emailVerified?: true
  password?: true
  name?: true
  picture?: true
  createdAt?: true
  role?: true
  isBanned?: true
  banExpiresAt?: true
  banReason?: true
  credibility?: true
}

export type UserCountAggregateInputType = {
  id?: true
  email?: true
  emailVerified?: true
  password?: true
  name?: true
  picture?: true
  createdAt?: true
  role?: true
  isBanned?: true
  banExpiresAt?: true
  banReason?: true
  credibility?: true
  _all?: true
}

export type UserAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which User to aggregate.
   */
  where?: Prisma.UserWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Users to fetch.
   */
  orderBy?: Prisma.UserOrderByWithRelationInput | Prisma.UserOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.UserWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Users from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Users.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Users
  **/
  _count?: true | UserCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: UserAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: UserSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: UserMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: UserMaxAggregateInputType
}

export type GetUserAggregateType<T extends UserAggregateArgs> = {
      [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateUser[P]>
    : Prisma.GetScalarType<T[P], AggregateUser[P]>
}




export type UserGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.UserWhereInput
  orderBy?: Prisma.UserOrderByWithAggregationInput | Prisma.UserOrderByWithAggregationInput[]
  by: Prisma.UserScalarFieldEnum[] | Prisma.UserScalarFieldEnum
  having?: Prisma.UserScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: UserCountAggregateInputType | true
  _avg?: UserAvgAggregateInputType
  _sum?: UserSumAggregateInputType
  _min?: UserMinAggregateInputType
  _max?: UserMaxAggregateInputType
}

export type UserGroupByOutputType = {
  id: number
  email: string
  emailVerified: boolean
  password: string
  name: string | null
  picture: string | null
  createdAt: Date
  role: $Enums.UserRole
  isBanned: boolean
  banExpiresAt: Date | null
  banReason: string | null
  credibility: number
  _count: UserCountAggregateOutputType | null
  _avg: UserAvgAggregateOutputType | null
  _sum: UserSumAggregateOutputType | null
  _min: UserMinAggregateOutputType | null
  _max: UserMaxAggregateOutputType | null
}

type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<UserGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], UserGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], UserGroupByOutputType[P]>
      }
    >
  >



export type UserWhereInput = {
  AND?: Prisma.UserWhereInput | Prisma.UserWhereInput[]
  OR?: Prisma.UserWhereInput[]
  NOT?: Prisma.UserWhereInput | Prisma.UserWhereInput[]
  id?: Prisma.IntFilter<"User"> | number
  email?: Prisma.StringFilter<"User"> | string
  emailVerified?: Prisma.BoolFilter<"User"> | boolean
  password?: Prisma.StringFilter<"User"> | string
  name?: Prisma.StringNullableFilter<"User"> | string | null
  picture?: Prisma.StringNullableFilter<"User"> | string | null
  createdAt?: Prisma.DateTimeFilter<"User"> | Date | string
  role?: Prisma.EnumUserRoleFilter<"User"> | $Enums.UserRole
  isBanned?: Prisma.BoolFilter<"User"> | boolean
  banExpiresAt?: Prisma.DateTimeNullableFilter<"User"> | Date | string | null
  banReason?: Prisma.StringNullableFilter<"User"> | string | null
  credibility?: Prisma.IntFilter<"User"> | number
  issues?: Prisma.IssueListRelationFilter
  comments?: Prisma.CommentListRelationFilter
  commentUpvotes?: Prisma.CommentUpvoteListRelationFilter
  issueUpvotes?: Prisma.IssueUpvoteListRelationFilter
  resolutionVotes?: Prisma.IssueResolutionVoteListRelationFilter
  badges?: Prisma.UserBadgeListRelationFilter
  notifications?: Prisma.NotificationListRelationFilter
}

export type UserOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  email?: Prisma.SortOrder
  emailVerified?: Prisma.SortOrder
  password?: Prisma.SortOrder
  name?: Prisma.SortOrderInput | Prisma.SortOrder
  picture?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  role?: Prisma.SortOrder
  isBanned?: Prisma.SortOrder
  banExpiresAt?: Prisma.SortOrderInput | Prisma.SortOrder
  banReason?: Prisma.SortOrderInput | Prisma.SortOrder
  credibility?: Prisma.SortOrder
  issues?: Prisma.IssueOrderByRelationAggregateInput
  comments?: Prisma.CommentOrderByRelationAggregateInput
  commentUpvotes?: Prisma.CommentUpvoteOrderByRelationAggregateInput
  issueUpvotes?: Prisma.IssueUpvoteOrderByRelationAggregateInput
  resolutionVotes?: Prisma.IssueResolutionVoteOrderByRelationAggregateInput
  badges?: Prisma.UserBadgeOrderByRelationAggregateInput
  notifications?: Prisma.NotificationOrderByRelationAggregateInput
}

export type UserWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  email?: string
  AND?: Prisma.UserWhereInput | Prisma.UserWhereInput[]
  OR?: Prisma.UserWhereInput[]
  NOT?: Prisma.UserWhereInput | Prisma.UserWhereInput[]
  emailVerified?: Prisma.BoolFilter<"User"> | boolean
  password?: Prisma.StringFilter<"User"> | string
  name?: Prisma.StringNullableFilter<"User"> | string | null
  picture?: Prisma.StringNullableFilter<"User"> | string | null
  createdAt?: Prisma.DateTimeFilter<"User"> | Date | string
  role?: Prisma.EnumUserRoleFilter<"User"> | $Enums.UserRole
  isBanned?: Prisma.BoolFilter<"User"> | boolean
  banExpiresAt?: Prisma.DateTimeNullableFilter<"User"> | Date | string | null
  banReason?: Prisma.StringNullableFilter<"User"> | string | null
  credibility?: Prisma.IntFilter<"User"> | number
  issues?: Prisma.IssueListRelationFilter
  comments?: Prisma.CommentListRelationFilter
  commentUpvotes?: Prisma.CommentUpvoteListRelationFilter
  issueUpvotes?: Prisma.IssueUpvoteListRelationFilter
  resolutionVotes?: Prisma.IssueResolutionVoteListRelationFilter
  badges?: Prisma.UserBadgeListRelationFilter
  notifications?: Prisma.NotificationListRelationFilter
}, "id" | "email">

export type UserOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  email?: Prisma.SortOrder
  emailVerified?: Prisma.SortOrder
  password?: Prisma.SortOrder
  name?: Prisma.SortOrderInput | Prisma.SortOrder
  picture?: Prisma.SortOrderInput | Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  role?: Prisma.SortOrder
  isBanned?: Prisma.SortOrder
  banExpiresAt?: Prisma.SortOrderInput | Prisma.SortOrder
  banReason?: Prisma.SortOrderInput | Prisma.SortOrder
  credibility?: Prisma.SortOrder
  _count?: Prisma.UserCountOrderByAggregateInput
  _avg?: Prisma.UserAvgOrderByAggregateInput
  _max?: Prisma.UserMaxOrderByAggregateInput
  _min?: Prisma.UserMinOrderByAggregateInput
  _sum?: Prisma.UserSumOrderByAggregateInput
}

export type UserScalarWhereWithAggregatesInput = {
  AND?: Prisma.UserScalarWhereWithAggregatesInput | Prisma.UserScalarWhereWithAggregatesInput[]
  OR?: Prisma.UserScalarWhereWithAggregatesInput[]
  NOT?: Prisma.UserScalarWhereWithAggregatesInput | Prisma.UserScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"User"> | number
  email?: Prisma.StringWithAggregatesFilter<"User"> | string
  emailVerified?: Prisma.BoolWithAggregatesFilter<"User"> | boolean
  password?: Prisma.StringWithAggregatesFilter<"User"> | string
  name?: Prisma.StringNullableWithAggregatesFilter<"User"> | string | null
  picture?: Prisma.StringNullableWithAggregatesFilter<"User"> | string | null
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"User"> | Date | string
  role?: Prisma.EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
  isBanned?: Prisma.BoolWithAggregatesFilter<"User"> | boolean
  banExpiresAt?: Prisma.DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  banReason?: Prisma.StringNullableWithAggregatesFilter<"User"> | string | null
  credibility?: Prisma.IntWithAggregatesFilter<"User"> | number
}

export type UserCreateInput = {
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationCreateNestedManyWithoutUserInput
}

export type UserUncheckedCreateInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueUncheckedCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeUncheckedCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput
}

export type UserUpdateInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUpdateManyWithoutUserNestedInput
}

export type UserUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUncheckedUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUncheckedUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput
}

export type UserCreateManyInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
}

export type UserUpdateManyMutationInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
}

export type UserUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
}

export type UserCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  email?: Prisma.SortOrder
  emailVerified?: Prisma.SortOrder
  password?: Prisma.SortOrder
  name?: Prisma.SortOrder
  picture?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  role?: Prisma.SortOrder
  isBanned?: Prisma.SortOrder
  banExpiresAt?: Prisma.SortOrder
  banReason?: Prisma.SortOrder
  credibility?: Prisma.SortOrder
}

export type UserAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  credibility?: Prisma.SortOrder
}

export type UserMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  email?: Prisma.SortOrder
  emailVerified?: Prisma.SortOrder
  password?: Prisma.SortOrder
  name?: Prisma.SortOrder
  picture?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  role?: Prisma.SortOrder
  isBanned?: Prisma.SortOrder
  banExpiresAt?: Prisma.SortOrder
  banReason?: Prisma.SortOrder
  credibility?: Prisma.SortOrder
}

export type UserMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  email?: Prisma.SortOrder
  emailVerified?: Prisma.SortOrder
  password?: Prisma.SortOrder
  name?: Prisma.SortOrder
  picture?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  role?: Prisma.SortOrder
  isBanned?: Prisma.SortOrder
  banExpiresAt?: Prisma.SortOrder
  banReason?: Prisma.SortOrder
  credibility?: Prisma.SortOrder
}

export type UserSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  credibility?: Prisma.SortOrder
}

export type UserScalarRelationFilter = {
  is?: Prisma.UserWhereInput
  isNot?: Prisma.UserWhereInput
}

export type UserNullableScalarRelationFilter = {
  is?: Prisma.UserWhereInput | null
  isNot?: Prisma.UserWhereInput | null
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string
}

export type EnumUserRoleFieldUpdateOperationsInput = {
  set?: $Enums.UserRole
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type IntFieldUpdateOperationsInput = {
  set?: number
  increment?: number
  decrement?: number
  multiply?: number
  divide?: number
}

export type UserCreateNestedOneWithoutBadgesInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutBadgesInput, Prisma.UserUncheckedCreateWithoutBadgesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutBadgesInput
  connect?: Prisma.UserWhereUniqueInput
}

export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutBadgesInput, Prisma.UserUncheckedCreateWithoutBadgesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutBadgesInput
  upsert?: Prisma.UserUpsertWithoutBadgesInput
  connect?: Prisma.UserWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.UserUpdateToOneWithWhereWithoutBadgesInput, Prisma.UserUpdateWithoutBadgesInput>, Prisma.UserUncheckedUpdateWithoutBadgesInput>
}

export type UserCreateNestedOneWithoutIssuesInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutIssuesInput, Prisma.UserUncheckedCreateWithoutIssuesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutIssuesInput
  connect?: Prisma.UserWhereUniqueInput
}

export type UserUpdateOneRequiredWithoutIssuesNestedInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutIssuesInput, Prisma.UserUncheckedCreateWithoutIssuesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutIssuesInput
  upsert?: Prisma.UserUpsertWithoutIssuesInput
  connect?: Prisma.UserWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.UserUpdateToOneWithWhereWithoutIssuesInput, Prisma.UserUpdateWithoutIssuesInput>, Prisma.UserUncheckedUpdateWithoutIssuesInput>
}

export type UserCreateNestedOneWithoutIssueUpvotesInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutIssueUpvotesInput, Prisma.UserUncheckedCreateWithoutIssueUpvotesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutIssueUpvotesInput
  connect?: Prisma.UserWhereUniqueInput
}

export type UserUpdateOneRequiredWithoutIssueUpvotesNestedInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutIssueUpvotesInput, Prisma.UserUncheckedCreateWithoutIssueUpvotesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutIssueUpvotesInput
  upsert?: Prisma.UserUpsertWithoutIssueUpvotesInput
  connect?: Prisma.UserWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.UserUpdateToOneWithWhereWithoutIssueUpvotesInput, Prisma.UserUpdateWithoutIssueUpvotesInput>, Prisma.UserUncheckedUpdateWithoutIssueUpvotesInput>
}

export type UserCreateNestedOneWithoutResolutionVotesInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutResolutionVotesInput, Prisma.UserUncheckedCreateWithoutResolutionVotesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutResolutionVotesInput
  connect?: Prisma.UserWhereUniqueInput
}

export type UserUpdateOneRequiredWithoutResolutionVotesNestedInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutResolutionVotesInput, Prisma.UserUncheckedCreateWithoutResolutionVotesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutResolutionVotesInput
  upsert?: Prisma.UserUpsertWithoutResolutionVotesInput
  connect?: Prisma.UserWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.UserUpdateToOneWithWhereWithoutResolutionVotesInput, Prisma.UserUpdateWithoutResolutionVotesInput>, Prisma.UserUncheckedUpdateWithoutResolutionVotesInput>
}

export type UserCreateNestedOneWithoutCommentsInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutCommentsInput, Prisma.UserUncheckedCreateWithoutCommentsInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutCommentsInput
  connect?: Prisma.UserWhereUniqueInput
}

export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutCommentsInput, Prisma.UserUncheckedCreateWithoutCommentsInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutCommentsInput
  upsert?: Prisma.UserUpsertWithoutCommentsInput
  connect?: Prisma.UserWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.UserUpdateToOneWithWhereWithoutCommentsInput, Prisma.UserUpdateWithoutCommentsInput>, Prisma.UserUncheckedUpdateWithoutCommentsInput>
}

export type UserCreateNestedOneWithoutCommentUpvotesInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutCommentUpvotesInput, Prisma.UserUncheckedCreateWithoutCommentUpvotesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutCommentUpvotesInput
  connect?: Prisma.UserWhereUniqueInput
}

export type UserUpdateOneRequiredWithoutCommentUpvotesNestedInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutCommentUpvotesInput, Prisma.UserUncheckedCreateWithoutCommentUpvotesInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutCommentUpvotesInput
  upsert?: Prisma.UserUpsertWithoutCommentUpvotesInput
  connect?: Prisma.UserWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.UserUpdateToOneWithWhereWithoutCommentUpvotesInput, Prisma.UserUpdateWithoutCommentUpvotesInput>, Prisma.UserUncheckedUpdateWithoutCommentUpvotesInput>
}

export type UserCreateNestedOneWithoutNotificationsInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutNotificationsInput, Prisma.UserUncheckedCreateWithoutNotificationsInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutNotificationsInput
  connect?: Prisma.UserWhereUniqueInput
}

export type UserUpdateOneWithoutNotificationsNestedInput = {
  create?: Prisma.XOR<Prisma.UserCreateWithoutNotificationsInput, Prisma.UserUncheckedCreateWithoutNotificationsInput>
  connectOrCreate?: Prisma.UserCreateOrConnectWithoutNotificationsInput
  upsert?: Prisma.UserUpsertWithoutNotificationsInput
  disconnect?: Prisma.UserWhereInput | boolean
  delete?: Prisma.UserWhereInput | boolean
  connect?: Prisma.UserWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.UserUpdateToOneWithWhereWithoutNotificationsInput, Prisma.UserUpdateWithoutNotificationsInput>, Prisma.UserUncheckedUpdateWithoutNotificationsInput>
}

export type UserCreateWithoutBadgesInput = {
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationCreateNestedManyWithoutUserInput
}

export type UserUncheckedCreateWithoutBadgesInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueUncheckedCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput
}

export type UserCreateOrConnectWithoutBadgesInput = {
  where: Prisma.UserWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCreateWithoutBadgesInput, Prisma.UserUncheckedCreateWithoutBadgesInput>
}

export type UserUpsertWithoutBadgesInput = {
  update: Prisma.XOR<Prisma.UserUpdateWithoutBadgesInput, Prisma.UserUncheckedUpdateWithoutBadgesInput>
  create: Prisma.XOR<Prisma.UserCreateWithoutBadgesInput, Prisma.UserUncheckedCreateWithoutBadgesInput>
  where?: Prisma.UserWhereInput
}

export type UserUpdateToOneWithWhereWithoutBadgesInput = {
  where?: Prisma.UserWhereInput
  data: Prisma.XOR<Prisma.UserUpdateWithoutBadgesInput, Prisma.UserUncheckedUpdateWithoutBadgesInput>
}

export type UserUpdateWithoutBadgesInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUpdateManyWithoutUserNestedInput
}

export type UserUncheckedUpdateWithoutBadgesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUncheckedUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput
}

export type UserCreateWithoutIssuesInput = {
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  comments?: Prisma.CommentCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationCreateNestedManyWithoutUserInput
}

export type UserUncheckedCreateWithoutIssuesInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeUncheckedCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput
}

export type UserCreateOrConnectWithoutIssuesInput = {
  where: Prisma.UserWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCreateWithoutIssuesInput, Prisma.UserUncheckedCreateWithoutIssuesInput>
}

export type UserUpsertWithoutIssuesInput = {
  update: Prisma.XOR<Prisma.UserUpdateWithoutIssuesInput, Prisma.UserUncheckedUpdateWithoutIssuesInput>
  create: Prisma.XOR<Prisma.UserCreateWithoutIssuesInput, Prisma.UserUncheckedCreateWithoutIssuesInput>
  where?: Prisma.UserWhereInput
}

export type UserUpdateToOneWithWhereWithoutIssuesInput = {
  where?: Prisma.UserWhereInput
  data: Prisma.XOR<Prisma.UserUpdateWithoutIssuesInput, Prisma.UserUncheckedUpdateWithoutIssuesInput>
}

export type UserUpdateWithoutIssuesInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  comments?: Prisma.CommentUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUpdateManyWithoutUserNestedInput
}

export type UserUncheckedUpdateWithoutIssuesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  comments?: Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUncheckedUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput
}

export type UserCreateWithoutIssueUpvotesInput = {
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationCreateNestedManyWithoutUserInput
}

export type UserUncheckedCreateWithoutIssueUpvotesInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueUncheckedCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeUncheckedCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput
}

export type UserCreateOrConnectWithoutIssueUpvotesInput = {
  where: Prisma.UserWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCreateWithoutIssueUpvotesInput, Prisma.UserUncheckedCreateWithoutIssueUpvotesInput>
}

export type UserUpsertWithoutIssueUpvotesInput = {
  update: Prisma.XOR<Prisma.UserUpdateWithoutIssueUpvotesInput, Prisma.UserUncheckedUpdateWithoutIssueUpvotesInput>
  create: Prisma.XOR<Prisma.UserCreateWithoutIssueUpvotesInput, Prisma.UserUncheckedCreateWithoutIssueUpvotesInput>
  where?: Prisma.UserWhereInput
}

export type UserUpdateToOneWithWhereWithoutIssueUpvotesInput = {
  where?: Prisma.UserWhereInput
  data: Prisma.XOR<Prisma.UserUpdateWithoutIssueUpvotesInput, Prisma.UserUncheckedUpdateWithoutIssueUpvotesInput>
}

export type UserUpdateWithoutIssueUpvotesInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUpdateManyWithoutUserNestedInput
}

export type UserUncheckedUpdateWithoutIssueUpvotesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUncheckedUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUncheckedUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput
}

export type UserCreateWithoutResolutionVotesInput = {
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationCreateNestedManyWithoutUserInput
}

export type UserUncheckedCreateWithoutResolutionVotesInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueUncheckedCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeUncheckedCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput
}

export type UserCreateOrConnectWithoutResolutionVotesInput = {
  where: Prisma.UserWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCreateWithoutResolutionVotesInput, Prisma.UserUncheckedCreateWithoutResolutionVotesInput>
}

export type UserUpsertWithoutResolutionVotesInput = {
  update: Prisma.XOR<Prisma.UserUpdateWithoutResolutionVotesInput, Prisma.UserUncheckedUpdateWithoutResolutionVotesInput>
  create: Prisma.XOR<Prisma.UserCreateWithoutResolutionVotesInput, Prisma.UserUncheckedCreateWithoutResolutionVotesInput>
  where?: Prisma.UserWhereInput
}

export type UserUpdateToOneWithWhereWithoutResolutionVotesInput = {
  where?: Prisma.UserWhereInput
  data: Prisma.XOR<Prisma.UserUpdateWithoutResolutionVotesInput, Prisma.UserUncheckedUpdateWithoutResolutionVotesInput>
}

export type UserUpdateWithoutResolutionVotesInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUpdateManyWithoutUserNestedInput
}

export type UserUncheckedUpdateWithoutResolutionVotesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUncheckedUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUncheckedUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput
}

export type UserCreateWithoutCommentsInput = {
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationCreateNestedManyWithoutUserInput
}

export type UserUncheckedCreateWithoutCommentsInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueUncheckedCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeUncheckedCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput
}

export type UserCreateOrConnectWithoutCommentsInput = {
  where: Prisma.UserWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCreateWithoutCommentsInput, Prisma.UserUncheckedCreateWithoutCommentsInput>
}

export type UserUpsertWithoutCommentsInput = {
  update: Prisma.XOR<Prisma.UserUpdateWithoutCommentsInput, Prisma.UserUncheckedUpdateWithoutCommentsInput>
  create: Prisma.XOR<Prisma.UserCreateWithoutCommentsInput, Prisma.UserUncheckedCreateWithoutCommentsInput>
  where?: Prisma.UserWhereInput
}

export type UserUpdateToOneWithWhereWithoutCommentsInput = {
  where?: Prisma.UserWhereInput
  data: Prisma.XOR<Prisma.UserUpdateWithoutCommentsInput, Prisma.UserUncheckedUpdateWithoutCommentsInput>
}

export type UserUpdateWithoutCommentsInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUpdateManyWithoutUserNestedInput
}

export type UserUncheckedUpdateWithoutCommentsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUncheckedUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUncheckedUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput
}

export type UserCreateWithoutCommentUpvotesInput = {
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationCreateNestedManyWithoutUserInput
}

export type UserUncheckedCreateWithoutCommentUpvotesInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueUncheckedCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeUncheckedCreateNestedManyWithoutUserInput
  notifications?: Prisma.NotificationUncheckedCreateNestedManyWithoutUserInput
}

export type UserCreateOrConnectWithoutCommentUpvotesInput = {
  where: Prisma.UserWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCreateWithoutCommentUpvotesInput, Prisma.UserUncheckedCreateWithoutCommentUpvotesInput>
}

export type UserUpsertWithoutCommentUpvotesInput = {
  update: Prisma.XOR<Prisma.UserUpdateWithoutCommentUpvotesInput, Prisma.UserUncheckedUpdateWithoutCommentUpvotesInput>
  create: Prisma.XOR<Prisma.UserCreateWithoutCommentUpvotesInput, Prisma.UserUncheckedCreateWithoutCommentUpvotesInput>
  where?: Prisma.UserWhereInput
}

export type UserUpdateToOneWithWhereWithoutCommentUpvotesInput = {
  where?: Prisma.UserWhereInput
  data: Prisma.XOR<Prisma.UserUpdateWithoutCommentUpvotesInput, Prisma.UserUncheckedUpdateWithoutCommentUpvotesInput>
}

export type UserUpdateWithoutCommentUpvotesInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUpdateManyWithoutUserNestedInput
}

export type UserUncheckedUpdateWithoutCommentUpvotesInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUncheckedUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUncheckedUpdateManyWithoutUserNestedInput
  notifications?: Prisma.NotificationUncheckedUpdateManyWithoutUserNestedInput
}

export type UserCreateWithoutNotificationsInput = {
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeCreateNestedManyWithoutUserInput
}

export type UserUncheckedCreateWithoutNotificationsInput = {
  id?: number
  email: string
  emailVerified?: boolean
  password: string
  name?: string | null
  picture?: string | null
  createdAt?: Date | string
  role?: $Enums.UserRole
  isBanned?: boolean
  banExpiresAt?: Date | string | null
  banReason?: string | null
  credibility?: number
  issues?: Prisma.IssueUncheckedCreateNestedManyWithoutUserInput
  comments?: Prisma.CommentUncheckedCreateNestedManyWithoutUserInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedCreateNestedManyWithoutUserInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedCreateNestedManyWithoutUserInput
  badges?: Prisma.UserBadgeUncheckedCreateNestedManyWithoutUserInput
}

export type UserCreateOrConnectWithoutNotificationsInput = {
  where: Prisma.UserWhereUniqueInput
  create: Prisma.XOR<Prisma.UserCreateWithoutNotificationsInput, Prisma.UserUncheckedCreateWithoutNotificationsInput>
}

export type UserUpsertWithoutNotificationsInput = {
  update: Prisma.XOR<Prisma.UserUpdateWithoutNotificationsInput, Prisma.UserUncheckedUpdateWithoutNotificationsInput>
  create: Prisma.XOR<Prisma.UserCreateWithoutNotificationsInput, Prisma.UserUncheckedCreateWithoutNotificationsInput>
  where?: Prisma.UserWhereInput
}

export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
  where?: Prisma.UserWhereInput
  data: Prisma.XOR<Prisma.UserUpdateWithoutNotificationsInput, Prisma.UserUncheckedUpdateWithoutNotificationsInput>
}

export type UserUpdateWithoutNotificationsInput = {
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUpdateManyWithoutUserNestedInput
}

export type UserUncheckedUpdateWithoutNotificationsInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  email?: Prisma.StringFieldUpdateOperationsInput | string
  emailVerified?: Prisma.BoolFieldUpdateOperationsInput | boolean
  password?: Prisma.StringFieldUpdateOperationsInput | string
  name?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  picture?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  role?: Prisma.EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
  isBanned?: Prisma.BoolFieldUpdateOperationsInput | boolean
  banExpiresAt?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  banReason?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  credibility?: Prisma.IntFieldUpdateOperationsInput | number
  issues?: Prisma.IssueUncheckedUpdateManyWithoutUserNestedInput
  comments?: Prisma.CommentUncheckedUpdateManyWithoutUserNestedInput
  commentUpvotes?: Prisma.CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
  issueUpvotes?: Prisma.IssueUpvoteUncheckedUpdateManyWithoutUserNestedInput
  resolutionVotes?: Prisma.IssueResolutionVoteUncheckedUpdateManyWithoutUserNestedInput
  badges?: Prisma.UserBadgeUncheckedUpdateManyWithoutUserNestedInput
}


/**
 * Count Type UserCountOutputType
 */

export type UserCountOutputType = {
  issues: number
  comments: number
  commentUpvotes: number
  issueUpvotes: number
  resolutionVotes: number
  badges: number
  notifications: number
}

export type UserCountOutputTypeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issues?: boolean | UserCountOutputTypeCountIssuesArgs
  comments?: boolean | UserCountOutputTypeCountCommentsArgs
  commentUpvotes?: boolean | UserCountOutputTypeCountCommentUpvotesArgs
  issueUpvotes?: boolean | UserCountOutputTypeCountIssueUpvotesArgs
  resolutionVotes?: boolean | UserCountOutputTypeCountResolutionVotesArgs
  badges?: boolean | UserCountOutputTypeCountBadgesArgs
  notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
}

/**
 * UserCountOutputType without action
 */
export type UserCountOutputTypeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserCountOutputType
   */
  select?: Prisma.UserCountOutputTypeSelect<ExtArgs> | null
}

/**
 * UserCountOutputType without action
 */
export type UserCountOutputTypeCountIssuesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueWhereInput
}

/**
 * UserCountOutputType without action
 */
export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommentWhereInput
}

/**
 * UserCountOutputType without action
 */
export type UserCountOutputTypeCountCommentUpvotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.CommentUpvoteWhereInput
}

/**
 * UserCountOutputType without action
 */
export type UserCountOutputTypeCountIssueUpvotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueUpvoteWhereInput
}

/**
 * UserCountOutputType without action
 */
export type UserCountOutputTypeCountResolutionVotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.IssueResolutionVoteWhereInput
}

/**
 * UserCountOutputType without action
 */
export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.UserBadgeWhereInput
}

/**
 * UserCountOutputType without action
 */
export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.NotificationWhereInput
}


export type UserSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  email?: boolean
  emailVerified?: boolean
  password?: boolean
  name?: boolean
  picture?: boolean
  createdAt?: boolean
  role?: boolean
  isBanned?: boolean
  banExpiresAt?: boolean
  banReason?: boolean
  credibility?: boolean
  issues?: boolean | Prisma.User$issuesArgs<ExtArgs>
  comments?: boolean | Prisma.User$commentsArgs<ExtArgs>
  commentUpvotes?: boolean | Prisma.User$commentUpvotesArgs<ExtArgs>
  issueUpvotes?: boolean | Prisma.User$issueUpvotesArgs<ExtArgs>
  resolutionVotes?: boolean | Prisma.User$resolutionVotesArgs<ExtArgs>
  badges?: boolean | Prisma.User$badgesArgs<ExtArgs>
  notifications?: boolean | Prisma.User$notificationsArgs<ExtArgs>
  _count?: boolean | Prisma.UserCountOutputTypeDefaultArgs<ExtArgs>
}, ExtArgs["result"]["user"]>

export type UserSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  email?: boolean
  emailVerified?: boolean
  password?: boolean
  name?: boolean
  picture?: boolean
  createdAt?: boolean
  role?: boolean
  isBanned?: boolean
  banExpiresAt?: boolean
  banReason?: boolean
  credibility?: boolean
}, ExtArgs["result"]["user"]>

export type UserSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  email?: boolean
  emailVerified?: boolean
  password?: boolean
  name?: boolean
  picture?: boolean
  createdAt?: boolean
  role?: boolean
  isBanned?: boolean
  banExpiresAt?: boolean
  banReason?: boolean
  credibility?: boolean
}, ExtArgs["result"]["user"]>

export type UserSelectScalar = {
  id?: boolean
  email?: boolean
  emailVerified?: boolean
  password?: boolean
  name?: boolean
  picture?: boolean
  createdAt?: boolean
  role?: boolean
  isBanned?: boolean
  banExpiresAt?: boolean
  banReason?: boolean
  credibility?: boolean
}

export type UserOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "email" | "emailVerified" | "password" | "name" | "picture" | "createdAt" | "role" | "isBanned" | "banExpiresAt" | "banReason" | "credibility", ExtArgs["result"]["user"]>
export type UserInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  issues?: boolean | Prisma.User$issuesArgs<ExtArgs>
  comments?: boolean | Prisma.User$commentsArgs<ExtArgs>
  commentUpvotes?: boolean | Prisma.User$commentUpvotesArgs<ExtArgs>
  issueUpvotes?: boolean | Prisma.User$issueUpvotesArgs<ExtArgs>
  resolutionVotes?: boolean | Prisma.User$resolutionVotesArgs<ExtArgs>
  badges?: boolean | Prisma.User$badgesArgs<ExtArgs>
  notifications?: boolean | Prisma.User$notificationsArgs<ExtArgs>
  _count?: boolean | Prisma.UserCountOutputTypeDefaultArgs<ExtArgs>
}
export type UserIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}
export type UserIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {}

export type $UserPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    issues: Prisma.$IssuePayload<ExtArgs>[]
    comments: Prisma.$CommentPayload<ExtArgs>[]
    commentUpvotes: Prisma.$CommentUpvotePayload<ExtArgs>[]
    issueUpvotes: Prisma.$IssueUpvotePayload<ExtArgs>[]
    resolutionVotes: Prisma.$IssueResolutionVotePayload<ExtArgs>[]
    badges: Prisma.$UserBadgePayload<ExtArgs>[]
    notifications: Prisma.$NotificationPayload<ExtArgs>[]
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    email: string
    emailVerified: boolean
    password: string
    name: string | null
    picture: string | null
    createdAt: Date
    role: $Enums.UserRole
    isBanned: boolean
    banExpiresAt: Date | null
    banReason: string | null
    credibility: number
  }, ExtArgs["result"]["user"]>
  composites: {}
}

export type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$UserPayload, S>

export type UserCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCountAggregateInputType | true
  }

export interface UserDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
  /**
   * Find zero or one User that matches the filter.
   * @param {UserFindUniqueArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends UserFindUniqueArgs>(args: Prisma.SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one User that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first User that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFindFirstArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends UserFindFirstArgs>(args?: Prisma.SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first User that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
   * @example
   * // Get one User
   * const user = await prisma.user.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Users that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Users
   * const users = await prisma.user.findMany()
   * 
   * // Get first 10 Users
   * const users = await prisma.user.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends UserFindManyArgs>(args?: Prisma.SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a User.
   * @param {UserCreateArgs} args - Arguments to create a User.
   * @example
   * // Create one User
   * const User = await prisma.user.create({
   *   data: {
   *     // ... data to create a User
   *   }
   * })
   * 
   */
  create<T extends UserCreateArgs>(args: Prisma.SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Users.
   * @param {UserCreateManyArgs} args - Arguments to create many Users.
   * @example
   * // Create many Users
   * const user = await prisma.user.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends UserCreateManyArgs>(args?: Prisma.SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many Users and returns the data saved in the database.
   * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
   * @example
   * // Create many Users
   * const user = await prisma.user.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many Users and only return the `id`
   * const userWithIdOnly = await prisma.user.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a User.
   * @param {UserDeleteArgs} args - Arguments to delete one User.
   * @example
   * // Delete one User
   * const User = await prisma.user.delete({
   *   where: {
   *     // ... filter to delete one User
   *   }
   * })
   * 
   */
  delete<T extends UserDeleteArgs>(args: Prisma.SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one User.
   * @param {UserUpdateArgs} args - Arguments to update one User.
   * @example
   * // Update one User
   * const user = await prisma.user.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends UserUpdateArgs>(args: Prisma.SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Users.
   * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
   * @example
   * // Delete a few Users
   * const { count } = await prisma.user.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends UserDeleteManyArgs>(args?: Prisma.SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Users.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Users
   * const user = await prisma.user.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends UserUpdateManyArgs>(args: Prisma.SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Users and returns the data updated in the database.
   * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
   * @example
   * // Update many Users
   * const user = await prisma.user.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more Users and only return the `id`
   * const userWithIdOnly = await prisma.user.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one User.
   * @param {UserUpsertArgs} args - Arguments to update or create a User.
   * @example
   * // Update or create a User
   * const user = await prisma.user.upsert({
   *   create: {
   *     // ... data to create a User
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the User we want to update
   *   }
   * })
   */
  upsert<T extends UserUpsertArgs>(args: Prisma.SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Users.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserCountArgs} args - Arguments to filter Users to count.
   * @example
   * // Count the number of Users
   * const count = await prisma.user.count({
   *   where: {
   *     // ... the filter for the Users we want to count
   *   }
   * })
  **/
  count<T extends UserCountArgs>(
    args?: Prisma.Subset<T, UserCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], UserCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a User.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends UserAggregateArgs>(args: Prisma.Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

  /**
   * Group by User.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends UserGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: UserGroupByArgs['orderBy'] }
      : { orderBy?: UserGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the User model
 */
readonly fields: UserFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for User.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__UserClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  issues<T extends Prisma.User$issuesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.User$issuesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  comments<T extends Prisma.User$commentsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  commentUpvotes<T extends Prisma.User$commentUpvotesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.User$commentUpvotesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  issueUpvotes<T extends Prisma.User$issueUpvotesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.User$issueUpvotesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueUpvotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  resolutionVotes<T extends Prisma.User$resolutionVotesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.User$resolutionVotesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$IssueResolutionVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  badges<T extends Prisma.User$badgesArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  notifications<T extends Prisma.User$notificationsArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the User model
 */
export interface UserFieldRefs {
  readonly id: Prisma.FieldRef<"User", 'Int'>
  readonly email: Prisma.FieldRef<"User", 'String'>
  readonly emailVerified: Prisma.FieldRef<"User", 'Boolean'>
  readonly password: Prisma.FieldRef<"User", 'String'>
  readonly name: Prisma.FieldRef<"User", 'String'>
  readonly picture: Prisma.FieldRef<"User", 'String'>
  readonly createdAt: Prisma.FieldRef<"User", 'DateTime'>
  readonly role: Prisma.FieldRef<"User", 'UserRole'>
  readonly isBanned: Prisma.FieldRef<"User", 'Boolean'>
  readonly banExpiresAt: Prisma.FieldRef<"User", 'DateTime'>
  readonly banReason: Prisma.FieldRef<"User", 'String'>
  readonly credibility: Prisma.FieldRef<"User", 'Int'>
}
    

// Custom InputTypes
/**
 * User findUnique
 */
export type UserFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * Filter, which User to fetch.
   */
  where: Prisma.UserWhereUniqueInput
}

/**
 * User findUniqueOrThrow
 */
export type UserFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * Filter, which User to fetch.
   */
  where: Prisma.UserWhereUniqueInput
}

/**
 * User findFirst
 */
export type UserFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * Filter, which User to fetch.
   */
  where?: Prisma.UserWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Users to fetch.
   */
  orderBy?: Prisma.UserOrderByWithRelationInput | Prisma.UserOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Users.
   */
  cursor?: Prisma.UserWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Users from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Users.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Users.
   */
  distinct?: Prisma.UserScalarFieldEnum | Prisma.UserScalarFieldEnum[]
}

/**
 * User findFirstOrThrow
 */
export type UserFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * Filter, which User to fetch.
   */
  where?: Prisma.UserWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Users to fetch.
   */
  orderBy?: Prisma.UserOrderByWithRelationInput | Prisma.UserOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Users.
   */
  cursor?: Prisma.UserWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Users from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Users.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Users.
   */
  distinct?: Prisma.UserScalarFieldEnum | Prisma.UserScalarFieldEnum[]
}

/**
 * User findMany
 */
export type UserFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * Filter, which Users to fetch.
   */
  where?: Prisma.UserWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Users to fetch.
   */
  orderBy?: Prisma.UserOrderByWithRelationInput | Prisma.UserOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Users.
   */
  cursor?: Prisma.UserWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` Users from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Users.
   */
  skip?: number
  distinct?: Prisma.UserScalarFieldEnum | Prisma.UserScalarFieldEnum[]
}

/**
 * User create
 */
export type UserCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * The data needed to create a User.
   */
  data: Prisma.XOR<Prisma.UserCreateInput, Prisma.UserUncheckedCreateInput>
}

/**
 * User createMany
 */
export type UserCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Users.
   */
  data: Prisma.UserCreateManyInput | Prisma.UserCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * User createManyAndReturn
 */
export type UserCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * The data used to create many Users.
   */
  data: Prisma.UserCreateManyInput | Prisma.UserCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * User update
 */
export type UserUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * The data needed to update a User.
   */
  data: Prisma.XOR<Prisma.UserUpdateInput, Prisma.UserUncheckedUpdateInput>
  /**
   * Choose, which User to update.
   */
  where: Prisma.UserWhereUniqueInput
}

/**
 * User updateMany
 */
export type UserUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Users.
   */
  data: Prisma.XOR<Prisma.UserUpdateManyMutationInput, Prisma.UserUncheckedUpdateManyInput>
  /**
   * Filter which Users to update
   */
  where?: Prisma.UserWhereInput
  /**
   * Limit how many Users to update.
   */
  limit?: number
}

/**
 * User updateManyAndReturn
 */
export type UserUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * The data used to update Users.
   */
  data: Prisma.XOR<Prisma.UserUpdateManyMutationInput, Prisma.UserUncheckedUpdateManyInput>
  /**
   * Filter which Users to update
   */
  where?: Prisma.UserWhereInput
  /**
   * Limit how many Users to update.
   */
  limit?: number
}

/**
 * User upsert
 */
export type UserUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * The filter to search for the User to update in case it exists.
   */
  where: Prisma.UserWhereUniqueInput
  /**
   * In case the User found by the `where` argument doesn't exist, create a new User with this data.
   */
  create: Prisma.XOR<Prisma.UserCreateInput, Prisma.UserUncheckedCreateInput>
  /**
   * In case the User was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.UserUpdateInput, Prisma.UserUncheckedUpdateInput>
}

/**
 * User delete
 */
export type UserDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
  /**
   * Filter which User to delete.
   */
  where: Prisma.UserWhereUniqueInput
}

/**
 * User deleteMany
 */
export type UserDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Users to delete
   */
  where?: Prisma.UserWhereInput
  /**
   * Limit how many Users to delete.
   */
  limit?: number
}

/**
 * User.issues
 */
export type User$issuesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Issue
   */
  select?: Prisma.IssueSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Issue
   */
  omit?: Prisma.IssueOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueInclude<ExtArgs> | null
  where?: Prisma.IssueWhereInput
  orderBy?: Prisma.IssueOrderByWithRelationInput | Prisma.IssueOrderByWithRelationInput[]
  cursor?: Prisma.IssueWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.IssueScalarFieldEnum | Prisma.IssueScalarFieldEnum[]
}

/**
 * User.comments
 */
export type User$commentsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Comment
   */
  select?: Prisma.CommentSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Comment
   */
  omit?: Prisma.CommentOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentInclude<ExtArgs> | null
  where?: Prisma.CommentWhereInput
  orderBy?: Prisma.CommentOrderByWithRelationInput | Prisma.CommentOrderByWithRelationInput[]
  cursor?: Prisma.CommentWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[]
}

/**
 * User.commentUpvotes
 */
export type User$commentUpvotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the CommentUpvote
   */
  select?: Prisma.CommentUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the CommentUpvote
   */
  omit?: Prisma.CommentUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.CommentUpvoteInclude<ExtArgs> | null
  where?: Prisma.CommentUpvoteWhereInput
  orderBy?: Prisma.CommentUpvoteOrderByWithRelationInput | Prisma.CommentUpvoteOrderByWithRelationInput[]
  cursor?: Prisma.CommentUpvoteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.CommentUpvoteScalarFieldEnum | Prisma.CommentUpvoteScalarFieldEnum[]
}

/**
 * User.issueUpvotes
 */
export type User$issueUpvotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueUpvote
   */
  select?: Prisma.IssueUpvoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueUpvote
   */
  omit?: Prisma.IssueUpvoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueUpvoteInclude<ExtArgs> | null
  where?: Prisma.IssueUpvoteWhereInput
  orderBy?: Prisma.IssueUpvoteOrderByWithRelationInput | Prisma.IssueUpvoteOrderByWithRelationInput[]
  cursor?: Prisma.IssueUpvoteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.IssueUpvoteScalarFieldEnum | Prisma.IssueUpvoteScalarFieldEnum[]
}

/**
 * User.resolutionVotes
 */
export type User$resolutionVotesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the IssueResolutionVote
   */
  select?: Prisma.IssueResolutionVoteSelect<ExtArgs> | null
  /**
   * Omit specific fields from the IssueResolutionVote
   */
  omit?: Prisma.IssueResolutionVoteOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.IssueResolutionVoteInclude<ExtArgs> | null
  where?: Prisma.IssueResolutionVoteWhereInput
  orderBy?: Prisma.IssueResolutionVoteOrderByWithRelationInput | Prisma.IssueResolutionVoteOrderByWithRelationInput[]
  cursor?: Prisma.IssueResolutionVoteWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.IssueResolutionVoteScalarFieldEnum | Prisma.IssueResolutionVoteScalarFieldEnum[]
}

/**
 * User.badges
 */
export type User$badgesArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  where?: Prisma.UserBadgeWhereInput
  orderBy?: Prisma.UserBadgeOrderByWithRelationInput | Prisma.UserBadgeOrderByWithRelationInput[]
  cursor?: Prisma.UserBadgeWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.UserBadgeScalarFieldEnum | Prisma.UserBadgeScalarFieldEnum[]
}

/**
 * User.notifications
 */
export type User$notificationsArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Notification
   */
  select?: Prisma.NotificationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Notification
   */
  omit?: Prisma.NotificationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.NotificationInclude<ExtArgs> | null
  where?: Prisma.NotificationWhereInput
  orderBy?: Prisma.NotificationOrderByWithRelationInput | Prisma.NotificationOrderByWithRelationInput[]
  cursor?: Prisma.NotificationWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Prisma.NotificationScalarFieldEnum | Prisma.NotificationScalarFieldEnum[]
}

/**
 * User without action
 */
export type UserDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the User
   */
  select?: Prisma.UserSelect<ExtArgs> | null
  /**
   * Omit specific fields from the User
   */
  omit?: Prisma.UserOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\generated\prisma\models\UserBadge.ts
<code>

/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `UserBadge` model and its related types.
 *
 *  You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model UserBadge
 * 
 */
export type UserBadgeModel = runtime.Types.Result.DefaultSelection<Prisma.$UserBadgePayload>

export type AggregateUserBadge = {
  _count: UserBadgeCountAggregateOutputType | null
  _avg: UserBadgeAvgAggregateOutputType | null
  _sum: UserBadgeSumAggregateOutputType | null
  _min: UserBadgeMinAggregateOutputType | null
  _max: UserBadgeMaxAggregateOutputType | null
}

export type UserBadgeAvgAggregateOutputType = {
  id: number | null
  userId: number | null
}

export type UserBadgeSumAggregateOutputType = {
  id: number | null
  userId: number | null
}

export type UserBadgeMinAggregateOutputType = {
  id: number | null
  name: string | null
  awardedAt: Date | null
  userId: number | null
}

export type UserBadgeMaxAggregateOutputType = {
  id: number | null
  name: string | null
  awardedAt: Date | null
  userId: number | null
}

export type UserBadgeCountAggregateOutputType = {
  id: number
  name: number
  awardedAt: number
  userId: number
  _all: number
}


export type UserBadgeAvgAggregateInputType = {
  id?: true
  userId?: true
}

export type UserBadgeSumAggregateInputType = {
  id?: true
  userId?: true
}

export type UserBadgeMinAggregateInputType = {
  id?: true
  name?: true
  awardedAt?: true
  userId?: true
}

export type UserBadgeMaxAggregateInputType = {
  id?: true
  name?: true
  awardedAt?: true
  userId?: true
}

export type UserBadgeCountAggregateInputType = {
  id?: true
  name?: true
  awardedAt?: true
  userId?: true
  _all?: true
}

export type UserBadgeAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which UserBadge to aggregate.
   */
  where?: Prisma.UserBadgeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserBadges to fetch.
   */
  orderBy?: Prisma.UserBadgeOrderByWithRelationInput | Prisma.UserBadgeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.UserBadgeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` UserBadges from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserBadges.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned UserBadges
  **/
  _count?: true | UserBadgeCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: UserBadgeAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: UserBadgeSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: UserBadgeMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: UserBadgeMaxAggregateInputType
}

export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
      [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateUserBadge[P]>
    : Prisma.GetScalarType<T[P], AggregateUserBadge[P]>
}




export type UserBadgeGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.UserBadgeWhereInput
  orderBy?: Prisma.UserBadgeOrderByWithAggregationInput | Prisma.UserBadgeOrderByWithAggregationInput[]
  by: Prisma.UserBadgeScalarFieldEnum[] | Prisma.UserBadgeScalarFieldEnum
  having?: Prisma.UserBadgeScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: UserBadgeCountAggregateInputType | true
  _avg?: UserBadgeAvgAggregateInputType
  _sum?: UserBadgeSumAggregateInputType
  _min?: UserBadgeMinAggregateInputType
  _max?: UserBadgeMaxAggregateInputType
}

export type UserBadgeGroupByOutputType = {
  id: number
  name: string
  awardedAt: Date
  userId: number
  _count: UserBadgeCountAggregateOutputType | null
  _avg: UserBadgeAvgAggregateOutputType | null
  _sum: UserBadgeSumAggregateOutputType | null
  _min: UserBadgeMinAggregateOutputType | null
  _max: UserBadgeMaxAggregateOutputType | null
}

type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
      }
    >
  >



export type UserBadgeWhereInput = {
  AND?: Prisma.UserBadgeWhereInput | Prisma.UserBadgeWhereInput[]
  OR?: Prisma.UserBadgeWhereInput[]
  NOT?: Prisma.UserBadgeWhereInput | Prisma.UserBadgeWhereInput[]
  id?: Prisma.IntFilter<"UserBadge"> | number
  name?: Prisma.StringFilter<"UserBadge"> | string
  awardedAt?: Prisma.DateTimeFilter<"UserBadge"> | Date | string
  userId?: Prisma.IntFilter<"UserBadge"> | number
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}

export type UserBadgeOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
  awardedAt?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  user?: Prisma.UserOrderByWithRelationInput
}

export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
  id?: number
  AND?: Prisma.UserBadgeWhereInput | Prisma.UserBadgeWhereInput[]
  OR?: Prisma.UserBadgeWhereInput[]
  NOT?: Prisma.UserBadgeWhereInput | Prisma.UserBadgeWhereInput[]
  name?: Prisma.StringFilter<"UserBadge"> | string
  awardedAt?: Prisma.DateTimeFilter<"UserBadge"> | Date | string
  userId?: Prisma.IntFilter<"UserBadge"> | number
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>
}, "id">

export type UserBadgeOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
  awardedAt?: Prisma.SortOrder
  userId?: Prisma.SortOrder
  _count?: Prisma.UserBadgeCountOrderByAggregateInput
  _avg?: Prisma.UserBadgeAvgOrderByAggregateInput
  _max?: Prisma.UserBadgeMaxOrderByAggregateInput
  _min?: Prisma.UserBadgeMinOrderByAggregateInput
  _sum?: Prisma.UserBadgeSumOrderByAggregateInput
}

export type UserBadgeScalarWhereWithAggregatesInput = {
  AND?: Prisma.UserBadgeScalarWhereWithAggregatesInput | Prisma.UserBadgeScalarWhereWithAggregatesInput[]
  OR?: Prisma.UserBadgeScalarWhereWithAggregatesInput[]
  NOT?: Prisma.UserBadgeScalarWhereWithAggregatesInput | Prisma.UserBadgeScalarWhereWithAggregatesInput[]
  id?: Prisma.IntWithAggregatesFilter<"UserBadge"> | number
  name?: Prisma.StringWithAggregatesFilter<"UserBadge"> | string
  awardedAt?: Prisma.DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  userId?: Prisma.IntWithAggregatesFilter<"UserBadge"> | number
}

export type UserBadgeCreateInput = {
  name: string
  awardedAt?: Date | string
  user: Prisma.UserCreateNestedOneWithoutBadgesInput
}

export type UserBadgeUncheckedCreateInput = {
  id?: number
  name: string
  awardedAt?: Date | string
  userId: number
}

export type UserBadgeUpdateInput = {
  name?: Prisma.StringFieldUpdateOperationsInput | string
  awardedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  user?: Prisma.UserUpdateOneRequiredWithoutBadgesNestedInput
}

export type UserBadgeUncheckedUpdateInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  name?: Prisma.StringFieldUpdateOperationsInput | string
  awardedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type UserBadgeCreateManyInput = {
  id?: number
  name: string
  awardedAt?: Date | string
  userId: number
}

export type UserBadgeUpdateManyMutationInput = {
  name?: Prisma.StringFieldUpdateOperationsInput | string
  awardedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserBadgeUncheckedUpdateManyInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  name?: Prisma.StringFieldUpdateOperationsInput | string
  awardedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  userId?: Prisma.IntFieldUpdateOperationsInput | number
}

export type UserBadgeListRelationFilter = {
  every?: Prisma.UserBadgeWhereInput
  some?: Prisma.UserBadgeWhereInput
  none?: Prisma.UserBadgeWhereInput
}

export type UserBadgeOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type UserBadgeCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
  awardedAt?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type UserBadgeAvgOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type UserBadgeMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
  awardedAt?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type UserBadgeMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  name?: Prisma.SortOrder
  awardedAt?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type UserBadgeSumOrderByAggregateInput = {
  id?: Prisma.SortOrder
  userId?: Prisma.SortOrder
}

export type UserBadgeCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.UserBadgeCreateWithoutUserInput, Prisma.UserBadgeUncheckedCreateWithoutUserInput> | Prisma.UserBadgeCreateWithoutUserInput[] | Prisma.UserBadgeUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserBadgeCreateOrConnectWithoutUserInput | Prisma.UserBadgeCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.UserBadgeCreateManyUserInputEnvelope
  connect?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
}

export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
  create?: Prisma.XOR<Prisma.UserBadgeCreateWithoutUserInput, Prisma.UserBadgeUncheckedCreateWithoutUserInput> | Prisma.UserBadgeCreateWithoutUserInput[] | Prisma.UserBadgeUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserBadgeCreateOrConnectWithoutUserInput | Prisma.UserBadgeCreateOrConnectWithoutUserInput[]
  createMany?: Prisma.UserBadgeCreateManyUserInputEnvelope
  connect?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
}

export type UserBadgeUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.UserBadgeCreateWithoutUserInput, Prisma.UserBadgeUncheckedCreateWithoutUserInput> | Prisma.UserBadgeCreateWithoutUserInput[] | Prisma.UserBadgeUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserBadgeCreateOrConnectWithoutUserInput | Prisma.UserBadgeCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.UserBadgeUpsertWithWhereUniqueWithoutUserInput | Prisma.UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.UserBadgeCreateManyUserInputEnvelope
  set?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
  disconnect?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
  delete?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
  connect?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
  update?: Prisma.UserBadgeUpdateWithWhereUniqueWithoutUserInput | Prisma.UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.UserBadgeUpdateManyWithWhereWithoutUserInput | Prisma.UserBadgeUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.UserBadgeScalarWhereInput | Prisma.UserBadgeScalarWhereInput[]
}

export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.UserBadgeCreateWithoutUserInput, Prisma.UserBadgeUncheckedCreateWithoutUserInput> | Prisma.UserBadgeCreateWithoutUserInput[] | Prisma.UserBadgeUncheckedCreateWithoutUserInput[]
  connectOrCreate?: Prisma.UserBadgeCreateOrConnectWithoutUserInput | Prisma.UserBadgeCreateOrConnectWithoutUserInput[]
  upsert?: Prisma.UserBadgeUpsertWithWhereUniqueWithoutUserInput | Prisma.UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
  createMany?: Prisma.UserBadgeCreateManyUserInputEnvelope
  set?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
  disconnect?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
  delete?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
  connect?: Prisma.UserBadgeWhereUniqueInput | Prisma.UserBadgeWhereUniqueInput[]
  update?: Prisma.UserBadgeUpdateWithWhereUniqueWithoutUserInput | Prisma.UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
  updateMany?: Prisma.UserBadgeUpdateManyWithWhereWithoutUserInput | Prisma.UserBadgeUpdateManyWithWhereWithoutUserInput[]
  deleteMany?: Prisma.UserBadgeScalarWhereInput | Prisma.UserBadgeScalarWhereInput[]
}

export type UserBadgeCreateWithoutUserInput = {
  name: string
  awardedAt?: Date | string
}

export type UserBadgeUncheckedCreateWithoutUserInput = {
  id?: number
  name: string
  awardedAt?: Date | string
}

export type UserBadgeCreateOrConnectWithoutUserInput = {
  where: Prisma.UserBadgeWhereUniqueInput
  create: Prisma.XOR<Prisma.UserBadgeCreateWithoutUserInput, Prisma.UserBadgeUncheckedCreateWithoutUserInput>
}

export type UserBadgeCreateManyUserInputEnvelope = {
  data: Prisma.UserBadgeCreateManyUserInput | Prisma.UserBadgeCreateManyUserInput[]
  skipDuplicates?: boolean
}

export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
  where: Prisma.UserBadgeWhereUniqueInput
  update: Prisma.XOR<Prisma.UserBadgeUpdateWithoutUserInput, Prisma.UserBadgeUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.UserBadgeCreateWithoutUserInput, Prisma.UserBadgeUncheckedCreateWithoutUserInput>
}

export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
  where: Prisma.UserBadgeWhereUniqueInput
  data: Prisma.XOR<Prisma.UserBadgeUpdateWithoutUserInput, Prisma.UserBadgeUncheckedUpdateWithoutUserInput>
}

export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
  where: Prisma.UserBadgeScalarWhereInput
  data: Prisma.XOR<Prisma.UserBadgeUpdateManyMutationInput, Prisma.UserBadgeUncheckedUpdateManyWithoutUserInput>
}

export type UserBadgeScalarWhereInput = {
  AND?: Prisma.UserBadgeScalarWhereInput | Prisma.UserBadgeScalarWhereInput[]
  OR?: Prisma.UserBadgeScalarWhereInput[]
  NOT?: Prisma.UserBadgeScalarWhereInput | Prisma.UserBadgeScalarWhereInput[]
  id?: Prisma.IntFilter<"UserBadge"> | number
  name?: Prisma.StringFilter<"UserBadge"> | string
  awardedAt?: Prisma.DateTimeFilter<"UserBadge"> | Date | string
  userId?: Prisma.IntFilter<"UserBadge"> | number
}

export type UserBadgeCreateManyUserInput = {
  id?: number
  name: string
  awardedAt?: Date | string
}

export type UserBadgeUpdateWithoutUserInput = {
  name?: Prisma.StringFieldUpdateOperationsInput | string
  awardedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserBadgeUncheckedUpdateWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  name?: Prisma.StringFieldUpdateOperationsInput | string
  awardedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
  id?: Prisma.IntFieldUpdateOperationsInput | number
  name?: Prisma.StringFieldUpdateOperationsInput | string
  awardedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type UserBadgeSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  name?: boolean
  awardedAt?: boolean
  userId?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userBadge"]>

export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  name?: boolean
  awardedAt?: boolean
  userId?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userBadge"]>

export type UserBadgeSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  name?: boolean
  awardedAt?: boolean
  userId?: boolean
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}, ExtArgs["result"]["userBadge"]>

export type UserBadgeSelectScalar = {
  id?: boolean
  name?: boolean
  awardedAt?: boolean
  userId?: boolean
}

export type UserBadgeOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "name" | "awardedAt" | "userId", ExtArgs["result"]["userBadge"]>
export type UserBadgeInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}
export type UserBadgeIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.UserDefaultArgs<ExtArgs>
}

export type $UserBadgePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "UserBadge"
  objects: {
    user: Prisma.$UserPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: number
    name: string
    awardedAt: Date
    userId: number
  }, ExtArgs["result"]["userBadge"]>
  composites: {}
}

export type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$UserBadgePayload, S>

export type UserBadgeCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserBadgeCountAggregateInputType | true
  }

export interface UserBadgeDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
  /**
   * Find zero or one UserBadge that matches the filter.
   * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
   * @example
   * // Get one UserBadge
   * const userBadge = await prisma.userBadge.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends UserBadgeFindUniqueArgs>(args: Prisma.SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma.Prisma__UserBadgeClient<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
   * @example
   * // Get one UserBadge
   * const userBadge = await prisma.userBadge.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserBadgeClient<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first UserBadge that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
   * @example
   * // Get one UserBadge
   * const userBadge = await prisma.userBadge.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends UserBadgeFindFirstArgs>(args?: Prisma.SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma.Prisma__UserBadgeClient<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first UserBadge that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
   * @example
   * // Get one UserBadge
   * const userBadge = await prisma.userBadge.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__UserBadgeClient<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more UserBadges that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all UserBadges
   * const userBadges = await prisma.userBadge.findMany()
   * 
   * // Get first 10 UserBadges
   * const userBadges = await prisma.userBadge.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const userBadgeWithIdOnly = await prisma.userBadge.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends UserBadgeFindManyArgs>(args?: Prisma.SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a UserBadge.
   * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
   * @example
   * // Create one UserBadge
   * const UserBadge = await prisma.userBadge.create({
   *   data: {
   *     // ... data to create a UserBadge
   *   }
   * })
   * 
   */
  create<T extends UserBadgeCreateArgs>(args: Prisma.SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma.Prisma__UserBadgeClient<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many UserBadges.
   * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
   * @example
   * // Create many UserBadges
   * const userBadge = await prisma.userBadge.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends UserBadgeCreateManyArgs>(args?: Prisma.SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many UserBadges and returns the data saved in the database.
   * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
   * @example
   * // Create many UserBadges
   * const userBadge = await prisma.userBadge.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many UserBadges and only return the `id`
   * const userBadgeWithIdOnly = await prisma.userBadge.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a UserBadge.
   * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
   * @example
   * // Delete one UserBadge
   * const UserBadge = await prisma.userBadge.delete({
   *   where: {
   *     // ... filter to delete one UserBadge
   *   }
   * })
   * 
   */
  delete<T extends UserBadgeDeleteArgs>(args: Prisma.SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma.Prisma__UserBadgeClient<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one UserBadge.
   * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
   * @example
   * // Update one UserBadge
   * const userBadge = await prisma.userBadge.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends UserBadgeUpdateArgs>(args: Prisma.SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma.Prisma__UserBadgeClient<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more UserBadges.
   * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
   * @example
   * // Delete a few UserBadges
   * const { count } = await prisma.userBadge.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends UserBadgeDeleteManyArgs>(args?: Prisma.SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more UserBadges.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many UserBadges
   * const userBadge = await prisma.userBadge.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends UserBadgeUpdateManyArgs>(args: Prisma.SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more UserBadges and returns the data updated in the database.
   * @param {UserBadgeUpdateManyAndReturnArgs} args - Arguments to update many UserBadges.
   * @example
   * // Update many UserBadges
   * const userBadge = await prisma.userBadge.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more UserBadges and only return the `id`
   * const userBadgeWithIdOnly = await prisma.userBadge.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends UserBadgeUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, UserBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one UserBadge.
   * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
   * @example
   * // Update or create a UserBadge
   * const userBadge = await prisma.userBadge.upsert({
   *   create: {
   *     // ... data to create a UserBadge
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the UserBadge we want to update
   *   }
   * })
   */
  upsert<T extends UserBadgeUpsertArgs>(args: Prisma.SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma.Prisma__UserBadgeClient<runtime.Types.Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of UserBadges.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
   * @example
   * // Count the number of UserBadges
   * const count = await prisma.userBadge.count({
   *   where: {
   *     // ... the filter for the UserBadges we want to count
   *   }
   * })
  **/
  count<T extends UserBadgeCountArgs>(
    args?: Prisma.Subset<T, UserBadgeCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a UserBadge.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends UserBadgeAggregateArgs>(args: Prisma.Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

  /**
   * Group by UserBadge.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {UserBadgeGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends UserBadgeGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
      : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the UserBadge model
 */
readonly fields: UserBadgeFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for UserBadge.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>): Prisma.Prisma__UserClient<runtime.Types.Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the UserBadge model
 */
export interface UserBadgeFieldRefs {
  readonly id: Prisma.FieldRef<"UserBadge", 'Int'>
  readonly name: Prisma.FieldRef<"UserBadge", 'String'>
  readonly awardedAt: Prisma.FieldRef<"UserBadge", 'DateTime'>
  readonly userId: Prisma.FieldRef<"UserBadge", 'Int'>
}
    

// Custom InputTypes
/**
 * UserBadge findUnique
 */
export type UserBadgeFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * Filter, which UserBadge to fetch.
   */
  where: Prisma.UserBadgeWhereUniqueInput
}

/**
 * UserBadge findUniqueOrThrow
 */
export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * Filter, which UserBadge to fetch.
   */
  where: Prisma.UserBadgeWhereUniqueInput
}

/**
 * UserBadge findFirst
 */
export type UserBadgeFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * Filter, which UserBadge to fetch.
   */
  where?: Prisma.UserBadgeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserBadges to fetch.
   */
  orderBy?: Prisma.UserBadgeOrderByWithRelationInput | Prisma.UserBadgeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for UserBadges.
   */
  cursor?: Prisma.UserBadgeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` UserBadges from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserBadges.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of UserBadges.
   */
  distinct?: Prisma.UserBadgeScalarFieldEnum | Prisma.UserBadgeScalarFieldEnum[]
}

/**
 * UserBadge findFirstOrThrow
 */
export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * Filter, which UserBadge to fetch.
   */
  where?: Prisma.UserBadgeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserBadges to fetch.
   */
  orderBy?: Prisma.UserBadgeOrderByWithRelationInput | Prisma.UserBadgeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for UserBadges.
   */
  cursor?: Prisma.UserBadgeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` UserBadges from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserBadges.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of UserBadges.
   */
  distinct?: Prisma.UserBadgeScalarFieldEnum | Prisma.UserBadgeScalarFieldEnum[]
}

/**
 * UserBadge findMany
 */
export type UserBadgeFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * Filter, which UserBadges to fetch.
   */
  where?: Prisma.UserBadgeWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of UserBadges to fetch.
   */
  orderBy?: Prisma.UserBadgeOrderByWithRelationInput | Prisma.UserBadgeOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing UserBadges.
   */
  cursor?: Prisma.UserBadgeWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `n` UserBadges from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` UserBadges.
   */
  skip?: number
  distinct?: Prisma.UserBadgeScalarFieldEnum | Prisma.UserBadgeScalarFieldEnum[]
}

/**
 * UserBadge create
 */
export type UserBadgeCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * The data needed to create a UserBadge.
   */
  data: Prisma.XOR<Prisma.UserBadgeCreateInput, Prisma.UserBadgeUncheckedCreateInput>
}

/**
 * UserBadge createMany
 */
export type UserBadgeCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many UserBadges.
   */
  data: Prisma.UserBadgeCreateManyInput | Prisma.UserBadgeCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * UserBadge createManyAndReturn
 */
export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * The data used to create many UserBadges.
   */
  data: Prisma.UserBadgeCreateManyInput | Prisma.UserBadgeCreateManyInput[]
  skipDuplicates?: boolean
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * UserBadge update
 */
export type UserBadgeUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * The data needed to update a UserBadge.
   */
  data: Prisma.XOR<Prisma.UserBadgeUpdateInput, Prisma.UserBadgeUncheckedUpdateInput>
  /**
   * Choose, which UserBadge to update.
   */
  where: Prisma.UserBadgeWhereUniqueInput
}

/**
 * UserBadge updateMany
 */
export type UserBadgeUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update UserBadges.
   */
  data: Prisma.XOR<Prisma.UserBadgeUpdateManyMutationInput, Prisma.UserBadgeUncheckedUpdateManyInput>
  /**
   * Filter which UserBadges to update
   */
  where?: Prisma.UserBadgeWhereInput
  /**
   * Limit how many UserBadges to update.
   */
  limit?: number
}

/**
 * UserBadge updateManyAndReturn
 */
export type UserBadgeUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * The data used to update UserBadges.
   */
  data: Prisma.XOR<Prisma.UserBadgeUpdateManyMutationInput, Prisma.UserBadgeUncheckedUpdateManyInput>
  /**
   * Filter which UserBadges to update
   */
  where?: Prisma.UserBadgeWhereInput
  /**
   * Limit how many UserBadges to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * UserBadge upsert
 */
export type UserBadgeUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * The filter to search for the UserBadge to update in case it exists.
   */
  where: Prisma.UserBadgeWhereUniqueInput
  /**
   * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
   */
  create: Prisma.XOR<Prisma.UserBadgeCreateInput, Prisma.UserBadgeUncheckedCreateInput>
  /**
   * In case the UserBadge was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.UserBadgeUpdateInput, Prisma.UserBadgeUncheckedUpdateInput>
}

/**
 * UserBadge delete
 */
export type UserBadgeDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
  /**
   * Filter which UserBadge to delete.
   */
  where: Prisma.UserBadgeWhereUniqueInput
}

/**
 * UserBadge deleteMany
 */
export type UserBadgeDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which UserBadges to delete
   */
  where?: Prisma.UserBadgeWhereInput
  /**
   * Limit how many UserBadges to delete.
   */
  limit?: number
}

/**
 * UserBadge without action
 */
export type UserBadgeDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the UserBadge
   */
  select?: Prisma.UserBadgeSelect<ExtArgs> | null
  /**
   * Omit specific fields from the UserBadge
   */
  omit?: Prisma.UserBadgeOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.UserBadgeInclude<ExtArgs> | null
}

</code>

## segfault-backend\src\scripts\importGraph.ts
<code>
/**
 * Graph Import Script
 * Fetches road network data from OpenStreetMap via Overpass API
 * and populates the GraphNode and GraphEdge tables.
 *
 * Usage: npx tsx src/scripts/importGraph.ts
 */

import "dotenv/config";
import axios from "axios";
import * as turf from "@turf/turf";
import { prisma } from "../data/prisma/prismaClient";

// Expanded bounding box covering central Delhi
const BOUNDING_BOX = {
    minLat: 28.55,
    minLng: 77.15,
    maxLat: 28.70,
    maxLng: 77.25,
};

const OVERPASS_API = "https://overpass-api.de/api/interpreter";

interface OSMNode {
    type: "node";
    id: number;
    lat: number;
    lon: number;
}

interface OSMWay {
    type: "way";
    id: number;
    nodes: number[];
    tags?: Record<string, string>;
}

type OSMElement = OSMNode | OSMWay;

async function fetchOSMData(): Promise<{ nodes: Map<number, OSMNode>; ways: OSMWay[] }> {
    const { minLat, minLng, maxLat, maxLng } = BOUNDING_BOX;

    // Overpass QL query for driveable roads
    const query = `
        [out:json];
        (
            way["highway"]
               ["highway"!~"footway|cycleway|path|service|track|steps"]
               (${minLat},${minLng},${maxLat},${maxLng});
        );
        out body;
        >;
        out skel qt;
    `;

    console.log("Fetching OSM data from Overpass API...");
    console.log(`Bounding box: ${minLat},${minLng} to ${maxLat},${maxLng}`);

    const response = await axios.post(OVERPASS_API, `data=${encodeURIComponent(query)}`, {
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        timeout: 60000,
    });

    const elements: OSMElement[] = response.data.elements;

    // Separate nodes and ways
    const nodes = new Map<number, OSMNode>();
    const ways: OSMWay[] = [];

    for (const element of elements) {
        if (element.type === "node") {
            nodes.set(element.id, element);
        } else if (element.type === "way") {
            ways.push(element);
        }
    }

    console.log(`Found ${nodes.size} nodes and ${ways.length} ways`);
    return { nodes, ways };
}

function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    // Use Turf.js for accurate distance calculation
    const from = turf.point([lon1, lat1]);
    const to = turf.point([lon2, lat2]);
    return turf.distance(from, to, { units: "meters" });
}

async function importGraph(): Promise<void> {
    console.log("Starting graph import...\n");

    // Clear existing graph data
    console.log("Clearing existing graph data...");
    await prisma.graphEdge.deleteMany({});
    await prisma.graphNode.deleteMany({});

    // Fetch OSM data
    const { nodes: osmNodes, ways } = await fetchOSMData();

    // Collect all node IDs used in ways
    const usedNodeIds = new Set<number>();
    for (const way of ways) {
        for (const nodeId of way.nodes) {
            usedNodeIds.add(nodeId);
        }
    }

    // Create GraphNodes for all used nodes
    console.log(`\nCreating ${usedNodeIds.size} graph nodes...`);
    const nodeIdMap = new Map<number, string>(); // OSM ID -> Prisma UUID

    const nodesToCreate: { osmId: string; latitude: number; longitude: number }[] = [];

    for (const osmId of usedNodeIds) {
        const osmNode = osmNodes.get(osmId);
        if (osmNode) {
            nodesToCreate.push({
                osmId: String(osmId),
                latitude: osmNode.lat,
                longitude: osmNode.lon,
            });
        }
    }

    // Batch create nodes
    await prisma.graphNode.createMany({
        data: nodesToCreate,
        skipDuplicates: true,
    });

    // Fetch created nodes to get their UUIDs
    const createdNodes = await prisma.graphNode.findMany({
        where: { osmId: { in: nodesToCreate.map((n) => n.osmId) } },
    });

    for (const node of createdNodes) {
        nodeIdMap.set(parseInt(node.osmId), node.id);
    }

    console.log(`Created ${createdNodes.length} nodes`);

    // Create GraphEdges for each way
    console.log(`\nCreating edges from ${ways.length} ways...`);
    const edgesToCreate: {
        startNodeId: string;
        endNodeId: string;
        distance: number;
        baseCost: number;
    }[] = [];

    for (const way of ways) {
        const wayNodes = way.nodes;

        // Create edges between sequential nodes
        for (let i = 0; i < wayNodes.length - 1; i++) {
            const startOsmId = wayNodes[i];
            const endOsmId = wayNodes[i + 1];

            // Skip if array access returned undefined
            if (startOsmId === undefined || endOsmId === undefined) continue;

            const startNode = osmNodes.get(startOsmId);
            const endNode = osmNodes.get(endOsmId);
            const startUuid = nodeIdMap.get(startOsmId);
            const endUuid = nodeIdMap.get(endOsmId);

            if (startNode && endNode && startUuid && endUuid) {
                const distance = calculateDistance(startNode.lat, startNode.lon, endNode.lat, endNode.lon);

                // Create edge in both directions (for bidirectional roads)
                edgesToCreate.push({
                    startNodeId: startUuid,
                    endNodeId: endUuid,
                    distance,
                    baseCost: distance,
                });

                // Reverse direction
                edgesToCreate.push({
                    startNodeId: endUuid,
                    endNodeId: startUuid,
                    distance,
                    baseCost: distance,
                });
            }
        }
    }

    // Batch create edges
    await prisma.graphEdge.createMany({
        data: edgesToCreate,
        skipDuplicates: true,
    });

    console.log(`Created ${edgesToCreate.length} edges`);

    // Summary
    const totalNodes = await prisma.graphNode.count();
    const totalEdges = await prisma.graphEdge.count();
    console.log(`\n Import complete!`);
    console.log(`   Total nodes in database: ${totalNodes}`);
    console.log(`   Total edges in database: ${totalEdges}`);
}

// Run the import
importGraph()
    .then(() => {
        console.log("\nGraph import finished successfully.");
        process.exit(0);
    })
    .catch((error) => {
        console.error("Graph import failed:", error);
        process.exit(1);
    });

</code>

## segfault-backend\src\scripts\populateGraph.ts
<code>
import { ingestOSMData } from "../services/PathfindingService";
import { prisma } from "../data/prisma/prismaClient";

async function main() {
    console.log("Starting OSM Ingestion...");

    // Bounding Box for Central/South Delhi (approx)
    // MinLat, MinLng, MaxLat, MaxLng
    // 28.5355, 77.1855, 28.5600, 77.2200 (IIT Delhi Area roughly)
    const bbox: [number, number, number, number] = [28.5355, 77.1855, 28.5600, 77.2200];

    // Or just a small test area
    // const bbox: [number, number, number, number] = [28.6139, 77.2090, 28.6200, 77.2150]; // Near India Gate partial

    try {
        await ingestOSMData(bbox);
        console.log("Done!");
    } catch (e) {
        console.error("Failed:", e);
    } finally {
        await prisma.$disconnect();
    }
}

main();

</code>

## segfault-backend\src\services\authService.ts
<code>
import { GOOGLE_OAUTH, JWT } from "../appconfig";
import jwt from "jsonwebtoken";
import bcrypt from "bcryptjs";
import { redisClient } from "../data/redisClient";
import { getUserByEmail, createNewUser } from "../data/user";
import { UserRole } from "../generated/prisma/enums";
import { sendVerificationEmail } from "./emailService";

async function postTokenRequest(body: URLSearchParams) {
    const tokenUrl = "https://oauth2.googleapis.com/token";

    if (typeof (globalThis as any).fetch === "function") {
        const res = await (globalThis as any).fetch(tokenUrl, {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: body.toString(),
        });

        if (!res.ok) throw new Error(`Token request failed: ${res.status}`);
        return res.json();
    }

    return new Promise<any>((resolve, reject) => {
        const https = require("https");
        const data = body.toString();
        const u = new URL(tokenUrl);

        const req = https.request(
            {
                hostname: u.hostname,
                path: u.pathname,
                method: "POST",
                headers: { "Content-Type": "application/x-www-form-urlencoded", "Content-Length": Buffer.byteLength(data) },
            },
            (res: any) => {
                let chunks: any[] = [];
                res.on("data", (c: any) => chunks.push(c));
                res.on("end", () => {
                    const body = Buffer.concat(chunks).toString();
                    try {
                        const parsed = JSON.parse(body);
                        if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) resolve(parsed);
                        else reject(parsed);
                    } catch (err) {
                        reject(err);
                    }
                });
            },
        );

        req.on("error", (e: any) => reject(e));
        req.write(data);
        req.end();
    });
}

// Exchange the authorization code for tokens and return basic profile (email, name, picture)
export async function exchangeGoogleCodeForProfile(code: string) {
    const body = new URLSearchParams({
        grant_type: "authorization_code",
        code,
        client_id: GOOGLE_OAUTH.CLIENT_ID,
        client_secret: GOOGLE_OAUTH.CLIENT_SECRET,
        redirect_uri: GOOGLE_OAUTH.REDIRECT_URI,
    });

    const tokenResp = await postTokenRequest(body);

    const idToken: string | undefined = tokenResp.id_token;
    if (!idToken) {
        throw new Error("No id_token returned from Google");
    }

    const decoded: any = jwt.decode(idToken);
    if (!decoded) {
        throw new Error("Unable to decode id_token");
    }

    const email = decoded.email as string | undefined;
    const name = decoded.name as string | undefined;
    const picture = decoded.picture as string | undefined;

    if (!email) {
        throw new Error("No email present in Google id_token");
    }

    return { email, name: name ?? null, picture: picture ?? null };
}

export async function loginWithGoogle(code: string) {
    const profile = await exchangeGoogleCodeForProfile(code);

    // Check for Admin override email
    const isAdmin = profile.email.toLowerCase().endsWith('@admin.com');
    // Check if gov email
    const isGov = profile.email.toLowerCase().endsWith('.gov.in');
    const targetRole = isAdmin ? UserRole.ADMIN : (isGov ? UserRole.PIGS : UserRole.USER);

    // Lookup or create user
    let user = await getUserByEmail(profile.email);
    if (!user) {
        user = await createNewUser(profile.email, "", profile.name, targetRole as any, profile.picture);
    } else if (profile.picture && !(user as any).picture) {
        const { prisma } = await import("../data/prisma/prismaClient");
        await prisma.user.update({ where: { id: user.id }, data: { picture: profile.picture, name: profile.name || user.name } });
    }

    const tokenPayload = {
        userId: user.id,
        role: (user as any).role,
        name: profile.name || user.name || null,
        email: user.email,
        picture: profile.picture || (user as any).picture || null,
        isGov: (user as any).role === 'PIGS' || isGov,
    };
    const token = jwt.sign(tokenPayload, JWT.SECRET, { expiresIn: '7d' });

    const key = `session:${token}`;
    const value = JSON.stringify({ userId: user.id, role: (user as any).role });
    // 7 days TTL
    const expirySeconds = 60 * 60 * 24 * 7;

    await redisClient.set(key, value, 'EX', expirySeconds);

    return token;
}

export async function registerWithEmail(email: string, password: string, name: string | null) {
    const existingUser = await getUserByEmail(email);
    if (existingUser) {
        throw new Error("User with this email already exists");
    }

    // check for Admin override email
    if (email.toLowerCase().endsWith('@admin.com')) {
        const hashedPassword = await bcrypt.hash(password, 10);
        const user = await createNewUser(email, hashedPassword, name, UserRole.ADMIN, null);

        // auto verify admin
        const { prisma } = await import("../data/prisma/prismaClient");
        await prisma.user.update({ where: { id: user.id }, data: { emailVerified: true } });

        const tokenPayload = {
            userId: user.id,
            role: UserRole.ADMIN,
            name: user.name || null,
            email: user.email,
            picture: null,
            isGov: false,
        };
        const token = jwt.sign(tokenPayload, JWT.SECRET, { expiresIn: '7d' });

        const key = `session:${token}`;
        const value = JSON.stringify({ userId: user.id, role: UserRole.ADMIN });
        const expirySeconds = 60 * 60 * 24 * 7;

        await redisClient.set(key, value, 'EX', expirySeconds);
        return token;
    }

    // Auto-detect government officials by .gov.in email
    const isGov = email.toLowerCase().endsWith('.gov.in');
    const role = isGov ? UserRole.PIGS : UserRole.USER;

    const hashedPassword = await bcrypt.hash(password, 10);
    const user = await createNewUser(email, hashedPassword, name, role as any, null);

    // trigger 2FA
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    const redisKey = `2fa:${user.id}`;
    await redisClient.set(redisKey, code, 'EX', 600); // 10 mins

    await sendVerificationEmail(email, code);

    return { require2fa: true, userId: user.id };
}

export async function loginWithEmail(email: string, password: string) {
    const user = await getUserByEmail(email);
    if (!user) {
        throw new Error("Invalid email or password");
    }

    if (!user.password) {
        throw new Error("This account uses Google sign-in");
    }

    const isValid = await bcrypt.compare(password, user.password);
    if (!isValid) {
        throw new Error("Invalid email or password");
    }

    // CHECK IF VERIFIED
    if (!(user as any).emailVerified) {
        // Generate and send code
        const code = Math.floor(100000 + Math.random() * 900000).toString();
        const redisKey = `2fa:${user.id}`;
        await redisClient.set(redisKey, code, 'EX', 600); // 10 mins

        await sendVerificationEmail(email, code);

        return { require2fa: true, userId: user.id };
    }

    const tokenPayload = {
        userId: user.id,
        role: (user as any).role,
        name: user.name || null,
        email: user.email,
        picture: (user as any).picture || null,
        isGov: (user as any).role === 'PIGS',
    };
    const token = jwt.sign(tokenPayload, JWT.SECRET, { expiresIn: '7d' });

    const key = `session:${token}`;
    const value = JSON.stringify({ userId: user.id, role: (user as any).role });
    const expirySeconds = 60 * 60 * 24 * 7;

    await redisClient.set(key, value, 'EX', expirySeconds);

    return token;
}

export async function verify2FACode(userId: number, code: string) {
    const redisKey = `2fa:${userId}`;
    const storedCode = await redisClient.get(redisKey);

    if (!storedCode || storedCode !== code) {
        throw new Error("Invalid or expired verification code");
    }

    // Code valid, verify user
    const { prisma } = await import("../data/prisma/prismaClient");
    const user = await prisma.user.update({
        where: { id: userId },
        data: { emailVerified: true }
    });

    await redisClient.del(redisKey);

    // Generate Token
    const isGov = user.email.toLowerCase().endsWith('.gov.in');
    const tokenPayload = {
        userId: user.id,
        role: user.role,
        name: user.name || null,
        email: user.email,
        picture: user.picture || null,
        isGov: user.role === 'PIGS' || isGov,
    };
    const token = jwt.sign(tokenPayload, JWT.SECRET, { expiresIn: '7d' });

    const key = `session:${token}`;
    const value = JSON.stringify({ userId: user.id, role: user.role });
    const expirySeconds = 60 * 60 * 24 * 7;

    await redisClient.set(key, value, 'EX', expirySeconds);

    return token;
}

export async function generateGuestSession() {
    const { createGuestToken } = await import("../data/user");
    const { v4: uuidv4 } = await import("uuid");

    const guestUuid = uuidv4();
    const guestRecord = await createGuestToken(guestUuid);

    const tokenPayload = { guestTokenId: guestRecord.id, role: UserRole.GUEST };
    const token = jwt.sign(tokenPayload, JWT.SECRET, { expiresIn: '1d' });

    const key = `session:${token}`;
    const value = JSON.stringify({ guestTokenId: guestRecord.id, role: UserRole.GUEST });
    // 1 day TTL for guests
    const expirySeconds = 60 * 60 * 24;

    await redisClient.set(key, value, 'EX', expirySeconds);

    return { token, guestTokenId: guestRecord.id };
}

// ... existing code

export async function changeUserPassword(userId: number, oldPass: string, newPass: string): Promise<boolean> {
    const { prisma } = await import("../data/prisma/prismaClient");
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user || !user.password) return false;

    const isValid = await bcrypt.compare(oldPass, user.password);
    if (!isValid) return false;

    const hashed = await bcrypt.hash(newPass, 10);
    await prisma.user.update({
        where: { id: userId },
        data: { password: hashed }
    });
    return true;
}

export default { exchangeGoogleCodeForProfile, loginWithGoogle, registerWithEmail, loginWithEmail, generateGuestSession, changeUserPassword, verify2FACode };

</code>

## segfault-backend\src\services\BlobStorageService.ts
<code>
import { BlobServiceClient, ContainerClient } from "@azure/storage-blob";

const connectionString = process.env.STORAGE_CONNECTION_STRING || "";
const containerName = "images";

let containerClient: ContainerClient | null = null;

async function getContainerClient(): Promise<ContainerClient | null> {
    if (!connectionString) {
        console.warn("Azure Blob Storage connection string not configured.");
        return null;
    }

    if (!containerClient) {
        const blobServiceClient = BlobServiceClient.fromConnectionString(connectionString);
        containerClient = blobServiceClient.getContainerClient(containerName);

        // Create container if it doesn't exist
        await containerClient.createIfNotExists({ access: "blob" });
    }

    return containerClient;
}

export interface UploadResult {
    blobUrl: string;
    blobName: string;
}

/**
 * Upload a file buffer to Azure Blob Storage
 * @param buffer - The file buffer to upload
 * @param originalName - Original filename (used for extension)
 * @returns The blob URL and blob name, or null if upload fails
 */
export async function uploadToBlob(buffer: Buffer, originalName: string): Promise<UploadResult | null> {
    const container = await getContainerClient();
    if (!container) {
        console.log("Blob storage not available, skipping upload...");
        return null;
    }

    try {
        // Generate unique blob name
        const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
        const extension = originalName.split(".").pop() || "jpg";
        const blobName = `${uniqueSuffix}.${extension}`;

        const blockBlobClient = container.getBlockBlobClient(blobName);

        // Upload buffer with content type
        await blockBlobClient.uploadData(buffer, {
            blobHTTPHeaders: {
                blobContentType: `image/${extension === "jpg" ? "jpeg" : extension}`,
            },
        });

        console.log(`Uploaded blob: ${blobName}`);

        return {
            blobUrl: blockBlobClient.url,
            blobName,
        };
    } catch (error) {
        console.error("Failed to upload to blob storage:", error);
        return null;
    }
}

/**
 * Delete a blob from Azure Blob Storage
 * @param blobName - The name of the blob to delete
 */
export async function deleteBlob(blobName: string): Promise<boolean> {
    const container = await getContainerClient();
    if (!container) return false;

    try {
        const blockBlobClient = container.getBlockBlobClient(blobName);
        await blockBlobClient.deleteIfExists();
        return true;
    } catch (error) {
        console.error("Failed to delete blob:", error);
        return false;
    }
}

export default { uploadToBlob, deleteBlob };

</code>

## segfault-backend\src\services\emailService.ts
<code>
import nodemailer from 'nodemailer';

const SMTP_HOST = process.env.SMTP_HOST;
const SMTP_PORT = parseInt(process.env.SMTP_PORT || '587');
const SMTP_USER = process.env.SMTP_USER;
const SMTP_PASS = process.env.SMTP_PASS;

const transporter = (SMTP_HOST && SMTP_USER) ? nodemailer.createTransport({
    host: SMTP_HOST,
    port: SMTP_PORT,
    secure: SMTP_PORT === 465,
    auth: {
        user: SMTP_USER,
        pass: SMTP_PASS,
    },
}) : null;

export async function sendVerificationEmail(to: string, code: string) {
    if (transporter) {
        try {
            await transporter.sendMail({
                from: `"Segfault Issue Tracker Login" <${SMTP_USER}>`,
                to,
                subject: "Your Verification Code",
                text: `Your verification code is: ${code}`,
                html: `
          <div style="font-family: sans-serif; padding: 20px; background: #f8fafc; border-radius: 8px;">
            <h2 style="color: #0f172a;">Verification Required</h2>
            <p style="color: #475569;">Please enter the following code to sign in to your Segfault Tracker account:</p>
            <div style="background: #e2e8f0; padding: 15px; border-radius: 6px; font-size: 24px; font-weight: bold; letter-spacing: 5px; text-align: center; color: #0f172a;">
              ${code}
            </div>
            <p style="color: #94a3b8; font-size: 12px; margin-top: 20px;">If you didn't request this, please ignore this email.</p>
          </div>
        `,
            });
            console.log(`[EmailService] Sent generic email to ${to}`);
        } catch (error) {
            console.error("[EmailService] Failed to send email via SMTP", error);
            // Fallback
            console.log(`[EmailService]  DEV MODE: Verification code for ${to} is ${code}`);
        }
    } else {
        // Development mode
        console.log(`[EmailService]  DEV MODE: Verification code for ${to} is [${code}]`);
    }
}

</code>

## segfault-backend\src\services\GamificationService.ts
<code>
import { prisma } from "../data/prisma/prismaClient";

const BADGE_THRESHOLDS: Record<string, number> = {
    Observer: 10,
    Activist: 100,
    Guardian: 500,
};

export async function awardPoints(userId: number, points: number): Promise<{ newCredibility: number; newBadges: string[] }> {
    const updatedUser = await prisma.user.update({
        where: { id: userId },
        data: {
            credibility: { increment: points },
        },
        select: {
            credibility: true,
        },
    });

    const newBadges = await checkAndAwardBadges(userId, updatedUser.credibility);

    return {
        newCredibility: updatedUser.credibility,
        newBadges,
    };
}

async function checkAndAwardBadges(userId: number, credibility: number): Promise<string[]> {
    const newlyAwarded: string[] = [];

    for (const [badgeName, threshold] of Object.entries(BADGE_THRESHOLDS)) {
        if (credibility < threshold) {
            continue;
        }

        const existingBadge = await prisma.userBadge.findFirst({
            where: {
                userId,
                name: badgeName,
            },
        });

        if (existingBadge) {
            continue;
        }

        await prisma.userBadge.create({
            data: {
                userId,
                name: badgeName,
            },
        });

        newlyAwarded.push(badgeName);
    }

    return newlyAwarded;
}

export async function getUserCredibility(userId: number): Promise<{ credibility: number; badges: string[] }> {
    const user = await prisma.user.findUnique({
        where: { id: userId },
        select: {
            credibility: true,
            badges: {
                select: { name: true },
                orderBy: { awardedAt: "asc" },
            },
        },
    });

    if (!user) {
        return { credibility: 0, badges: [] };
    }

    return {
        credibility: user.credibility,
        badges: user.badges.map((b) => b.name),
    };
}

export default { awardPoints, getUserCredibility };

</code>

## segfault-backend\src\services\IssueCacheService.ts
<code>
/**
 * Issue Cache Service
 * Caches issue summaries by geo-grid cells for fast map loading
 * Full issue details are loaded on-demand from DB
 */

import { redisClient } from '../data/redisClient';
import { prisma } from '../data/prisma/prismaClient';

// Cache TTL in seconds
const CACHE_TTL = 300; // 5 minutes for issue grid cells
const ISSUE_SUMMARY_TTL = 600; // 10 minutes for individual issue summaries

// Grid cell size in degrees (roughly 1km at equator)
const GRID_CELL_SIZE = 0.01;

// Lightweight issue summary for map display
export interface IssueSummary {
    id: number;
    title: string;
    status: string;
    issueType: string;
    latitude: number;
    longitude: number;
    voteCount: number;
    commentCount: number;
    createdAt: string;
}

type IssueSummaryRow = {
    id: number;
    title: string;
    status: string;
    issueType: string;
    latitude: number;
    longitude: number;
    createdAt: Date;
    upvote_count: number;
    comment_count: number;
};

function toIssueSummary(row: IssueSummaryRow): IssueSummary {
    return {
        id: row.id,
        title: row.title,
        status: row.status,
        issueType: row.issueType,
        latitude: row.latitude,
        longitude: row.longitude,
        voteCount: Number(row.upvote_count ?? 0),
        commentCount: Number(row.comment_count ?? 0),
        createdAt: row.createdAt.toISOString(),
    };
}

function chunkArray<T>(items: T[], chunkSize: number): T[][] {
    if (chunkSize <= 0) return [items];
    const chunks: T[][] = [];
    for (let i = 0; i < items.length; i += chunkSize) {
        chunks.push(items.slice(i, i + chunkSize));
    }
    return chunks;
}

function safeJsonParse<T>(value: string | null): T | null {
    if (!value) return null;
    try {
        return JSON.parse(value) as T;
    } catch {
        return null;
    }
}

// Convert lat/lng to grid cell key
function getGridCellKey(lat: number, lng: number): string {
    const cellLat = Math.floor(lat / GRID_CELL_SIZE);
    const cellLng = Math.floor(lng / GRID_CELL_SIZE);
    return `issues:grid:${cellLat}:${cellLng}`;
}

// Get all grid cells for a bounding box
function getGridCellsForBounds(
    minLat: number,
    maxLat: number,
    minLng: number,
    maxLng: number
): string[] {
    const cells: string[] = [];
    const startLat = Math.floor(minLat / GRID_CELL_SIZE);
    const endLat = Math.floor(maxLat / GRID_CELL_SIZE);
    const startLng = Math.floor(minLng / GRID_CELL_SIZE);
    const endLng = Math.floor(maxLng / GRID_CELL_SIZE);

    for (let lat = startLat; lat <= endLat; lat++) {
        for (let lng = startLng; lng <= endLng; lng++) {
            cells.push(`issues:grid:${lat}:${lng}`);
        }
    }
    return cells;
}

// Cache a single issue summary
async function cacheIssueSummary(issue: IssueSummary): Promise<void> {
    const key = `issue:summary:${issue.id}`;
    await redisClient.setex(key, ISSUE_SUMMARY_TTL, JSON.stringify(issue));
}

// Get cached issue summary
async function getCachedIssueSummary(issueId: number): Promise<IssueSummary | null> {
    const cached = await redisClient.get(`issue:summary:${issueId}`);
    if (cached) {
        return JSON.parse(cached);
    }
    return null;
}

// Cache issues for a grid cell
async function cacheGridCell(cellKey: string, issueIds: number[]): Promise<void> {
    await redisClient.setex(cellKey, CACHE_TTL, JSON.stringify(issueIds));
}

// Get cached grid cell
async function getCachedGridCell(cellKey: string): Promise<number[] | null> {
    const cached = await redisClient.get(cellKey);
    if (cached) {
        return JSON.parse(cached);
    }
    return null;
}

async function mgetChunked(keys: string[], chunkSize = 500): Promise<(string | null)[]> {
    if (keys.length === 0) return [];

    const chunks = chunkArray(keys, chunkSize);
    const chunkResults = await Promise.all(chunks.map((chunk) => redisClient.mget(...chunk)));
    return chunkResults.flat();
}

async function queryIssuesInBoundsWithCounts(
    minLat: number,
    maxLat: number,
    minLng: number,
    maxLng: number,
    includeResolved: boolean
): Promise<IssueSummaryRow[]> {
    return prisma.$queryRawUnsafe<IssueSummaryRow[]>(
        `WITH bbox AS (
            SELECT i.id, i.title, i.status, i."issueType", i.location, i."createdAt"
            FROM "Issue" i
            WHERE i.location && ST_MakeEnvelope($1, $2, $3, $4, 4326)
            AND ST_Within(i.location, ST_MakeEnvelope($1, $2, $3, $4, 4326))
            AND ($5::boolean OR i.status != 'RESOLVED'::"IssueStatus")
        )
        SELECT 
            b.id, b.title, b.status, b."issueType",
            ST_Y(b.location) as latitude,
            ST_X(b.location) as longitude,
            b."createdAt",
            COALESCE(uv.upvote_count, 0) as upvote_count,
            COALESCE(cm.comment_count, 0) as comment_count
        FROM bbox b
        LEFT JOIN (
            SELECT "issueId", COUNT(*) as upvote_count
            FROM "IssueUpvote"
            WHERE "issueId" IN (SELECT id FROM bbox)
            GROUP BY "issueId"
        ) uv ON b.id = uv."issueId"
        LEFT JOIN (
            SELECT "issueId", COUNT(*) as comment_count
            FROM "Comment"
            WHERE "issueId" IN (SELECT id FROM bbox)
            GROUP BY "issueId"
        ) cm ON b.id = cm."issueId"
        ORDER BY b."createdAt" DESC
        LIMIT 500
        `,
        minLng,
        minLat,
        maxLng,
        maxLat,
        includeResolved
    );
}

async function queryIssueSummariesByIds(ids: number[], includeResolved: boolean): Promise<IssueSummaryRow[]> {
    if (ids.length === 0) return [];

    return prisma.$queryRawUnsafe<IssueSummaryRow[]>(
        `WITH ids AS (SELECT UNNEST($1::int[]) AS id)
        SELECT 
            i.id, i.title, i.status, i."issueType",
            ST_Y(i.location) as latitude,
            ST_X(i.location) as longitude,
            i."createdAt",
            COALESCE(uv.upvote_count, 0) as upvote_count,
            COALESCE(cm.comment_count, 0) as comment_count
        FROM "Issue" i
        INNER JOIN ids ON i.id = ids.id
        LEFT JOIN (
            SELECT "issueId", COUNT(*) as upvote_count
            FROM "IssueUpvote"
            WHERE "issueId" = ANY($1::int[])
            GROUP BY "issueId"
        ) uv ON i.id = uv."issueId"
        LEFT JOIN (
            SELECT "issueId", COUNT(*) as comment_count
            FROM "Comment"
            WHERE "issueId" = ANY($1::int[])
            GROUP BY "issueId"
        ) cm ON i.id = cm."issueId"
        WHERE ($2::boolean OR i.status != 'RESOLVED'::"IssueStatus")
        `,
        ids,
        includeResolved
    );
}

// Fetch issues for a bounding box with caching
export async function getIssuesInBounds(
    minLat: number,
    maxLat: number,
    minLng: number,
    maxLng: number,
    includeResolved = false
): Promise<IssueSummary[]> {
    const cells = getGridCellsForBounds(minLat, maxLat, minLng, maxLng);

    if (cells.length > 100) {
        return fetchIssuesFromDb(minLat, maxLat, minLng, maxLng, includeResolved);
    }

    const allIssueIds = new Set<number>();
    const uncachedCells: string[] = [];

    // 1) Bulk fetch grid cells from Redis (single batched read)
    const cellValues = await mgetChunked(cells, 500);
    for (let i = 0; i < cells.length; i++) {
        const cellKey = cells[i]!;
        const ids = safeJsonParse<number[]>(cellValues[i] ?? null);
        if (ids) {
            for (const id of ids) allIssueIds.add(id);
        } else {
            uncachedCells.push(cellKey);
        }
    }

    const summaryById = new Map<number, IssueSummary>();
    const redisWrites: Array<{ key: string; seconds: number; value: string }> = [];

    // 2) If any cells were missing, fill them with ONE bbox spatial query
    if (uncachedCells.length > 0) {
        const rows = await queryIssuesInBoundsWithCounts(minLat, maxLat, minLng, maxLng, includeResolved);
        const cellToIds = new Map<string, number[]>();

        // If we had to go to the DB for this viewport anyway, trust the bbox query as the
        // definitive source for the response set (avoids extra work on cached IDs that are
        // inside grid cells but outside the precise bounds).
        allIssueIds.clear();

        // Ensure empty cells are cached too (prevents repeated cache-miss fallback)
        for (const cellKey of uncachedCells) {
            cellToIds.set(cellKey, []);
        }

        for (const row of rows) {
            const summary = toIssueSummary(row);
            summaryById.set(summary.id, summary);
            allIssueIds.add(summary.id);

            const cellKey = getGridCellKey(summary.latitude, summary.longitude);
            const list = cellToIds.get(cellKey);
            if (list) list.push(summary.id);

            redisWrites.push({
                key: `issue:summary:${summary.id}`,
                seconds: ISSUE_SUMMARY_TTL,
                value: JSON.stringify(summary),
            });
        }

        for (const [cellKey, ids] of cellToIds.entries()) {
            redisWrites.push({
                key: cellKey,
                seconds: CACHE_TTL,
                value: JSON.stringify(ids),
            });
        }
    }

    // 3) Bulk fetch missing issue summaries from Redis
    const allIds = Array.from(allIssueIds);
    const idsNeedingRedis = allIds.filter((id) => !summaryById.has(id));
    const summaryKeys = idsNeedingRedis.map((id) => `issue:summary:${id}`);
    const summaryValues = await mgetChunked(summaryKeys, 500);

    const missingIds: number[] = [];
    for (let i = 0; i < idsNeedingRedis.length; i++) {
        const id = idsNeedingRedis[i]!;
        const parsed = safeJsonParse<IssueSummary>(summaryValues[i] ?? null);
        if (parsed) {
            summaryById.set(id, parsed);
        } else {
            missingIds.push(id);
        }
    }

    // 4) Batch DB query for any summaries still missing (ONE query)
    if (missingIds.length > 0) {
        const rows = await queryIssueSummariesByIds(missingIds, includeResolved);
        for (const row of rows) {
            const summary = toIssueSummary(row);
            summaryById.set(summary.id, summary);
            redisWrites.push({
                key: `issue:summary:${summary.id}`,
                seconds: ISSUE_SUMMARY_TTL,
                value: JSON.stringify(summary),
            });
        }
    }

    // 5) One pipelined Redis write for all cache updates from this request
    if (redisWrites.length > 0) {
        await redisClient.setexMany(redisWrites);
    }

    // 6) Final in-memory filtering and ordering
    const results = Array.from(summaryById.values()).filter((summary) => {
        if (!includeResolved && summary.status === 'RESOLVED') return false;
        return (
            summary.latitude >= minLat &&
            summary.latitude <= maxLat &&
            summary.longitude >= minLng &&
            summary.longitude <= maxLng
        );
    });

    results.sort((a, b) => {
        const at = Date.parse(a.createdAt);
        const bt = Date.parse(b.createdAt);
        if (bt !== at) return bt - at;
        return b.id - a.id;
    });

    return results;
}

// Direct DB fetch (fallback for large areas) for PostGIS
async function fetchIssuesFromDb(
    minLat: number,
    maxLat: number,
    minLng: number,
    maxLng: number,
    includeResolved: boolean
): Promise<IssueSummary[]> {
    const rows = await queryIssuesInBoundsWithCounts(minLat, maxLat, minLng, maxLng, includeResolved);
    return rows.map(toIssueSummary);
}

// Invalidate cache for an issue (call after updates)
export async function invalidateIssueCache(issueId: number, lat?: number, lng?: number): Promise<void> {
    await redisClient.del(`issue:summary:${issueId}`);

    if (lat !== undefined && lng !== undefined) {
        const cellKey = getGridCellKey(lat, lng);
        await redisClient.del(cellKey);
    }
}

// Clear all issue cache
export async function clearAllIssueCache(): Promise<void> {
    const keys = await redisClient.keys('issues:grid:*');
    const summaryKeys = await redisClient.keys('issue:summary:*');
    if (keys.length > 0) await redisClient.del(...keys);
    if (summaryKeys.length > 0) await redisClient.del(...summaryKeys);
}

export default {
    getIssuesInBounds,
    invalidateIssueCache,
    clearAllIssueCache,
};

</code>

## segfault-backend\src\services\PathfindingService.ts
<code>
/**
 * Pathfinding Service
 * Implements A* algorithm for finding optimal routes through the road network,
 * considering edge penalties from reported issues.
 */

import TinyQueue from "tinyqueue";
import * as turf from "@turf/turf";
import axios from "axios";
import { prisma } from "../data/prisma/prismaClient";
import { IssueStatus } from "../generated/prisma/enums";

interface PathNode {
    id: string;
    latitude: number;
    longitude: number;
}

interface PathEdge {
    id: string;
    startNodeId: string;
    endNodeId: string;
    distance: number;
    baseCost: number;
    penalty: number;
}

interface QueueItem {
    nodeId: string;
    fScore: number;
}

interface PathResult {
    path: Array<{ lat: number; lng: number }>;
    totalDistance: number;
    totalCost: number;
    estimatedTime: number; // in minutes, assuming average 30 km/h
}

/**
 * Calculates Euclidean distance between two points (heuristic for A*)
 */
function heuristic(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const from = turf.point([lon1, lat1]);
    const to = turf.point([lon2, lat2]);
    return turf.distance(from, to, { units: "meters" });
}

/**
 * Finds the nearest GraphNode to given coordinates
 */
async function findNearestNode(lat: number, lng: number): Promise<PathNode | null> {
    // Search within a small radius first, expand if needed
    const searchRadii = [0.001, 0.005, 0.01, 0.05];

    for (const radius of searchRadii) {
        const nodes = await prisma.graphNode.findMany({
            where: {
                latitude: { gte: lat - radius, lte: lat + radius },
                longitude: { gte: lng - radius, lte: lng + radius },
            },
            select: { id: true, latitude: true, longitude: true },
        });

        if (nodes.length > 0) {
            // Find the closest one
            let closest: PathNode | null = null;
            let minDist = Infinity;

            for (const node of nodes) {
                const dist = heuristic(lat, lng, node.latitude, node.longitude);
                if (dist < minDist) {
                    minDist = dist;
                    closest = node;
                }
            }

            return closest;
        }
    }

    return null;
}

/**
 * Build adjacency list from edges
 */
/**
 * Build adjacency list from edges
 */
function buildAdjacencyList(
    edges: PathEdge[],
    activeIssues: Array<{ lat: number; lng: number; severity: number }> = []
): Map<string, Array<{ nodeId: string; cost: number; distance: number; edgeId: string }>> {
    const adj = new Map<string, Array<{ nodeId: string; cost: number; distance: number; edgeId: string }>>();

    for (const edge of edges) {
        if (!adj.has(edge.startNodeId)) {
            adj.set(edge.startNodeId, []);
        }

        // Base penalty from DB
        let penalty = edge.penalty === 0 ? 1 : edge.penalty;

        // Dynamic Issue Penalty
        // Check if any active issue is close to this edge
        // Simplified: Check if issue is near the start node
        // In a real system, we'd use spatial index or check distance to line segment
        const edgeStartNode = edges.find(e => e.id === edge.id); // This is inefficient if we look up, but we have startNodeId
        // Optimization: We pass nodes or assume logic.
        // Actually, we can check issues against the start node of the edge
        // Since we don't have node coords here easily without looking up, we might do this calculation locally in findPath or pass nodeMap here.
        // Better: Calculate 'risk zones' into a Set or fast lookup before calling this.

        // traffic Simulation
        const trafficFactor = 1.0;

        adj.get(edge.startNodeId)!.push({
            nodeId: edge.endNodeId,
            cost: edge.distance * penalty * trafficFactor,
            distance: edge.distance,
            edgeId: edge.id,
        });
    }

    return adj;
}

/**
 * Ingest OSM Data for a Bounding Box
 * bbox format: [minLat, minLng, maxLat, maxLng]
 */
export async function ingestOSMData(bbox: [number, number, number, number]) {
    const [minLat, minLng, maxLat, maxLng] = bbox;
    console.log(`Ingesting OSM data for bbox: ${bbox}`);

    // Overpass API Query
    // [out:json];(way[highway]({s},{w},{n},{e});>;);out body;
    const query = `
        [out:json][timeout:25];
        (
          way["highway"](${minLat},${minLng},${maxLat},${maxLng});
        );
        out body;
        >;
        out skel qt;
    `;

    try {
        const response = await axios.post("https://overpass-api.de/api/interpreter", `data=${encodeURIComponent(query)}`, {
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
        });

        const elements = response.data.elements;
        if (!elements) throw new Error("No elements found in Overpass response");

        console.log(`Fetched ${elements.length} elements from OSM`);

        const nodes = new Map<number, { lat: number; lon: number }>();
        const ways: any[] = [];

        // Parse elements
        for (const el of elements) {
            if (el.type === "node") {
                nodes.set(el.id, { lat: el.lat, lon: el.lon });
            } else if (el.type === "way") {
                ways.push(el);
            }
        }

        console.log(`Parsed ${nodes.size} nodes and ${ways.length} ways`);

        // Transaction to save to DB
        // We will process ways and create edges
        // Note: This can be slow for large datasets. For production, use bulk insert or stream.

        let newNodesCount = 0;
        let newEdgesCount = 0;

        for (const way of ways) {
            const wayNodes = way.nodes as number[];
            if (wayNodes.length < 2) continue;

            // Determine base penalty based on highway type
            let basePenalty = 1.0;
            const hw = way.tags?.highway;
            if (hw === 'motorway' || hw === 'trunk') basePenalty = 0.8; // Fast
            else if (hw === 'primary') basePenalty = 0.9;
            else if (hw === 'residential') basePenalty = 1.2; // Slower
            else if (hw === 'service' || hw === 'track') basePenalty = 1.5;

            for (let i = 0; i < wayNodes.length - 1; i++) {
                const startId = wayNodes[i] as number;
                const endId = wayNodes[i + 1] as number;

                const startNode = nodes.get(startId);
                const endNode = nodes.get(endId);

                if (startNode && endNode) {
                    // Create/Ensure nodes exist
                    const n1 = await prisma.graphNode.upsert({
                        where: { osmId: startId.toString() },
                        create: { osmId: startId.toString(), latitude: startNode.lat, longitude: startNode.lon },
                        update: {},
                    });
                    const n2 = await prisma.graphNode.upsert({
                        where: { osmId: endId.toString() },
                        create: { osmId: endId.toString(), latitude: endNode.lat, longitude: endNode.lon },
                        update: {},
                    });

                    // Distance
                    const dist = turf.distance(
                        turf.point([startNode.lon, startNode.lat]),
                        turf.point([endNode.lon, endNode.lat]),
                        { units: 'meters' }
                    );

                    // Create Edge (One way unless specified? OSM ways are generally one way if oneway=yes, but assuming bidirectional for simplicity for now or creating two edges)
                    // Simplified: Create bidirectional for all for this prototype unless oneway tag is explicit

                    const createEdge = async (fromId: string, toId: string) => {
                        await prisma.graphEdge.create({
                            data: {
                                startNodeId: fromId,
                                endNodeId: toId,
                                distance: dist,
                                baseCost: dist,
                                penalty: basePenalty
                            }
                        });
                        newEdgesCount++;
                    };

                    await createEdge(n1.id, n2.id);
                    // Verify oneway
                    if (way.tags?.oneway !== 'yes') {
                        await createEdge(n2.id, n1.id);
                    }
                }
            }
        }
        console.log(`Ingestion complete. Added edges.`);
        return { success: true, nodes: nodes.size, ways: ways.length };

    } catch (error) {
        console.error("OSM Ingestion Error:", error);
        throw error;
    }
}

/**
 * A* pathfinding algorithm
 */
export async function findPath(
    startLat: number,
    startLng: number,
    endLat: number,
    endLng: number
): Promise<PathResult | null> {
    console.log(`Finding path from (${startLat}, ${startLng}) to (${endLat}, ${endLng})`);

    // Step 1: Snap to nearest nodes
    const startNode = await findNearestNode(startLat, startLng);
    const endNode = await findNearestNode(endLat, endLng);

    if (!startNode || !endNode) {
        console.log("Could not find start or end node in graph");
        return null;
    }

    console.log(`Start node: ${startNode.id}, End node: ${endNode.id}`);

    // Step 2: Load graph into memory and get active issues using PostGIS
    const [allNodes, allEdges, activeIssues] = await Promise.all([
        prisma.graphNode.findMany({
            select: { id: true, latitude: true, longitude: true },
        }),
        prisma.graphEdge.findMany({
            select: { id: true, startNodeId: true, endNodeId: true, distance: true, baseCost: true, penalty: true },
        }),
        // Use PostGIS to get issue locations
        prisma.$queryRaw<Array<{
            latitude: number;
            longitude: number;
            issueType: string;
            severity: number;
        }>>`
            SELECT 
                ST_Y(location) as latitude,
                ST_X(location) as longitude,
                "issueType", severity
            FROM "Issue" 
            WHERE status != 'RESOLVED'::"IssueStatus"
            AND location IS NOT NULL
        `
    ]);

    console.log(`Loaded ${allNodes.length} nodes, ${allEdges.length} edges, and ${activeIssues.length} active issues`);

    // Build node lookup
    const nodeMap = new Map<string, PathNode>();
    for (const node of allNodes) {
        nodeMap.set(node.id, node);
    }

    // Apply dynamic penalties to edges
    // For each issue, find nearby edges using PostGIS instead of manual coordinate filtering
    const issueRadius = 50; // 50 meters

    // We update the 'penalty' in the edge objects in memory
    for (const issue of activeIssues) {
        // Use PostGIS to find nodes near each issue (within 50 meters)
        const nearbyNodes = await prisma.$queryRaw<Array<{ id: string }>>`
            SELECT gn.id
            FROM "GraphNode" gn
            WHERE ST_DWithin(
                ST_SetSRID(ST_MakePoint(gn.longitude, gn.latitude), 4326)::geography,
                ST_SetSRID(ST_MakePoint(${issue.longitude}, ${issue.latitude}), 4326)::geography,
                ${issueRadius}
            )
        `;

        const nearbyNodeIds = new Set(nearbyNodes.map(n => n.id));

        // Find edges connected to these nodes
        for (const edge of allEdges) {
            if (nearbyNodeIds.has(edge.startNodeId) || nearbyNodeIds.has(edge.endNodeId)) {
                // Calculate penalty based on severity (1-5)
                // Formula: Multiplier = 1 + (Severity * 2)
                // Severity 1 => 3x cost
                // Severity 3 => 7x cost  
                // Severity 5 => 11x cost (Avoid at all costs)
                const severity = issue.severity || 1;
                const multiplier = 1 + (severity * 2);

                edge.penalty = (edge.penalty || 1) * multiplier;
            }
        }
    }

    // Build adjacency list
    const adjacency = buildAdjacencyList(allEdges);

    // Step 3: A* Algorithm
    const openSet = new TinyQueue<QueueItem>([{ nodeId: startNode.id, fScore: 0 }], (a, b) => a.fScore - b.fScore);

    const gScore = new Map<string, number>();
    const cameFrom = new Map<string, string>();
    const distanceFrom = new Map<string, number>();

    gScore.set(startNode.id, 0);
    distanceFrom.set(startNode.id, 0);

    const visited = new Set<string>();

    while (openSet.length > 0) {
        const current = openSet.pop()!;

        if (current.nodeId === endNode.id) {
            // Reconstruct path
            const path: Array<{ lat: number; lng: number }> = [];
            let nodeId: string | undefined = endNode.id;
            // FIX: Use ?? instead of || to handle 0 correctly
            let totalDistance = distanceFrom.get(endNode.id) ?? 0;
            let totalCost = gScore.get(endNode.id) ?? 0;

            while (nodeId) {
                const node = nodeMap.get(nodeId);
                if (node) {
                    path.unshift({ lat: node.latitude, lng: node.longitude });
                }
                nodeId = cameFrom.get(nodeId);
            }

            // Estimated time at 30 km/h average
            const estimatedTime = (totalDistance / 1000 / 30) * 60;

            console.log(`Path found! ${path.length} nodes, ${totalDistance.toFixed(0)}m, ${estimatedTime.toFixed(1)}min`);

            return {
                path,
                totalDistance,
                totalCost,
                estimatedTime,
            };
        }

        if (visited.has(current.nodeId)) continue;
        visited.add(current.nodeId);

        const neighbors = adjacency.get(current.nodeId) || [];

        for (const neighbor of neighbors) {
            // FIX: Use ?? instead of || to handle gScore of 0 correctly
            const currentG = gScore.get(current.nodeId) ?? Infinity;
            const tentativeGScore = currentG + neighbor.cost;
            const tentativeDistance = (distanceFrom.get(current.nodeId) ?? 0) + neighbor.distance;

            // FIX: Use ?? instead of || to handle gScore of 0 correctly
            const neighborG = gScore.get(neighbor.nodeId) ?? Infinity;

            if (tentativeGScore < neighborG) {
                cameFrom.set(neighbor.nodeId, current.nodeId);
                gScore.set(neighbor.nodeId, tentativeGScore);
                distanceFrom.set(neighbor.nodeId, tentativeDistance);

                const neighborNode = nodeMap.get(neighbor.nodeId);
                if (neighborNode) {
                    const h = heuristic(neighborNode.latitude, neighborNode.longitude, endNode.latitude, endNode.longitude);
                    openSet.push({
                        nodeId: neighbor.nodeId,
                        fScore: tentativeGScore + h,
                    });
                }
            }
        }
    }

    console.log(`No path found after visiting ${visited.size} nodes`);
    return null;
}

export default { findPath, ingestOSMData };

</code>

## segfault-backend\src\services\PenaltyService.ts
<code>
/**
 * Penalty Service
 * Maps reported issues to nearby road edges and updates their penalties.
 */

import { prisma } from "../data/prisma/prismaClient";
import { IssueType, IssueStatus } from "../generated/prisma/enums";

// Penalty multipliers based on issue type
const ISSUE_PENALTY_MAP: Partial<Record<IssueType, number>> = {
    POTHOLE: 1.5,
    ROAD_DAMAGE: 5.0,
    DRAINAGE_BLOCKED: 3.0,
    SEWAGE_OVERFLOW: 4.0,
    OPEN_MANHOLE: 8.0,
    TREE_FALL: 10.0,
    TRAFFIC_LIGHT_FAULT: 2.0,
    BROKEN_FOOTPATH: 1.2,
};

// Search radius for finding nearby nodes (in degrees, ~20m  0.0002)
const SEARCH_RADIUS = 0.0002;

/**
 * Recalculates penalties for all edges based on active issues.
 * Uses nodes-first approach for performance:
 * 1. Find nodes near each issue
 * 2. Update edges connected to those nodes
 */
export async function recalculatePenalties(): Promise<void> {
    console.log("Recalculating edge penalties...");

    // Reset all penalties to 1.0
    await prisma.graphEdge.updateMany({
        data: { penalty: 1.0 },
    });

    // Get all active (non-resolved) issues using PostGIS
    const activeIssues = await prisma.$queryRaw<Array<{
        id: number;
        latitude: number;
        longitude: number;
        issueType: string;
        severity: number;
    }>>`
        SELECT 
            id,
            ST_Y(location) as latitude,
            ST_X(location) as longitude,
            "issueType", severity
        FROM "Issue" 
        WHERE status != 'RESOLVED'::"IssueStatus"
        AND location IS NOT NULL
    `;

    console.log(`Found ${activeIssues.length} active issues`);

    for (const issue of activeIssues) {
        const basePenalty = ISSUE_PENALTY_MAP[issue.issueType as IssueType] || 1.0;
        const severityMultiplier = issue.severity ? issue.severity / 3 : 1.0;
        const penalty = basePenalty * severityMultiplier;
        if (penalty <= 1.0) continue;

        // Use PostGIS to find nearby nodes within search radius
        const nearbyNodes = await prisma.$queryRaw<Array<{ id: string }>>`
            SELECT gn.id
            FROM "GraphNode" gn
            WHERE ST_DWithin(
                ST_SetSRID(ST_MakePoint(gn.longitude, gn.latitude), 4326)::geography,
                ST_SetSRID(ST_MakePoint(${issue.longitude}, ${issue.latitude}), 4326)::geography,
                ${SEARCH_RADIUS * 111000} -- Convert degrees to meters (approx)
            )
        `;

        if (nearbyNodes.length === 0) continue;

        const nodeIds = nearbyNodes.map((n) => n.id);

        // Update edges connected to these nodes
        await prisma.graphEdge.updateMany({
            where: {
                OR: [{ startNodeId: { in: nodeIds } }, { endNodeId: { in: nodeIds } }],
                penalty: { lt: penalty },
            },
            data: { penalty },
        });

        console.log(`  Issue #${issue.id} (${issue.issueType}): Applied penalty ${penalty} to ${nearbyNodes.length} nearby nodes`);
    }

    console.log("Penalty recalculation complete");
}

export default { recalculatePenalties };

</code>

## segfault-backend\src\services\QueueService.ts
<code>
import { QueueClient } from "@azure/storage-queue";

const connectionString = process.env.STORAGE_CONNECTION_STRING || "";
const queueName = "issue-queue";


let queueClient: QueueClient | null = null;

function getQueueClient(): QueueClient | null {
    if (!connectionString) {
        console.warn("Azure Storage connection string not configured. Queue disabled.");
        return null;
    }

    if (!queueClient) {
        queueClient = new QueueClient(connectionString, queueName);
    }
    return queueClient;
}

interface ModerationTask {
    issueId: number;
    blobUrl: string;
    latitude: number;
    longitude: number;
    issueType: string;
}

export async function sendToModerationQueue(task: ModerationTask): Promise<boolean> {
    const client = getQueueClient();
    if (!client) {
        console.log("Moderation queue not available, skipping...");
        return false;
    }

    try {
        const message = Buffer.from(JSON.stringify(task)).toString("base64");
        await client.sendMessage(message);
        console.log(`Sent issue ${task.issueId} to moderation queue`);
        return true;
    } catch (error) {
        console.error("Failed to send to moderation queue:", error);
        return false;
    }
}

export default { sendToModerationQueue };

</code>

## segfault-frontend\Dockerfile
<code>
# Build stage
FROM node:20-alpine AS builder

WORKDIR /app

# Copy package files and install dependencies
COPY package*.json ./
RUN npm ci

# Copy source code
COPY . .

# Build-time arg for API URL (Vite embeds this at build time)
ARG VITE_API_URL
ENV VITE_API_URL=$VITE_API_URL

# Build the production bundle
RUN npm run build

# Production stage - serve with nginx
FROM nginx:alpine

# Copy built files
COPY --from=builder /app/dist /usr/share/nginx/html

# Copy nginx config for SPA routing
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]

</code>

## segfault-frontend\eslint.config.js
<code>
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])

</code>

## segfault-frontend\index.html
<code>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>segfault-frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

</code>

## segfault-frontend\nginx.conf
<code>
server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # SPA routing - serve index.html for all routes
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}

</code>

## segfault-frontend\package-lock.json
<code>
{
  "name": "segfault-frontend",
  "version": "0.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "segfault-frontend",
      "version": "0.0.0",
      "dependencies": {
        "@emotion/react": "^11.14.0",
        "@emotion/styled": "^11.14.1",
        "@mui/icons-material": "^5.18.0",
        "@mui/material": "^5.18.0",
        "@mui/system": "^5.18.0",
        "axios": "^1.13.2",
        "leaflet": "^1.9.4",
        "leaflet-defaulticon-compatibility": "^0.1.2",
        "leaflet.heat": "^0.2.0",
        "react": "^19.2.0",
        "react-dom": "^19.2.0",
        "react-leaflet": "^5.0.0",
        "react-leaflet-cluster": "^4.0.0",
        "react-router-dom": "^7.10.1",
        "recharts": "^3.5.1"
      },
      "devDependencies": {
        "@eslint/js": "^9.39.1",
        "@types/leaflet": "^1.9.21",
        "@types/node": "^24.10.0",
        "@types/react": "^19.2.7",
        "@types/react-dom": "^19.2.2",
        "@vitejs/plugin-react": "^5.1.0",
        "eslint": "^9.39.1",
        "eslint-plugin-react-hooks": "^5.2.0",
        "eslint-plugin-react-refresh": "^0.4.24",
        "globals": "^16.5.0",
        "typescript": "~5.9.3",
        "typescript-eslint": "^8.46.3",
        "vite": "^7.2.2"
      }
    },
    "node_modules/@babel/code-frame": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.27.1.tgz",
      "integrity": "sha512-cjQ7ZlQ0Mv3b47hABuTevyTuYN4i+loJKGeV9flcCgIK37cCXRh+L1bd3iBHlynerhQ7BhCkn2BPbQUL+rGqFg==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-validator-identifier": "^7.27.1",
        "js-tokens": "^4.0.0",
        "picocolors": "^1.1.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/compat-data": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.28.5.tgz",
      "integrity": "sha512-6uFXyCayocRbqhZOB+6XcuZbkMNimwfVGFji8CTZnCzOHVGvDqzvitu1re2AU5LROliz7eQPhB8CpAMvnx9EjA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/core": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.28.5.tgz",
      "integrity": "sha512-e7jT4DxYvIDLk1ZHmU/m/mB19rex9sv0c2ftBtjSBv+kVM/902eh0fINUzD7UwLLNR+jU585GxUJ8/EBfAM5fw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.5",
        "@babel/helper-compilation-targets": "^7.27.2",
        "@babel/helper-module-transforms": "^7.28.3",
        "@babel/helpers": "^7.28.4",
        "@babel/parser": "^7.28.5",
        "@babel/template": "^7.27.2",
        "@babel/traverse": "^7.28.5",
        "@babel/types": "^7.28.5",
        "@jridgewell/remapping": "^2.3.5",
        "convert-source-map": "^2.0.0",
        "debug": "^4.1.0",
        "gensync": "^1.0.0-beta.2",
        "json5": "^2.2.3",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/babel"
      }
    },
    "node_modules/@babel/generator": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.28.5.tgz",
      "integrity": "sha512-3EwLFhZ38J4VyIP6WNtt2kUdW9dokXA9Cr4IVIFHuCpZ3H8/YFOl5JjZHisrn1fATPBmKKqXzDFvh9fUwHz6CQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.28.5",
        "@babel/types": "^7.28.5",
        "@jridgewell/gen-mapping": "^0.3.12",
        "@jridgewell/trace-mapping": "^0.3.28",
        "jsesc": "^3.0.2"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-compilation-targets": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.27.2.tgz",
      "integrity": "sha512-2+1thGUUWWjLTYTHZWK1n8Yga0ijBz1XAhUXcKy81rd5g6yh7hGqMp45v7cadSbEHc9G3OTv45SyneRN3ps4DQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/compat-data": "^7.27.2",
        "@babel/helper-validator-option": "^7.27.1",
        "browserslist": "^4.24.0",
        "lru-cache": "^5.1.1",
        "semver": "^6.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-globals": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@babel/helper-globals/-/helper-globals-7.28.0.tgz",
      "integrity": "sha512-+W6cISkXFa1jXsDEdYA8HeevQT/FULhxzR99pxphltZcVaugps53THCeiWA8SguxxpSp3gKPiuYfSWopkLQ4hw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-imports": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.27.1.tgz",
      "integrity": "sha512-0gSFWUPNXNopqtIPQvlD5WgXYI5GY2kP2cCvoT8kczjbfcfuIljTbcWrulD1CIPIX2gt1wghbDy08yE1p+/r3w==",
      "license": "MIT",
      "dependencies": {
        "@babel/traverse": "^7.27.1",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-module-transforms": {
      "version": "7.28.3",
      "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.28.3.tgz",
      "integrity": "sha512-gytXUbs8k2sXS9PnQptz5o0QnpLL51SwASIORY6XaBKF88nsOT0Zw9szLqlSGQDP/4TljBAD5y98p2U1fqkdsw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1",
        "@babel/traverse": "^7.28.3"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0"
      }
    },
    "node_modules/@babel/helper-plugin-utils": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.27.1.tgz",
      "integrity": "sha512-1gn1Up5YXka3YYAHGKpbideQ5Yjf1tDa9qYcgysz+cNCXukyLl6DjPXhD3VRwSb8c0J9tA4b2+rHEZtc6R0tlw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.28.5.tgz",
      "integrity": "sha512-qSs4ifwzKJSV39ucNjsvc6WVHs6b7S03sOh2OcHF9UHfVPqWWALUsNUVzhSBiItjRZoLHx7nIarVjqKVusUZ1Q==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-option": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.27.1.tgz",
      "integrity": "sha512-YvjJow9FxbhFFKDSuFnVCe2WxXk1zWc22fFePVNEaWJEu8IrZVlda6N0uHwzZrUM1il7NC9Mlp4MaJYbYd9JSg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helpers": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.28.4.tgz",
      "integrity": "sha512-HFN59MmQXGHVyYadKLVumYsA9dBFun/ldYxipEjzA4196jpLZd8UjEEBLkbEkvfYreDqJhZxYAWFPtrfhNpj4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.4"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.28.5.tgz",
      "integrity": "sha512-KKBU1VGYR7ORr3At5HAtUQ+TV3SzRCXmA/8OdDZiLDBIZxVyzXuztPjfLd3BV1PRAQGCMWWSHYhL0F8d5uHBDQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.5"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-self": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-self/-/plugin-transform-react-jsx-self-7.27.1.tgz",
      "integrity": "sha512-6UzkCs+ejGdZ5mFFC/OCUrv028ab2fp1znZmCZjAOBKiBK2jXD1O+BPSfX8X2qjJ75fZBMSnQn3Rq2mrBJK2mw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/plugin-transform-react-jsx-source": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/plugin-transform-react-jsx-source/-/plugin-transform-react-jsx-source-7.27.1.tgz",
      "integrity": "sha512-zbwoTsBruTeKB9hSq73ha66iFeJHuaFkUbwvqElnygoNbj/jHRsSeokowZFN3CZ64IvEqcmmkVe89OPXc7ldAw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-plugin-utils": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      },
      "peerDependencies": {
        "@babel/core": "^7.0.0-0"
      }
    },
    "node_modules/@babel/runtime": {
      "version": "7.28.4",
      "resolved": "https://registry.npmjs.org/@babel/runtime/-/runtime-7.28.4.tgz",
      "integrity": "sha512-Q/N6JNWvIvPnLDvjlE1OUBLPQHH6l3CltCEsHIujp45zQUSSh8K+gHnaEX45yAT1nyngnINhvWtzN+Nb9D8RAQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/template": {
      "version": "7.27.2",
      "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.27.2.tgz",
      "integrity": "sha512-LPDZ85aEJyYSd18/DkjNh4/y1ntkE5KwUHWTiqgRxruuZL2F1yuHligVHLvcHY2vMHXttKFpJn6LwfI7cw7ODw==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/parser": "^7.27.2",
        "@babel/types": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/traverse": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.28.5.tgz",
      "integrity": "sha512-TCCj4t55U90khlYkVV/0TfkJkAkUg3jZFA3Neb7unZT8CPok7iiRfaX0F+WnqWqt7OxhOn0uBKXCw4lbL8W0aQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.27.1",
        "@babel/generator": "^7.28.5",
        "@babel/helper-globals": "^7.28.0",
        "@babel/parser": "^7.28.5",
        "@babel/template": "^7.27.2",
        "@babel/types": "^7.28.5",
        "debug": "^4.3.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.28.5",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.28.5.tgz",
      "integrity": "sha512-qQ5m48eI/MFLQ5PxQj4PFaprjyCTLI37ElWMmNs0K8Lk3dVeOdNpB3ks8jc7yM5CDmVC73eMVk/trk3fgmrUpA==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.28.5"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@emotion/babel-plugin": {
      "version": "11.13.5",
      "resolved": "https://registry.npmjs.org/@emotion/babel-plugin/-/babel-plugin-11.13.5.tgz",
      "integrity": "sha512-pxHCpT2ex+0q+HH91/zsdHkw/lXd468DIN2zvfvLtPKLLMo6gQj7oLObq8PhkrxOZb/gGCq03S3Z7PDhS8pduQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/helper-module-imports": "^7.16.7",
        "@babel/runtime": "^7.18.3",
        "@emotion/hash": "^0.9.2",
        "@emotion/memoize": "^0.9.0",
        "@emotion/serialize": "^1.3.3",
        "babel-plugin-macros": "^3.1.0",
        "convert-source-map": "^1.5.0",
        "escape-string-regexp": "^4.0.0",
        "find-root": "^1.1.0",
        "source-map": "^0.5.7",
        "stylis": "4.2.0"
      }
    },
    "node_modules/@emotion/babel-plugin/node_modules/convert-source-map": {
      "version": "1.9.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.9.0.tgz",
      "integrity": "sha512-ASFBup0Mz1uyiIjANan1jzLQami9z1PoYSZCiiYW2FczPbenXc45FZdBZLzOT+r6+iciuEModtmCti+hjaAk0A==",
      "license": "MIT"
    },
    "node_modules/@emotion/cache": {
      "version": "11.14.0",
      "resolved": "https://registry.npmjs.org/@emotion/cache/-/cache-11.14.0.tgz",
      "integrity": "sha512-L/B1lc/TViYk4DcpGxtAVbx0ZyiKM5ktoIyafGkH6zg/tj+mA+NE//aPYKG0k8kCHSHVJrpLpcAlOBEXQ3SavA==",
      "license": "MIT",
      "dependencies": {
        "@emotion/memoize": "^0.9.0",
        "@emotion/sheet": "^1.4.0",
        "@emotion/utils": "^1.4.2",
        "@emotion/weak-memoize": "^0.4.0",
        "stylis": "4.2.0"
      }
    },
    "node_modules/@emotion/hash": {
      "version": "0.9.2",
      "resolved": "https://registry.npmjs.org/@emotion/hash/-/hash-0.9.2.tgz",
      "integrity": "sha512-MyqliTZGuOm3+5ZRSaaBGP3USLw6+EGykkwZns2EPC5g8jJ4z9OrdZY9apkl3+UP9+sdz76YYkwCKP5gh8iY3g==",
      "license": "MIT"
    },
    "node_modules/@emotion/is-prop-valid": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@emotion/is-prop-valid/-/is-prop-valid-1.4.0.tgz",
      "integrity": "sha512-QgD4fyscGcbbKwJmqNvUMSE02OsHUa+lAWKdEUIJKgqe5IwRSKd7+KhibEWdaKwgjLj0DRSHA9biAIqGBk05lw==",
      "license": "MIT",
      "dependencies": {
        "@emotion/memoize": "^0.9.0"
      }
    },
    "node_modules/@emotion/memoize": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/@emotion/memoize/-/memoize-0.9.0.tgz",
      "integrity": "sha512-30FAj7/EoJ5mwVPOWhAyCX+FPfMDrVecJAM+Iw9NRoSl4BBAQeqj4cApHHUXOVvIPgLVDsCFoz/hGD+5QQD1GQ==",
      "license": "MIT"
    },
    "node_modules/@emotion/react": {
      "version": "11.14.0",
      "resolved": "https://registry.npmjs.org/@emotion/react/-/react-11.14.0.tgz",
      "integrity": "sha512-O000MLDBDdk/EohJPFUqvnp4qnHeYkVP5B0xEG0D/L7cOKP9kefu2DXn8dj74cQfsEzUqh+sr1RzFqiL1o+PpA==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.13.5",
        "@emotion/cache": "^11.14.0",
        "@emotion/serialize": "^1.3.3",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
        "@emotion/utils": "^1.4.2",
        "@emotion/weak-memoize": "^0.4.0",
        "hoist-non-react-statics": "^3.3.1"
      },
      "peerDependencies": {
        "react": ">=16.8.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@emotion/serialize": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/@emotion/serialize/-/serialize-1.3.3.tgz",
      "integrity": "sha512-EISGqt7sSNWHGI76hC7x1CksiXPahbxEOrC5RjmFRJTqLyEK9/9hZvBbiYn70dw4wuwMKiEMCUlR6ZXTSWQqxA==",
      "license": "MIT",
      "dependencies": {
        "@emotion/hash": "^0.9.2",
        "@emotion/memoize": "^0.9.0",
        "@emotion/unitless": "^0.10.0",
        "@emotion/utils": "^1.4.2",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@emotion/sheet": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@emotion/sheet/-/sheet-1.4.0.tgz",
      "integrity": "sha512-fTBW9/8r2w3dXWYM4HCB1Rdp8NLibOw2+XELH5m5+AkWiL/KqYX6dc0kKYlaYyKjrQ6ds33MCdMPEwgs2z1rqg==",
      "license": "MIT"
    },
    "node_modules/@emotion/styled": {
      "version": "11.14.1",
      "resolved": "https://registry.npmjs.org/@emotion/styled/-/styled-11.14.1.tgz",
      "integrity": "sha512-qEEJt42DuToa3gurlH4Qqc1kVpNq8wO8cJtDzU46TjlzWjDlsVyevtYCRijVq3SrHsROS+gVQ8Fnea108GnKzw==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.13.5",
        "@emotion/is-prop-valid": "^1.3.0",
        "@emotion/serialize": "^1.3.3",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.2.0",
        "@emotion/utils": "^1.4.2"
      },
      "peerDependencies": {
        "@emotion/react": "^11.0.0-rc.0",
        "react": ">=16.8.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@emotion/unitless": {
      "version": "0.10.0",
      "resolved": "https://registry.npmjs.org/@emotion/unitless/-/unitless-0.10.0.tgz",
      "integrity": "sha512-dFoMUuQA20zvtVTuxZww6OHoJYgrzfKM1t52mVySDJnMSEa08ruEvdYQbhvyu6soU+NeLVd3yKfTfT0NeV6qGg==",
      "license": "MIT"
    },
    "node_modules/@emotion/use-insertion-effect-with-fallbacks": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/@emotion/use-insertion-effect-with-fallbacks/-/use-insertion-effect-with-fallbacks-1.2.0.tgz",
      "integrity": "sha512-yJMtVdH59sxi/aVJBpk9FQq+OR8ll5GT8oWd57UpeaKEVGab41JWaCFA7FRLoMLloOZF/c/wsPoe+bfGmRKgDg==",
      "license": "MIT",
      "peerDependencies": {
        "react": ">=16.8.0"
      }
    },
    "node_modules/@emotion/utils": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/@emotion/utils/-/utils-1.4.2.tgz",
      "integrity": "sha512-3vLclRofFziIa3J2wDh9jjbkUz9qk5Vi3IZ/FSTKViB0k+ef0fPV7dYrUIugbgupYDx7v9ud/SjrtEP8Y4xLoA==",
      "license": "MIT"
    },
    "node_modules/@emotion/weak-memoize": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/@emotion/weak-memoize/-/weak-memoize-0.4.0.tgz",
      "integrity": "sha512-snKqtPW01tN0ui7yu9rGv69aJXr/a/Ywvl11sUjNtEcRc+ng/mQriFL0wLXMef74iHa/EkftbDzU9F8iFbH+zg==",
      "license": "MIT"
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.25.12.tgz",
      "integrity": "sha512-Hhmwd6CInZ3dwpuGTF8fJG6yoWmsToE+vYgD4nytZVxcu1ulHpUQRAB1UJ8+N1Am3Mz4+xOByoQoSZf4D+CpkA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.25.12.tgz",
      "integrity": "sha512-VJ+sKvNA/GE7Ccacc9Cha7bpS8nyzVv0jdVgwNDaR4gDMC/2TTRc33Ip8qrNYUcpkOHUT5OZ0bUcNNVZQ9RLlg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.25.12.tgz",
      "integrity": "sha512-6AAmLG7zwD1Z159jCKPvAxZd4y/VTO0VkprYy+3N2FtJ8+BQWFXU+OxARIwA46c5tdD9SsKGZ/1ocqBS/gAKHg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.25.12.tgz",
      "integrity": "sha512-5jbb+2hhDHx5phYR2By8GTWEzn6I9UqR11Kwf22iKbNpYrsmRB18aX/9ivc5cabcUiAT/wM+YIZ6SG9QO6a8kg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.25.12.tgz",
      "integrity": "sha512-N3zl+lxHCifgIlcMUP5016ESkeQjLj/959RxxNYIthIg+CQHInujFuXeWbWMgnTo4cp5XVHqFPmpyu9J65C1Yg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.25.12.tgz",
      "integrity": "sha512-HQ9ka4Kx21qHXwtlTUVbKJOAnmG1ipXhdWTmNXiPzPfWKpXqASVcWdnf2bnL73wgjNrFXAa3yYvBSd9pzfEIpA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.25.12.tgz",
      "integrity": "sha512-gA0Bx759+7Jve03K1S0vkOu5Lg/85dou3EseOGUes8flVOGxbhDDh/iZaoek11Y8mtyKPGF3vP8XhnkDEAmzeg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.25.12.tgz",
      "integrity": "sha512-TGbO26Yw2xsHzxtbVFGEXBFH0FRAP7gtcPE7P5yP7wGy7cXK2oO7RyOhL5NLiqTlBh47XhmIUXuGciXEqYFfBQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.25.12.tgz",
      "integrity": "sha512-lPDGyC1JPDou8kGcywY0YILzWlhhnRjdof3UlcoqYmS9El818LLfJJc3PXXgZHrHCAKs/Z2SeZtDJr5MrkxtOw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.25.12.tgz",
      "integrity": "sha512-8bwX7a8FghIgrupcxb4aUmYDLp8pX06rGh5HqDT7bB+8Rdells6mHvrFHHW2JAOPZUbnjUpKTLg6ECyzvas2AQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.25.12.tgz",
      "integrity": "sha512-0y9KrdVnbMM2/vG8KfU0byhUN+EFCny9+8g202gYqSSVMonbsCfLjUO+rCci7pM0WBEtz+oK/PIwHkzxkyharA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.25.12.tgz",
      "integrity": "sha512-h///Lr5a9rib/v1GGqXVGzjL4TMvVTv+s1DPoxQdz7l/AYv6LDSxdIwzxkrPW438oUXiDtwM10o9PmwS/6Z0Ng==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.25.12.tgz",
      "integrity": "sha512-iyRrM1Pzy9GFMDLsXn1iHUm18nhKnNMWscjmp4+hpafcZjrr2WbT//d20xaGljXDBYHqRcl8HnxbX6uaA/eGVw==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.25.12.tgz",
      "integrity": "sha512-9meM/lRXxMi5PSUqEXRCtVjEZBGwB7P/D4yT8UG/mwIdze2aV4Vo6U5gD3+RsoHXKkHCfSxZKzmDssVlRj1QQA==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.25.12.tgz",
      "integrity": "sha512-Zr7KR4hgKUpWAwb1f3o5ygT04MzqVrGEGXGLnj15YQDJErYu/BGg+wmFlIDOdJp0PmB0lLvxFIOXZgFRrdjR0w==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.25.12.tgz",
      "integrity": "sha512-MsKncOcgTNvdtiISc/jZs/Zf8d0cl/t3gYWX8J9ubBnVOwlk65UIEEvgBORTiljloIWnBzLs4qhzPkJcitIzIg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.25.12.tgz",
      "integrity": "sha512-uqZMTLr/zR/ed4jIGnwSLkaHmPjOjJvnm6TVVitAa08SLS9Z0VM8wIRx7gWbJB5/J54YuIMInDquWyYvQLZkgw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-arm64/-/netbsd-arm64-0.25.12.tgz",
      "integrity": "sha512-xXwcTq4GhRM7J9A8Gv5boanHhRa/Q9KLVmcyXHCTaM4wKfIpWkdXiMog/KsnxzJ0A1+nD+zoecuzqPmCRyBGjg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.25.12.tgz",
      "integrity": "sha512-Ld5pTlzPy3YwGec4OuHh1aCVCRvOXdH8DgRjfDy/oumVovmuSzWfnSJg+VtakB9Cm0gxNO9BzWkj6mtO1FMXkQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.25.12.tgz",
      "integrity": "sha512-fF96T6KsBo/pkQI950FARU9apGNTSlZGsv1jZBAlcLL1MLjLNIWPBkj5NlSz8aAzYKg+eNqknrUJ24QBybeR5A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.25.12.tgz",
      "integrity": "sha512-MZyXUkZHjQxUvzK7rN8DJ3SRmrVrke8ZyRusHlP+kuwqTcfWLyqMOE3sScPPyeIXN/mDJIfGXvcMqCgYKekoQw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/openharmony-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/openharmony-arm64/-/openharmony-arm64-0.25.12.tgz",
      "integrity": "sha512-rm0YWsqUSRrjncSXGA7Zv78Nbnw4XL6/dzr20cyrQf7ZmRcsovpcRBdhD43Nuk3y7XIoW2OxMVvwuRvk9XdASg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.25.12.tgz",
      "integrity": "sha512-3wGSCDyuTHQUzt0nV7bocDy72r2lI33QL3gkDNGkod22EsYl04sMf0qLb8luNKTOmgF/eDEDP5BFNwoBKH441w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.25.12.tgz",
      "integrity": "sha512-rMmLrur64A7+DKlnSuwqUdRKyd3UE7oPJZmnljqEptesKM8wx9J8gx5u0+9Pq0fQQW8vqeKebwNXdfOyP+8Bsg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.25.12.tgz",
      "integrity": "sha512-HkqnmmBoCbCwxUKKNPBixiWDGCpQGVsrQfJoVGYLPT41XWF8lHuE5N6WhVia2n4o5QK5M4tYr21827fNhi4byQ==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.25.12.tgz",
      "integrity": "sha512-alJC0uCZpTFrSL0CCDjcgleBXPnCrEAhTBILpeAp7M/OFgoqtAetfBzX0xM00MUsVVPpVjlPuMbREqnZCXaTnA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.0",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.0.tgz",
      "integrity": "sha512-ayVFHdtZ+hsq1t2Dy24wCmGXGe4q9Gu3smhLYALJrr473ZH27MsnSL+LKUlimp4BWJqMDMLmPpx/Q9R3OAlL4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/eslint-utils/node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.2",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.2.tgz",
      "integrity": "sha512-EriSTlt5OC9/7SXkRSCAhfSxxoSUgBm33OH+IkwbdpgoqsSsUg7y3uh+IICI/Qg4BBWr3U2i39RpmycbxMq4ew==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/config-array": {
      "version": "0.21.1",
      "resolved": "https://registry.npmjs.org/@eslint/config-array/-/config-array-0.21.1.tgz",
      "integrity": "sha512-aw1gNayWpdI/jSYVgzN5pL0cfzU02GT3NBpeT/DXbx1/1x7ZKxFPd9bwrzygx/qiwIQiJ1sw/zD8qY/kRvlGHA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/object-schema": "^2.1.7",
        "debug": "^4.3.1",
        "minimatch": "^3.1.2"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/config-helpers": {
      "version": "0.4.2",
      "resolved": "https://registry.npmjs.org/@eslint/config-helpers/-/config-helpers-0.4.2.tgz",
      "integrity": "sha512-gBrxN88gOIf3R7ja5K9slwNayVcZgK6SOUORm2uBzTeIEfeVaIhOpCtTox3P6R7o2jLFwLFTLnC7kU/RGcYEgw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/core": {
      "version": "0.17.0",
      "resolved": "https://registry.npmjs.org/@eslint/core/-/core-0.17.0.tgz",
      "integrity": "sha512-yL/sLrpmtDaFEiUj1osRP4TI2MDz1AddJL+jZ7KSqvBuliN4xqYY54IfdN8qD8Toa6g1iloph1fxQNkjOxrrpQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@types/json-schema": "^7.0.15"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-3.3.1.tgz",
      "integrity": "sha512-gtF186CXhIl1p4pJNGZw8Yc6RlshoePRvE0X91oPGb3vZ8pM3qOS9W9NGPat9LziaBV7XrJWGylNQXkGcnM3IQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^10.0.1",
        "globals": "^14.0.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.0",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/globals": {
      "version": "14.0.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-14.0.0.tgz",
      "integrity": "sha512-oahGvuMGQlPw/ivIYBjVSrWAfWLBeku5tpPE2fOPLi+WHffIWbuh2tCjhyQhTBPMf5E9jDEH4FOmTYgYwbKwtQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/@eslint/js": {
      "version": "9.39.1",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-9.39.1.tgz",
      "integrity": "sha512-S26Stp4zCy88tH94QbBv3XCuzRQiZ9yXofEILmglYTh/Ug/a9/umqvgFtYBAo3Lp0nsI/5/qH1CCrbdK3AP1Tw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      }
    },
    "node_modules/@eslint/object-schema": {
      "version": "2.1.7",
      "resolved": "https://registry.npmjs.org/@eslint/object-schema/-/object-schema-2.1.7.tgz",
      "integrity": "sha512-VtAOaymWVfZcmZbp6E2mympDIHvyjXs/12LqWYjVw6qjrfF+VK+fyG33kChz3nnK+SU5/NeHOqrTEHS8sXO3OA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@eslint/plugin-kit": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@eslint/plugin-kit/-/plugin-kit-0.4.1.tgz",
      "integrity": "sha512-43/qtrDUokr7LJqoF2c3+RInu/t4zfrpYdoSDfYyhg52rwLV6TnOvdG4fXm7IkSB3wErkcmJS9iEhjVtOSEjjA==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@eslint/core": "^0.17.0",
        "levn": "^0.4.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      }
    },
    "node_modules/@humanfs/core": {
      "version": "0.19.1",
      "resolved": "https://registry.npmjs.org/@humanfs/core/-/core-0.19.1.tgz",
      "integrity": "sha512-5DyQ4+1JEUzejeK1JGICcideyfUbGixgS9jNgex5nqkW+cY7WZhxBigmieN5Qnw9ZosSNVC9KQKyb+GUaGyKUA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanfs/node": {
      "version": "0.16.7",
      "resolved": "https://registry.npmjs.org/@humanfs/node/-/node-0.16.7.tgz",
      "integrity": "sha512-/zUx+yOsIrG4Y43Eh2peDeKCxlRt/gET6aHfaKpuq267qXdYDFViVHfMaLyygZOnl0kGWxFIgsBy8QFuTLUXEQ==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanfs/core": "^0.19.1",
        "@humanwhocodes/retry": "^0.4.0"
      },
      "engines": {
        "node": ">=18.18.0"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/retry": {
      "version": "0.4.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/retry/-/retry-0.4.3.tgz",
      "integrity": "sha512-bV0Tgo9K4hfPCek+aMAn81RppFKv2ySDQeMoSZuvTASywNTnVJCArCZE2FWqpvIatKu7VMRLWlR1EazvVhDyhQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.13",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.13.tgz",
      "integrity": "sha512-2kkt/7niJ6MgEPxF0bYdQ6etZaA+fQvDcLKckhy1yIQOzaoKjBBjSj63/aLVjYE3qhRt5dvM+uUyfCg6UKCBbA==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/remapping": {
      "version": "2.3.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/remapping/-/remapping-2.3.5.tgz",
      "integrity": "sha512-LI9u/+laYG4Ds1TDKSJW2YPrIlcVYOwi2fUC6xB43lueCjgxV4lffOCZCtYFiH6TNOX+tQKXx97T4IKHbhyHEQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.5.tgz",
      "integrity": "sha512-cYQ9310grqxueWbl+WuIUIaiUaDcj7WOq5fVhEljNVgRfOUhY9fy2zTvfoqWsnebh8Sl70VScFbICvJnLKB0Og==",
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.31",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.31.tgz",
      "integrity": "sha512-zzNR+SdQSDJzc8joaeP8QQoCQr8NuYx2dIIytl1QeBEZHJ9uW6hebsrYgbz8hJwUQao3TWCMtmfV8Nu1twOLAw==",
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@mui/core-downloads-tracker": {
      "version": "5.18.0",
      "resolved": "https://registry.npmjs.org/@mui/core-downloads-tracker/-/core-downloads-tracker-5.18.0.tgz",
      "integrity": "sha512-jbhwoQ1AY200PSSOrNXmrFCaSDSJWP7qk6urkTmIirvRXDROkqe+QwcLlUiw/PrREwsIF/vm3/dAXvjlMHF0RA==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      }
    },
    "node_modules/@mui/icons-material": {
      "version": "5.18.0",
      "resolved": "https://registry.npmjs.org/@mui/icons-material/-/icons-material-5.18.0.tgz",
      "integrity": "sha512-1s0vEZj5XFXDMmz3Arl/R7IncFqJ+WQ95LDp1roHWGDE2oCO3IS4/hmiOv1/8SD9r6B7tv9GLiqVZYHo+6PkTg==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.23.9"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@mui/material": "^5.0.0",
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/material": {
      "version": "5.18.0",
      "resolved": "https://registry.npmjs.org/@mui/material/-/material-5.18.0.tgz",
      "integrity": "sha512-bbH/HaJZpFtXGvWg3TsBWG4eyt3gah3E7nCNU8GLyRjVoWcA91Vm/T+sjHfUcwgJSw9iLtucfHBoq+qW/T30aA==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.23.9",
        "@mui/core-downloads-tracker": "^5.18.0",
        "@mui/system": "^5.18.0",
        "@mui/types": "~7.2.15",
        "@mui/utils": "^5.17.1",
        "@popperjs/core": "^2.11.8",
        "@types/react-transition-group": "^4.4.10",
        "clsx": "^2.1.0",
        "csstype": "^3.1.3",
        "prop-types": "^15.8.1",
        "react-is": "^19.0.0",
        "react-transition-group": "^4.4.5"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@emotion/react": "^11.5.0",
        "@emotion/styled": "^11.3.0",
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@emotion/react": {
          "optional": true
        },
        "@emotion/styled": {
          "optional": true
        },
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/private-theming": {
      "version": "5.17.1",
      "resolved": "https://registry.npmjs.org/@mui/private-theming/-/private-theming-5.17.1.tgz",
      "integrity": "sha512-XMxU0NTYcKqdsG8LRmSoxERPXwMbp16sIXPcLVgLGII/bVNagX0xaheWAwFv8+zDK7tI3ajllkuD3GZZE++ICQ==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.23.9",
        "@mui/utils": "^5.17.1",
        "prop-types": "^15.8.1"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/styled-engine": {
      "version": "5.18.0",
      "resolved": "https://registry.npmjs.org/@mui/styled-engine/-/styled-engine-5.18.0.tgz",
      "integrity": "sha512-BN/vKV/O6uaQh2z5rXV+MBlVrEkwoS/TK75rFQ2mjxA7+NBo8qtTAOA4UaM0XeJfn7kh2wZ+xQw2HAx0u+TiBg==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.23.9",
        "@emotion/cache": "^11.13.5",
        "@emotion/serialize": "^1.3.3",
        "csstype": "^3.1.3",
        "prop-types": "^15.8.1"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@emotion/react": "^11.4.1",
        "@emotion/styled": "^11.3.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@emotion/react": {
          "optional": true
        },
        "@emotion/styled": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/system": {
      "version": "5.18.0",
      "resolved": "https://registry.npmjs.org/@mui/system/-/system-5.18.0.tgz",
      "integrity": "sha512-ojZGVcRWqWhu557cdO3pWHloIGJdzVtxs3rk0F9L+x55LsUjcMUVkEhiF7E4TMxZoF9MmIHGGs0ZX3FDLAf0Xw==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.23.9",
        "@mui/private-theming": "^5.17.1",
        "@mui/styled-engine": "^5.18.0",
        "@mui/types": "~7.2.15",
        "@mui/utils": "^5.17.1",
        "clsx": "^2.1.0",
        "csstype": "^3.1.3",
        "prop-types": "^15.8.1"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@emotion/react": "^11.5.0",
        "@emotion/styled": "^11.3.0",
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@emotion/react": {
          "optional": true
        },
        "@emotion/styled": {
          "optional": true
        },
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/types": {
      "version": "7.2.24",
      "resolved": "https://registry.npmjs.org/@mui/types/-/types-7.2.24.tgz",
      "integrity": "sha512-3c8tRt/CbWZ+pEg7QpSwbdxOk36EfmhbKf6AGZsD1EcLDLTSZoxxJ86FVtcjxvjuhdyBiWKSTGZFaXCnidO2kw==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@mui/utils": {
      "version": "5.17.1",
      "resolved": "https://registry.npmjs.org/@mui/utils/-/utils-5.17.1.tgz",
      "integrity": "sha512-jEZ8FTqInt2WzxDV8bhImWBqeQRD99c/id/fq83H0ER9tFl+sfZlaAoCdznGvbSQQ9ividMxqSV2c7cC1vBcQg==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.23.9",
        "@mui/types": "~7.2.15",
        "@types/prop-types": "^15.7.12",
        "clsx": "^2.1.1",
        "prop-types": "^15.8.1",
        "react-is": "^19.0.0"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/mui-org"
      },
      "peerDependencies": {
        "@types/react": "^17.0.0 || ^18.0.0 || ^19.0.0",
        "react": "^17.0.0 || ^18.0.0 || ^19.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        }
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@popperjs/core": {
      "version": "2.11.8",
      "resolved": "https://registry.npmjs.org/@popperjs/core/-/core-2.11.8.tgz",
      "integrity": "sha512-P1st0aksCrn9sGZhp8GMYwBnQsbvAWsZAX44oXNNvLHGqAOcoVxmjZiohstwQ7SqKnbR47akdNi+uleWD8+g6A==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/popperjs"
      }
    },
    "node_modules/@react-leaflet/core": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@react-leaflet/core/-/core-3.0.0.tgz",
      "integrity": "sha512-3EWmekh4Nz+pGcr+xjf0KNyYfC3U2JjnkWsh0zcqaexYqmmB5ZhH37kz41JXGmKzpaMZCnPofBBm64i+YrEvGQ==",
      "license": "Hippocratic-2.1",
      "peerDependencies": {
        "leaflet": "^1.9.0",
        "react": "^19.0.0",
        "react-dom": "^19.0.0"
      }
    },
    "node_modules/@reduxjs/toolkit": {
      "version": "2.11.0",
      "resolved": "https://registry.npmjs.org/@reduxjs/toolkit/-/toolkit-2.11.0.tgz",
      "integrity": "sha512-hBjYg0aaRL1O2Z0IqWhnTLytnjDIxekmRxm1snsHjHaKVmIF1HiImWqsq+PuEbn6zdMlkIj9WofK1vR8jjx+Xw==",
      "license": "MIT",
      "dependencies": {
        "@standard-schema/spec": "^1.0.0",
        "@standard-schema/utils": "^0.3.0",
        "immer": "^11.0.0",
        "redux": "^5.0.1",
        "redux-thunk": "^3.1.0",
        "reselect": "^5.1.0"
      },
      "peerDependencies": {
        "react": "^16.9.0 || ^17.0.0 || ^18 || ^19",
        "react-redux": "^7.2.1 || ^8.1.3 || ^9.0.0"
      },
      "peerDependenciesMeta": {
        "react": {
          "optional": true
        },
        "react-redux": {
          "optional": true
        }
      }
    },
    "node_modules/@reduxjs/toolkit/node_modules/immer": {
      "version": "11.0.1",
      "resolved": "https://registry.npmjs.org/immer/-/immer-11.0.1.tgz",
      "integrity": "sha512-naDCyggtcBWANtIrjQEajhhBEuL9b0Zg4zmlWK2CzS6xCWSE39/vvf4LqnMjUAWHBhot4m9MHCM/Z+mfWhUkiA==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/immer"
      }
    },
    "node_modules/@rolldown/pluginutils": {
      "version": "1.0.0-beta.43",
      "resolved": "https://registry.npmjs.org/@rolldown/pluginutils/-/pluginutils-1.0.0-beta.43.tgz",
      "integrity": "sha512-5Uxg7fQUCmfhax7FJke2+8B6cqgeUJUD9o2uXIKXhD+mG0mL6NObmVoi9wXEU1tY89mZKgAYA6fTbftx3q2ZPQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.53.2.tgz",
      "integrity": "sha512-yDPzwsgiFO26RJA4nZo8I+xqzh7sJTZIWQOxn+/XOdPE31lAvLIYCKqjV+lNH/vxE2L2iH3plKxDCRK6i+CwhA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.53.2.tgz",
      "integrity": "sha512-k8FontTxIE7b0/OGKeSN5B6j25EuppBcWM33Z19JoVT7UTXFSo3D9CdU39wGTeb29NO3XxpMNauh09B+Ibw+9g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.53.2.tgz",
      "integrity": "sha512-A6s4gJpomNBtJ2yioj8bflM2oogDwzUiMl2yNJ2v9E7++sHrSrsQ29fOfn5DM/iCzpWcebNYEdXpaK4tr2RhfQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.53.2.tgz",
      "integrity": "sha512-e6XqVmXlHrBlG56obu9gDRPW3O3hLxpwHpLsBJvuI8qqnsrtSZ9ERoWUXtPOkY8c78WghyPHZdmPhHLWNdAGEw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.53.2.tgz",
      "integrity": "sha512-v0E9lJW8VsrwPux5Qe5CwmH/CF/2mQs6xU1MF3nmUxmZUCHazCjLgYvToOk+YuuUqLQBio1qkkREhxhc656ViA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.53.2.tgz",
      "integrity": "sha512-ClAmAPx3ZCHtp6ysl4XEhWU69GUB1D+s7G9YjHGhIGCSrsg00nEGRRZHmINYxkdoJehde8VIsDC5t9C0gb6yqA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.53.2.tgz",
      "integrity": "sha512-EPlb95nUsz6Dd9Qy13fI5kUPXNSljaG9FiJ4YUGU1O/Q77i5DYFW5KR8g1OzTcdZUqQQ1KdDqsTohdFVwCwjqg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.53.2.tgz",
      "integrity": "sha512-BOmnVW+khAUX+YZvNfa0tGTEMVVEerOxN0pDk2E6N6DsEIa2Ctj48FOMfNDdrwinocKaC7YXUZ1pHlKpnkja/Q==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.53.2.tgz",
      "integrity": "sha512-Xt2byDZ+6OVNuREgBXr4+CZDJtrVso5woFtpKdGPhpTPHcNG7D8YXeQzpNbFRxzTVqJf7kvPMCub/pcGUWgBjA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.53.2.tgz",
      "integrity": "sha512-+LdZSldy/I9N8+klim/Y1HsKbJ3BbInHav5qE9Iy77dtHC/pibw1SR/fXlWyAk0ThnpRKoODwnAuSjqxFRDHUQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.53.2.tgz",
      "integrity": "sha512-8ms8sjmyc1jWJS6WdNSA23rEfdjWB30LH8Wqj0Cqvv7qSHnvw6kgMMXRdop6hkmGPlyYBdRPkjJnj3KCUHV/uQ==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.53.2.tgz",
      "integrity": "sha512-3HRQLUQbpBDMmzoxPJYd3W6vrVHOo2cVW8RUo87Xz0JPJcBLBr5kZ1pGcQAhdZgX9VV7NbGNipah1omKKe23/g==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.53.2.tgz",
      "integrity": "sha512-fMjKi+ojnmIvhk34gZP94vjogXNNUKMEYs+EDaB/5TG/wUkoeua7p7VCHnE6T2Tx+iaghAqQX8teQzcvrYpaQA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.53.2.tgz",
      "integrity": "sha512-XuGFGU+VwUUV5kLvoAdi0Wz5Xbh2SrjIxCtZj6Wq8MDp4bflb/+ThZsVxokM7n0pcbkEr2h5/pzqzDYI7cCgLQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.53.2.tgz",
      "integrity": "sha512-w6yjZF0P+NGzWR3AXWX9zc0DNEGdtvykB03uhonSHMRa+oWA6novflo2WaJr6JZakG2ucsyb+rvhrKac6NIy+w==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.53.2.tgz",
      "integrity": "sha512-yo8d6tdfdeBArzC7T/PnHd7OypfI9cbuZzPnzLJIyKYFhAQ8SvlkKtKBMbXDxe1h03Rcr7u++nFS7tqXz87Gtw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.53.2.tgz",
      "integrity": "sha512-ah59c1YkCxKExPP8O9PwOvs+XRLKwh/mV+3YdKqQ5AMQ0r4M4ZDuOrpWkUaqO7fzAHdINzV9tEVu8vNw48z0lA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.53.2.tgz",
      "integrity": "sha512-4VEd19Wmhr+Zy7hbUsFZ6YXEiP48hE//KPLCSVNY5RMGX2/7HZ+QkN55a3atM1C/BZCGIgqN+xrVgtdak2S9+A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.53.2.tgz",
      "integrity": "sha512-IlbHFYc/pQCgew/d5fslcy1KEaYVCJ44G8pajugd8VoOEI8ODhtb/j8XMhLpwHCMB3yk2J07ctup10gpw2nyMA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.53.2.tgz",
      "integrity": "sha512-lNlPEGgdUfSzdCWU176ku/dQRnA7W+Gp8d+cWv73jYrb8uT7HTVVxq62DUYxjbaByuf1Yk0RIIAbDzp+CnOTFg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.53.2.tgz",
      "integrity": "sha512-S6YojNVrHybQis2lYov1sd+uj7K0Q05NxHcGktuMMdIQ2VixGwAfbJ23NnlvvVV1bdpR2m5MsNBViHJKcA4ADw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.53.2.tgz",
      "integrity": "sha512-k+/Rkcyx//P6fetPoLMb8pBeqJBNGx81uuf7iljX9++yNBVRDQgD04L+SVXmXmh5ZP4/WOp4mWF0kmi06PW2tA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@standard-schema/spec": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/spec/-/spec-1.0.0.tgz",
      "integrity": "sha512-m2bOd0f2RT9k8QJx1JN85cZYyH1RqFBdlwtkSlf4tBDYLCiiZnv1fIIwacK6cqwXavOydf0NPToMQgpKq+dVlA==",
      "license": "MIT"
    },
    "node_modules/@standard-schema/utils": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/@standard-schema/utils/-/utils-0.3.0.tgz",
      "integrity": "sha512-e7Mew686owMaPJVNNLs55PUvgz371nKgwsc4vxE49zsODpJEnxgxRo2y/OKrqueavXgZNMDVj3DdHFlaSAeU8g==",
      "license": "MIT"
    },
    "node_modules/@types/babel__core": {
      "version": "7.20.5",
      "resolved": "https://registry.npmjs.org/@types/babel__core/-/babel__core-7.20.5.tgz",
      "integrity": "sha512-qoQprZvz5wQFJwMDqeseRXWv3rqMvhgpbXFfVyWhbx9X47POIA6i/+dXefEmZKoAgOaTdaIgNSMqMIU61yRyzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.20.7",
        "@babel/types": "^7.20.7",
        "@types/babel__generator": "*",
        "@types/babel__template": "*",
        "@types/babel__traverse": "*"
      }
    },
    "node_modules/@types/babel__generator": {
      "version": "7.27.0",
      "resolved": "https://registry.npmjs.org/@types/babel__generator/-/babel__generator-7.27.0.tgz",
      "integrity": "sha512-ufFd2Xi92OAVPYsy+P4n7/U7e68fex0+Ee8gSG9KX7eo084CWiQ4sdxktvdl0bOPupXtVJPY19zk6EwWqUQ8lg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__template": {
      "version": "7.4.4",
      "resolved": "https://registry.npmjs.org/@types/babel__template/-/babel__template-7.4.4.tgz",
      "integrity": "sha512-h/NUaSyG5EyxBIp8YRxo4RMe2/qQgvyowRwVMzhYhBCONbW8PUsg4lkFMrhgZhUe5z3L3MiLDuvyJ/CaPa2A8A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.1.0",
        "@babel/types": "^7.0.0"
      }
    },
    "node_modules/@types/babel__traverse": {
      "version": "7.28.0",
      "resolved": "https://registry.npmjs.org/@types/babel__traverse/-/babel__traverse-7.28.0.tgz",
      "integrity": "sha512-8PvcXf70gTDZBgt9ptxJ8elBeBjcLOAcOtoO/mPJjtji1+CdGbHgm77om1GrsPxsiE+uXIpNSK64UYaIwQXd4Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.28.2"
      }
    },
    "node_modules/@types/d3-array": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/@types/d3-array/-/d3-array-3.2.2.tgz",
      "integrity": "sha512-hOLWVbm7uRza0BYXpIIW5pxfrKe0W+D5lrFiAEYR+pb6w3N2SwSMaJbXdUfSEv+dT4MfHBLtn5js0LAWaO6otw==",
      "license": "MIT"
    },
    "node_modules/@types/d3-color": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/@types/d3-color/-/d3-color-3.1.3.tgz",
      "integrity": "sha512-iO90scth9WAbmgv7ogoq57O9YpKmFBbmoEoCHDB2xMBY0+/KVrqAaCDyCE16dUspeOvIxFFRI+0sEtqDqy2b4A==",
      "license": "MIT"
    },
    "node_modules/@types/d3-ease": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@types/d3-ease/-/d3-ease-3.0.2.tgz",
      "integrity": "sha512-NcV1JjO5oDzoK26oMzbILE6HW7uVXOHLQvHshBUW4UMdZGfiY6v5BeQwh9a9tCzv+CeefZQHJt5SRgK154RtiA==",
      "license": "MIT"
    },
    "node_modules/@types/d3-interpolate": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/d3-interpolate/-/d3-interpolate-3.0.4.tgz",
      "integrity": "sha512-mgLPETlrpVV1YRJIglr4Ez47g7Yxjl1lj7YKsiMCb27VJH9W8NVM6Bb9d8kkpG/uAQS5AmbA48q2IAolKKo1MA==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-color": "*"
      }
    },
    "node_modules/@types/d3-path": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/@types/d3-path/-/d3-path-3.1.1.tgz",
      "integrity": "sha512-VMZBYyQvbGmWyWVea0EHs/BwLgxc+MKi1zLDCONksozI4YJMcTt8ZEuIR4Sb1MMTE8MMW49v0IwI5+b7RmfWlg==",
      "license": "MIT"
    },
    "node_modules/@types/d3-scale": {
      "version": "4.0.9",
      "resolved": "https://registry.npmjs.org/@types/d3-scale/-/d3-scale-4.0.9.tgz",
      "integrity": "sha512-dLmtwB8zkAeO/juAMfnV+sItKjlsw2lKdZVVy6LRr0cBmegxSABiLEpGVmSJJ8O08i4+sGR6qQtb6WtuwJdvVw==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-time": "*"
      }
    },
    "node_modules/@types/d3-shape": {
      "version": "3.1.7",
      "resolved": "https://registry.npmjs.org/@types/d3-shape/-/d3-shape-3.1.7.tgz",
      "integrity": "sha512-VLvUQ33C+3J+8p+Daf+nYSOsjB4GXp19/S/aGo60m9h1v6XaxjiT82lKVWJCfzhtuZ3yD7i/TPeC/fuKLLOSmg==",
      "license": "MIT",
      "dependencies": {
        "@types/d3-path": "*"
      }
    },
    "node_modules/@types/d3-time": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@types/d3-time/-/d3-time-3.0.4.tgz",
      "integrity": "sha512-yuzZug1nkAAaBlBBikKZTgzCeA+k1uy4ZFwWANOfKw5z5LRhV0gNA7gNkKm7HoK+HRN0wX3EkxGk0fpbWhmB7g==",
      "license": "MIT"
    },
    "node_modules/@types/d3-timer": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@types/d3-timer/-/d3-timer-3.0.2.tgz",
      "integrity": "sha512-Ps3T8E8dZDam6fUyNiMkekK3XUsaUEik+idO9/YjPtfj2qruF8tFBXS7XhtE4iIXBLxhmLjP3SXpLhVf21I9Lw==",
      "license": "MIT"
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/geojson": {
      "version": "7946.0.16",
      "resolved": "https://registry.npmjs.org/@types/geojson/-/geojson-7946.0.16.tgz",
      "integrity": "sha512-6C8nqWur3j98U6+lXDfTUWIfgvZU+EumvpHKcYjujKH7woYyLj2sUmff0tRhrqM7BohUw7Pz3ZB1jj2gW9Fvmg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/leaflet": {
      "version": "1.9.21",
      "resolved": "https://registry.npmjs.org/@types/leaflet/-/leaflet-1.9.21.tgz",
      "integrity": "sha512-TbAd9DaPGSnzp6QvtYngntMZgcRk+igFELwR2N99XZn7RXUdKgsXMR+28bUO0rPsWp8MIu/f47luLIQuSLYv/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/geojson": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "24.10.0",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.10.0.tgz",
      "integrity": "sha512-qzQZRBqkFsYyaSWXuEHc2WR9c0a0CXwiE5FWUvn7ZM+vdy1uZLfCunD38UzhuB7YN/J11ndbDBcTmOdxJo9Q7A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.16.0"
      }
    },
    "node_modules/@types/parse-json": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/@types/parse-json/-/parse-json-4.0.2.tgz",
      "integrity": "sha512-dISoDXWWQwUquiKsyZ4Ng+HX2KsPL7LyHKHQwgGFEA3IaKac4Obd+h2a/a6waisAoepJlBcx9paWqjA8/HVjCw==",
      "license": "MIT"
    },
    "node_modules/@types/prop-types": {
      "version": "15.7.15",
      "resolved": "https://registry.npmjs.org/@types/prop-types/-/prop-types-15.7.15.tgz",
      "integrity": "sha512-F6bEyamV9jKGAFBEmlQnesRPGOQqS2+Uwi0Em15xenOxHaf2hv6L8YCVn3rPdPJOiJfPiCnLIRyvwVaqMY3MIw==",
      "license": "MIT"
    },
    "node_modules/@types/react": {
      "version": "19.2.7",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-19.2.7.tgz",
      "integrity": "sha512-MWtvHrGZLFttgeEj28VXHxpmwYbor/ATPYbBfSFZEIRK0ecCFLl2Qo55z52Hss+UV9CRN7trSeq1zbgx7YDWWg==",
      "license": "MIT",
      "dependencies": {
        "csstype": "^3.2.2"
      }
    },
    "node_modules/@types/react-dom": {
      "version": "19.2.2",
      "resolved": "https://registry.npmjs.org/@types/react-dom/-/react-dom-19.2.2.tgz",
      "integrity": "sha512-9KQPoO6mZCi7jcIStSnlOWn2nEF3mNmyr3rIAsGnAbQKYbRLyqmeSc39EVgtxXVia+LMT8j3knZLAZAh+xLmrw==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "^19.2.0"
      }
    },
    "node_modules/@types/react-transition-group": {
      "version": "4.4.12",
      "resolved": "https://registry.npmjs.org/@types/react-transition-group/-/react-transition-group-4.4.12.tgz",
      "integrity": "sha512-8TV6R3h2j7a91c+1DXdJi3Syo69zzIZbz7Lg5tORM5LEJG7X/E6a1V3drRyBRZq7/utz7A+c4OgYLiLcYGHG6w==",
      "license": "MIT",
      "peerDependencies": {
        "@types/react": "*"
      }
    },
    "node_modules/@types/use-sync-external-store": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/@types/use-sync-external-store/-/use-sync-external-store-0.0.6.tgz",
      "integrity": "sha512-zFDAD+tlpf2r4asuHEj0XH6pY6i0g5NeAHPn+15wk3BV6JA69eERFXC1gyGThDkVa1zCyKr5jox1+2LbV/AMLg==",
      "license": "MIT"
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-8.46.4.tgz",
      "integrity": "sha512-R48VhmTJqplNyDxCyqqVkFSZIx1qX6PzwqgcXn1olLrzxcSBDlOsbtcnQuQhNtnNiJ4Xe5gREI1foajYaYU2Vg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.10.0",
        "@typescript-eslint/scope-manager": "8.46.4",
        "@typescript-eslint/type-utils": "8.46.4",
        "@typescript-eslint/utils": "8.46.4",
        "@typescript-eslint/visitor-keys": "8.46.4",
        "graphemer": "^1.4.0",
        "ignore": "^7.0.0",
        "natural-compare": "^1.4.0",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^8.46.4",
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/eslint-plugin/node_modules/ignore": {
      "version": "7.0.5",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-7.0.5.tgz",
      "integrity": "sha512-Hs59xBNfUIunMFgWAbGX5cq6893IbWg4KnrjbYwX3tx0ztorVgTDA6B2sxf8ejHJ4wz8BqGUMYlnzNBer5NvGg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-8.46.4.tgz",
      "integrity": "sha512-tK3GPFWbirvNgsNKto+UmB/cRtn6TZfyw0D6IKrW55n6Vbs7KJoZtI//kpTKzE/DUmmnAFD8/Ca46s7Obs92/w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/scope-manager": "8.46.4",
        "@typescript-eslint/types": "8.46.4",
        "@typescript-eslint/typescript-estree": "8.46.4",
        "@typescript-eslint/visitor-keys": "8.46.4",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/project-service": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/project-service/-/project-service-8.46.4.tgz",
      "integrity": "sha512-nPiRSKuvtTN+no/2N1kt2tUh/HoFzeEgOm9fQ6XQk4/ApGqjx0zFIIaLJ6wooR1HIoozvj2j6vTi/1fgAz7UYQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/tsconfig-utils": "^8.46.4",
        "@typescript-eslint/types": "^8.46.4",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-8.46.4.tgz",
      "integrity": "sha512-tMDbLGXb1wC+McN1M6QeDx7P7c0UWO5z9CXqp7J8E+xGcJuUuevWKxuG8j41FoweS3+L41SkyKKkia16jpX7CA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.46.4",
        "@typescript-eslint/visitor-keys": "8.46.4"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/tsconfig-utils": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/tsconfig-utils/-/tsconfig-utils-8.46.4.tgz",
      "integrity": "sha512-+/XqaZPIAk6Cjg7NWgSGe27X4zMGqrFqZ8atJsX3CWxH/jACqWnrWI68h7nHQld0y+k9eTTjb9r+KU4twLoo9A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-8.46.4.tgz",
      "integrity": "sha512-V4QC8h3fdT5Wro6vANk6eojqfbv5bpwHuMsBcJUJkqs2z5XnYhJzyz9Y02eUmF9u3PgXEUiOt4w4KHR3P+z0PQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.46.4",
        "@typescript-eslint/typescript-estree": "8.46.4",
        "@typescript-eslint/utils": "8.46.4",
        "debug": "^4.3.4",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-8.46.4.tgz",
      "integrity": "sha512-USjyxm3gQEePdUwJBFjjGNG18xY9A2grDVGuk7/9AkjIF1L+ZrVnwR5VAU5JXtUnBL/Nwt3H31KlRDaksnM7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-8.46.4.tgz",
      "integrity": "sha512-7oV2qEOr1d4NWNmpXLR35LvCfOkTNymY9oyW+lUHkmCno7aOmIf/hMaydnJBUTBMRCOGZh8YjkFOc8dadEoNGA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/project-service": "8.46.4",
        "@typescript-eslint/tsconfig-utils": "8.46.4",
        "@typescript-eslint/types": "8.46.4",
        "@typescript-eslint/visitor-keys": "8.46.4",
        "debug": "^4.3.4",
        "fast-glob": "^3.3.2",
        "is-glob": "^4.0.3",
        "minimatch": "^9.0.4",
        "semver": "^7.6.0",
        "ts-api-utils": "^2.1.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree/node_modules/semver": {
      "version": "7.7.3",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.3.tgz",
      "integrity": "sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-8.46.4.tgz",
      "integrity": "sha512-AbSv11fklGXV6T28dp2Me04Uw90R2iJ30g2bgLz529Koehrmkbs1r7paFqr1vPCZi7hHwYxYtxfyQMRC8QaVSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.7.0",
        "@typescript-eslint/scope-manager": "8.46.4",
        "@typescript-eslint/types": "8.46.4",
        "@typescript-eslint/typescript-estree": "8.46.4"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-8.46.4.tgz",
      "integrity": "sha512-/++5CYLQqsO9HFGLI7APrxBJYo+5OCMpViuhV8q5/Qa3o5mMrF//eQHks+PXcsAVaLdn817fMuS7zqoXNNZGaw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "8.46.4",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@vitejs/plugin-react": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@vitejs/plugin-react/-/plugin-react-5.1.0.tgz",
      "integrity": "sha512-4LuWrg7EKWgQaMJfnN+wcmbAW+VSsCmqGohftWjuct47bv8uE4n/nPpq4XjJPsxgq00GGG5J8dvBczp8uxScew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/core": "^7.28.4",
        "@babel/plugin-transform-react-jsx-self": "^7.27.1",
        "@babel/plugin-transform-react-jsx-source": "^7.27.1",
        "@rolldown/pluginutils": "1.0.0-beta.43",
        "@types/babel__core": "^7.20.5",
        "react-refresh": "^0.18.0"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "peerDependencies": {
        "vite": "^4.2.0 || ^5.0.0 || ^6.0.0 || ^7.0.0"
      }
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "license": "MIT"
    },
    "node_modules/axios": {
      "version": "1.13.2",
      "resolved": "https://registry.npmjs.org/axios/-/axios-1.13.2.tgz",
      "integrity": "sha512-VPk9ebNqPcy5lRGuSlKx752IlDatOjT9paPlm8A7yOuW2Fbvp4X3JznJtT4f0GzGLLiWE9W8onz51SqLYwzGaA==",
      "license": "MIT",
      "dependencies": {
        "follow-redirects": "^1.15.6",
        "form-data": "^4.0.4",
        "proxy-from-env": "^1.1.0"
      }
    },
    "node_modules/babel-plugin-macros": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/babel-plugin-macros/-/babel-plugin-macros-3.1.0.tgz",
      "integrity": "sha512-Cg7TFGpIr01vOQNODXOOaGz2NpCU5gl8x1qJFbb6hbZxR7XrcE2vtbAsTAbJ7/xwJtUuJEw8K8Zr/AE0LHlesg==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.12.5",
        "cosmiconfig": "^7.0.0",
        "resolve": "^1.19.0"
      },
      "engines": {
        "node": ">=10",
        "npm": ">=6"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/baseline-browser-mapping": {
      "version": "2.8.25",
      "resolved": "https://registry.npmjs.org/baseline-browser-mapping/-/baseline-browser-mapping-2.8.25.tgz",
      "integrity": "sha512-2NovHVesVF5TXefsGX1yzx1xgr7+m9JQenvz6FQY3qd+YXkKkYiv+vTCc7OriP9mcDZpTC5mAOYN4ocd29+erA==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "baseline-browser-mapping": "dist/cli.js"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/browserslist": {
      "version": "4.28.0",
      "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.28.0.tgz",
      "integrity": "sha512-tbydkR/CxfMwelN0vwdP/pLkDwyAASZ+VfWm4EOwlB6SWhx1sYnWLqo8N5j0rAzPfzfRaxt0mM/4wPU/Su84RQ==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "baseline-browser-mapping": "^2.8.25",
        "caniuse-lite": "^1.0.30001754",
        "electron-to-chromium": "^1.5.249",
        "node-releases": "^2.0.27",
        "update-browserslist-db": "^1.1.4"
      },
      "bin": {
        "browserslist": "cli.js"
      },
      "engines": {
        "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/caniuse-lite": {
      "version": "1.0.30001754",
      "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001754.tgz",
      "integrity": "sha512-x6OeBXueoAceOmotzx3PO4Zpt4rzpeIFsSr6AAePTZxSkXiYDUmpypEl7e2+8NCd9bD7bXjqyef8CJYPC1jfxg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "CC-BY-4.0"
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/clsx": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/clsx/-/clsx-2.1.1.tgz",
      "integrity": "sha512-eYm0QWBtUrBWZWG0d386OGAw16Z995PiOVo2B7bjWSbHedGl5e0ZWaq65kOGgUSNesEIDkB9ISbTg/JK9dhCZA==",
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/convert-source-map": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-2.0.0.tgz",
      "integrity": "sha512-Kvp459HrV2FEJ1CAsi1Ku+MY3kasH19TFykTz2xWmMeq6bk2NU3XXvfJ+Q61m0xktWwt+1HSYf3JZsTms3aRJg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cookie": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-1.1.1.tgz",
      "integrity": "sha512-ei8Aos7ja0weRpFzJnEA9UHJ/7XQmqglbRwnf2ATjcB9Wq874VKH9kfjjirM6UhU2/E5fFYadylyhFldcqSidQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/cosmiconfig": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/cosmiconfig/-/cosmiconfig-7.1.0.tgz",
      "integrity": "sha512-AdmX6xUzdNASswsFtmwSt7Vj8po9IuqXm0UXz7QKPuEUmPB4XyjGfaAr2PSuELMwkRMVH1EpIkX5bTZGRB3eCA==",
      "license": "MIT",
      "dependencies": {
        "@types/parse-json": "^4.0.0",
        "import-fresh": "^3.2.1",
        "parse-json": "^5.0.0",
        "path-type": "^4.0.0",
        "yaml": "^1.10.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/cosmiconfig/node_modules/yaml": {
      "version": "1.10.2",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-1.10.2.tgz",
      "integrity": "sha512-r3vXyErRCYJ7wg28yvBY5VSoAF8ZvlcW9/BwUzEtUsjvX/DKs24dIkuwjtuprwJJHsbyUbLApepYTR1BN4uHrg==",
      "license": "ISC",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/csstype": {
      "version": "3.2.3",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.2.3.tgz",
      "integrity": "sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==",
      "license": "MIT"
    },
    "node_modules/d3-array": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/d3-array/-/d3-array-3.2.4.tgz",
      "integrity": "sha512-tdQAmyA18i4J7wprpYq8ClcxZy3SC31QMeByyCFyRt7BVHdREQZ5lpzoe5mFEYZUWe+oq8HBvk9JjpibyEV4Jg==",
      "license": "ISC",
      "dependencies": {
        "internmap": "1 - 2"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-color": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-color/-/d3-color-3.1.0.tgz",
      "integrity": "sha512-zg/chbXyeBtMQ1LbD/WSoW2DpC3I0mpmPdW+ynRTj/x2DAWYrIY7qeZIHidozwV24m4iavr15lNwIwLxRmOxhA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-ease": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-ease/-/d3-ease-3.0.1.tgz",
      "integrity": "sha512-wR/XK3D3XcLIZwpbvQwQ5fK+8Ykds1ip7A2Txe0yxncXSdq1L9skcG7blcedkOX+ZcgxGAmLX1FrRGbADwzi0w==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-format": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-format/-/d3-format-3.1.0.tgz",
      "integrity": "sha512-YyUI6AEuY/Wpt8KWLgZHsIU86atmikuoOmCfommt0LYHiQSPjvX2AcFc38PX0CBpr2RCyZhjex+NS/LPOv6YqA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-interpolate": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-interpolate/-/d3-interpolate-3.0.1.tgz",
      "integrity": "sha512-3bYs1rOD33uo8aqJfKP3JWPAibgw8Zm2+L9vBKEHJ2Rg+viTR7o5Mmv5mZcieN+FRYaAOWX5SJATX6k1PWz72g==",
      "license": "ISC",
      "dependencies": {
        "d3-color": "1 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-path": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-path/-/d3-path-3.1.0.tgz",
      "integrity": "sha512-p3KP5HCf/bvjBSSKuXid6Zqijx7wIfNW+J/maPs+iwR35at5JCbLUT0LzF1cnjbCHWhqzQTIN2Jpe8pRebIEFQ==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-scale": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/d3-scale/-/d3-scale-4.0.2.tgz",
      "integrity": "sha512-GZW464g1SH7ag3Y7hXjf8RoUuAFIqklOAq3MRl4OaWabTFJY9PN/E1YklhXLh+OQ3fM9yS2nOkCoS+WLZ6kvxQ==",
      "license": "ISC",
      "dependencies": {
        "d3-array": "2.10.0 - 3",
        "d3-format": "1 - 3",
        "d3-interpolate": "1.2.0 - 3",
        "d3-time": "2.1.1 - 3",
        "d3-time-format": "2 - 4"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-shape": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/d3-shape/-/d3-shape-3.2.0.tgz",
      "integrity": "sha512-SaLBuwGm3MOViRq2ABk3eLoxwZELpH6zhl3FbAoJ7Vm1gofKx6El1Ib5z23NUEhF9AsGl7y+dzLe5Cw2AArGTA==",
      "license": "ISC",
      "dependencies": {
        "d3-path": "^3.1.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-time": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/d3-time/-/d3-time-3.1.0.tgz",
      "integrity": "sha512-VqKjzBLejbSMT4IgbmVgDjpkYrNWUYJnbCGo874u7MMKIWsILRX+OpX/gTk8MqjpT1A/c6HY2dCA77ZN0lkQ2Q==",
      "license": "ISC",
      "dependencies": {
        "d3-array": "2 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-time-format": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/d3-time-format/-/d3-time-format-4.1.0.tgz",
      "integrity": "sha512-dJxPBlzC7NugB2PDLwo9Q8JiTR3M3e4/XANkreKSUxF8vvXKqm1Yfq4Q5dl8budlunRVlUUaDUgFt7eA8D6NLg==",
      "license": "ISC",
      "dependencies": {
        "d3-time": "1 - 3"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/d3-timer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/d3-timer/-/d3-timer-3.0.1.tgz",
      "integrity": "sha512-ndfJ/JxxMd3nw31uyKoY2naivF+r29V+Lc0svZxe1JvvIRmi8hUsrMvdOwgS1o6uBHmiz91geQ0ylPP0aj1VUA==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/decimal.js-light": {
      "version": "2.5.1",
      "resolved": "https://registry.npmjs.org/decimal.js-light/-/decimal.js-light-2.5.1.tgz",
      "integrity": "sha512-qIMFpTMZmny+MMIitAB6D7iVPEorVw6YQRWkvarTkT4tBeSLLiHzcwj6q0MmYSFCiVpiqPJTJEYIrpcPzVEIvg==",
      "license": "MIT"
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/dom-helpers": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/dom-helpers/-/dom-helpers-5.2.1.tgz",
      "integrity": "sha512-nRCa7CK3VTrM2NmGkIy4cbK7IZlgBE/PYMn55rrXefr5xXDP0LdtfPnblFDoVdcAfslJ7or6iqAUnx0CCGIWQA==",
      "license": "MIT",
      "dependencies": {
        "@babel/runtime": "^7.8.7",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/electron-to-chromium": {
      "version": "1.5.250",
      "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.250.tgz",
      "integrity": "sha512-/5UMj9IiGDMOFBnN4i7/Ry5onJrAGSbOGo3s9FEKmwobGq6xw832ccET0CE3CkkMBZ8GJSlUIesZofpyurqDXw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/error-ex": {
      "version": "1.3.4",
      "resolved": "https://registry.npmjs.org/error-ex/-/error-ex-1.3.4.tgz",
      "integrity": "sha512-sqQamAnR14VgCr1A618A3sGrygcpK+HEbenA/HiEAkkUwcZIIB/tgWqHFxWgOyDh4nB4JCRimh79dR5Ywc9MDQ==",
      "license": "MIT",
      "dependencies": {
        "is-arrayish": "^0.2.1"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-toolkit": {
      "version": "1.42.0",
      "resolved": "https://registry.npmjs.org/es-toolkit/-/es-toolkit-1.42.0.tgz",
      "integrity": "sha512-SLHIyY7VfDJBM8clz4+T2oquwTQxEzu263AyhVK4jREOAwJ+8eebaa4wM3nlvnAqhDrMm2EsA6hWHaQsMPQ1nA==",
      "license": "MIT",
      "workspaces": [
        "docs",
        "benchmarks"
      ]
    },
    "node_modules/esbuild": {
      "version": "0.25.12",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.25.12.tgz",
      "integrity": "sha512-bbPBYYrtZbkt6Os6FiTLCTFxvq4tt3JKall1vRwshA3fdVztsLAatFaZobhkBC8/BrPetoa0oksYoKXoG4ryJg==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.25.12",
        "@esbuild/android-arm": "0.25.12",
        "@esbuild/android-arm64": "0.25.12",
        "@esbuild/android-x64": "0.25.12",
        "@esbuild/darwin-arm64": "0.25.12",
        "@esbuild/darwin-x64": "0.25.12",
        "@esbuild/freebsd-arm64": "0.25.12",
        "@esbuild/freebsd-x64": "0.25.12",
        "@esbuild/linux-arm": "0.25.12",
        "@esbuild/linux-arm64": "0.25.12",
        "@esbuild/linux-ia32": "0.25.12",
        "@esbuild/linux-loong64": "0.25.12",
        "@esbuild/linux-mips64el": "0.25.12",
        "@esbuild/linux-ppc64": "0.25.12",
        "@esbuild/linux-riscv64": "0.25.12",
        "@esbuild/linux-s390x": "0.25.12",
        "@esbuild/linux-x64": "0.25.12",
        "@esbuild/netbsd-arm64": "0.25.12",
        "@esbuild/netbsd-x64": "0.25.12",
        "@esbuild/openbsd-arm64": "0.25.12",
        "@esbuild/openbsd-x64": "0.25.12",
        "@esbuild/openharmony-arm64": "0.25.12",
        "@esbuild/sunos-x64": "0.25.12",
        "@esbuild/win32-arm64": "0.25.12",
        "@esbuild/win32-ia32": "0.25.12",
        "@esbuild/win32-x64": "0.25.12"
      }
    },
    "node_modules/escalade": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "9.39.1",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-9.39.1.tgz",
      "integrity": "sha512-BhHmn2yNOFA9H9JmmIVKJmd288g9hrVRDkdoIgRCRuSySRUHH7r/DI6aAXW9T1WwUuY3DFgrcaqB+deURBLR5g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.8.0",
        "@eslint-community/regexpp": "^4.12.1",
        "@eslint/config-array": "^0.21.1",
        "@eslint/config-helpers": "^0.4.2",
        "@eslint/core": "^0.17.0",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "9.39.1",
        "@eslint/plugin-kit": "^0.4.1",
        "@humanfs/node": "^0.16.6",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@humanwhocodes/retry": "^0.4.2",
        "@types/estree": "^1.0.6",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.6",
        "debug": "^4.3.2",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^8.4.0",
        "eslint-visitor-keys": "^4.2.1",
        "espree": "^10.4.0",
        "esquery": "^1.5.0",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^8.0.0",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://eslint.org/donate"
      },
      "peerDependencies": {
        "jiti": "*"
      },
      "peerDependenciesMeta": {
        "jiti": {
          "optional": true
        }
      }
    },
    "node_modules/eslint-plugin-react-hooks": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-hooks/-/eslint-plugin-react-hooks-5.2.0.tgz",
      "integrity": "sha512-+f15FfK64YQwZdJNELETdn5ibXEUQmW1DZL6KXhNnc2heoy/sg9VJJeT7n8TlMWouzWqSWavFkIhHyIbIAEapg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "peerDependencies": {
        "eslint": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0 || ^8.0.0-0 || ^9.0.0"
      }
    },
    "node_modules/eslint-plugin-react-refresh": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/eslint-plugin-react-refresh/-/eslint-plugin-react-refresh-0.4.24.tgz",
      "integrity": "sha512-nLHIW7TEq3aLrEYWpVaJ1dRgFR+wLDPN8e8FpYAql/bMV2oBEfC37K0gLEGgv9fy66juNShSMV8OkTqzltcG/w==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "eslint": ">=8.40"
      }
    },
    "node_modules/eslint-scope": {
      "version": "8.4.0",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-8.4.0.tgz",
      "integrity": "sha512-sNXOfKCn74rt8RICKMvJS7XKV/Xk9kA7DyJr8mJik3S7Cwgy3qlkkmyS2uQB3jiJg6VNdZd/pDBJu0nvG2NlTg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-4.2.1.tgz",
      "integrity": "sha512-Uhdk5sfqcee/9H/rCOJikYz67o0a2Tw2hGRPOG2Y1R2dg7brRe1uG0yaNQDHu+TO/uQPF/5eCapvYSmHUjt7JQ==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/espree": {
      "version": "10.4.0",
      "resolved": "https://registry.npmjs.org/espree/-/espree-10.4.0.tgz",
      "integrity": "sha512-j6PAQ2uUr79PZhBjP5C5fhl8e39FmRnOjsD5lGnWrFU8i2G776tBK7+nP8KuQUTTyAZUwfQqXAgrVH5MbH9CYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.15.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^4.2.1"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz",
      "integrity": "sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/eventemitter3": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-5.0.1.tgz",
      "integrity": "sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA==",
      "license": "MIT"
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastq": {
      "version": "1.19.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.19.1.tgz",
      "integrity": "sha512-GwLTyxkCXjXbxqIhTsMI2Nui8huMPtnxg7krajPJAjnEG/iiOS7i+zCtWGZR9G0NBKbXKh6X9m9UIsYX/N6vvQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-8.0.0.tgz",
      "integrity": "sha512-XXTUwCvisa5oacNGRP9SfNtYBNAMi+RPwBFmblZEF7N7swHYQS6/Zfk7SRwx4D5j3CH211YNRco1DEMNVfZCnQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^4.0.0"
      },
      "engines": {
        "node": ">=16.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-root": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/find-root/-/find-root-1.1.0.tgz",
      "integrity": "sha512-NKfW6bec6GfKc0SGx1e07QZY9PE99u0Bft/0rzSD5k3sO/vwkVUpDUKVm5Gpp5Ue3YfShPFTX2070tDs5kB9Ng==",
      "license": "MIT"
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-4.0.1.tgz",
      "integrity": "sha512-f7ccFPK3SXFHpx15UIGyRJ/FJQctuKZ0zVuN3frBo4HnK3cay9VEW0R6yPYFHC0AgqhukPzKjq22t5DmAyqGyw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.4"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/follow-redirects": {
      "version": "1.15.11",
      "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.15.11.tgz",
      "integrity": "sha512-deG2P0JfjrTxl50XGCDyfI97ZGVCxIpfKYmfyrQ54n5FO/0gfIES8C/Psl6kWVDolizcaaxZJnTS0QSMxvnsBQ==",
      "funding": [
        {
          "type": "individual",
          "url": "https://github.com/sponsors/RubenVerborgh"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=4.0"
      },
      "peerDependenciesMeta": {
        "debug": {
          "optional": true
        }
      }
    },
    "node_modules/form-data": {
      "version": "4.0.5",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.5.tgz",
      "integrity": "sha512-8RipRLol37bNs2bhoV67fiTEvdTrbMUYcFTiy3+wuuOnUog2QBHCZWXDRijWQfAkhBj2Uf5UnVaiWwA5vdd82w==",
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "hasown": "^2.0.2",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/gensync": {
      "version": "1.0.0-beta.2",
      "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
      "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/globals": {
      "version": "16.5.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-16.5.0.tgz",
      "integrity": "sha512-c/c15i26VrJ4IRt5Z89DnIzCGDn9EcebibhAOjw5ibqEHsE1wLUgkPn9RDmNcUKyU87GeaL633nyJ+pplFR2ZQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/graphemer": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/graphemer/-/graphemer-1.4.0.tgz",
      "integrity": "sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/hoist-non-react-statics": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/hoist-non-react-statics/-/hoist-non-react-statics-3.3.2.tgz",
      "integrity": "sha512-/gGivxi8JPKWNm/W0jSmzcMPpfpPLc3dY/6GxhX2hQ9iGj3aDfklV4ET7NjKpSinLpJ5vafa9iiGIEZg10SfBw==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "react-is": "^16.7.0"
      }
    },
    "node_modules/hoist-non-react-statics/node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "license": "MIT"
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/immer": {
      "version": "10.2.0",
      "resolved": "https://registry.npmjs.org/immer/-/immer-10.2.0.tgz",
      "integrity": "sha512-d/+XTN3zfODyjr89gM3mPq1WNX2B8pYsu7eORitdwyA2sBubnTl3laYlBk4sXY5FUa5qTZGBDPJICVbvqzjlbw==",
      "license": "MIT",
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/immer"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/internmap": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/internmap/-/internmap-2.0.3.tgz",
      "integrity": "sha512-5Hh7Y1wQbvY5ooGgPbDaL5iYLAPzMTUrjMulskHLH6wnv/A+1q5rgEaiuqEjB+oxGXIVZs1FF+R/KPN3ZSQYYg==",
      "license": "ISC",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/is-arrayish": {
      "version": "0.2.1",
      "resolved": "https://registry.npmjs.org/is-arrayish/-/is-arrayish-0.2.1.tgz",
      "integrity": "sha512-zz06S8t0ozoDXMG+ube26zeCTNXcKIPJZJi8hBrF4idCLms4CG9QtK7qBl1boi5ODzFpjswb5JPmHCbMpjaYzg==",
      "license": "MIT"
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/js-tokens": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
      "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
      "license": "MIT"
    },
    "node_modules/js-yaml": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsesc": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-3.1.0.tgz",
      "integrity": "sha512-/sM3dO2FOzXjKQhJuo0Q173wf2KOo8t4I8vHy6lF9poUp7bKT0/NHE8fPX23PwfhnykfqnC2xRxOnVw5XuGIaA==",
      "license": "MIT",
      "bin": {
        "jsesc": "bin/jsesc"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-parse-even-better-errors": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/json-parse-even-better-errors/-/json-parse-even-better-errors-2.3.1.tgz",
      "integrity": "sha512-xyFwyhro/JEof6Ghe2iz2NcXoj2sloNsWr/XsERDK/oiPCfaNhl5ONfp+jQdAZRQQ0IJWNzH9zIZF7li91kh2w==",
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json5": {
      "version": "2.2.3",
      "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.3.tgz",
      "integrity": "sha512-XmOWe7eyHYH14cLdVPoyg+GOH3rYX++KpzrylJwSW98t3Nk+U8XOl8FWKOgwtzdb8lXGf6zYwDUzeHMWfxasyg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "json5": "lib/cli.js"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/leaflet": {
      "version": "1.9.4",
      "resolved": "https://registry.npmjs.org/leaflet/-/leaflet-1.9.4.tgz",
      "integrity": "sha512-nxS1ynzJOmOlHp+iL3FyWqK89GtNL8U8rvlMOsQdTTssxZwCXh8N2NB3GDQOL+YR3XnWyZAxwQixURb+FA74PA==",
      "license": "BSD-2-Clause"
    },
    "node_modules/leaflet-defaulticon-compatibility": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/leaflet-defaulticon-compatibility/-/leaflet-defaulticon-compatibility-0.1.2.tgz",
      "integrity": "sha512-IrKagWxkTwzxUkFIumy/Zmo3ksjuAu3zEadtOuJcKzuXaD76Gwvg2Z1mLyx7y52ykOzM8rAH5ChBs4DnfdGa6Q==",
      "license": "BSD-2-Clause"
    },
    "node_modules/leaflet.heat": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/leaflet.heat/-/leaflet.heat-0.2.0.tgz",
      "integrity": "sha512-Cd5PbAA/rX3X3XKxfDoUGi9qp78FyhWYurFg3nsfhntcM/MCNK08pRkf4iEenO1KNqwVPKCmkyktjW3UD+h9bQ=="
    },
    "node_modules/leaflet.markercluster": {
      "version": "1.5.3",
      "resolved": "https://registry.npmjs.org/leaflet.markercluster/-/leaflet.markercluster-1.5.3.tgz",
      "integrity": "sha512-vPTw/Bndq7eQHjLBVlWpnGeLa3t+3zGiuM7fJwCkiMFq+nmRuG3RI3f7f4N4TDX7T4NpbAXpR2+NTRSEGfCSeA==",
      "license": "MIT",
      "peerDependencies": {
        "leaflet": "^1.3.1"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lines-and-columns": {
      "version": "1.2.4",
      "resolved": "https://registry.npmjs.org/lines-and-columns/-/lines-and-columns-1.2.4.tgz",
      "integrity": "sha512-7ylylesZQ/PV29jhEDl3Ufjo6ZX7gCqJr5F7PKrqc93v7fzSymt1BpwEU8nAUXs8qzzvqhbjhK5QZg6Mt/HkBg==",
      "license": "MIT"
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/loose-envify": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/loose-envify/-/loose-envify-1.4.0.tgz",
      "integrity": "sha512-lyuxPGr/Wfhrlem2CL/UcnUc1zcqKAImBDzukY7Y5F/yQiNdko6+fRLevlw1HgMySw7f611UIY408EtxRSoK3Q==",
      "license": "MIT",
      "dependencies": {
        "js-tokens": "^3.0.0 || ^4.0.0"
      },
      "bin": {
        "loose-envify": "cli.js"
      }
    },
    "node_modules/lru-cache": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-5.1.1.tgz",
      "integrity": "sha512-KpNARQA3Iwv+jTA0utUVVbrh+Jlrr1Fv0e56GGzAFOXN7dk/FviaDW8LHmK52DlcH4WP2n6gI8vN1aesBFgo9w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "yallist": "^3.0.2"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/node-releases": {
      "version": "2.0.27",
      "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.27.tgz",
      "integrity": "sha512-nmh3lCkYZ3grZvqcCH+fjmQ7X+H0OeZgP40OierEaAptX4XofMh5kwNbWh7lBduUzCcV/8kZ+NDLCwm2iorIlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/parse-json": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/parse-json/-/parse-json-5.2.0.tgz",
      "integrity": "sha512-ayCKvm/phCGxOkYRSCM82iDwct8/EonSEgCSxWxD7ve6jHggsFl4fZVQBPRNgQoKiuV/odhFrGzQXZwbifC8Rg==",
      "license": "MIT",
      "dependencies": {
        "@babel/code-frame": "^7.0.0",
        "error-ex": "^1.3.1",
        "json-parse-even-better-errors": "^2.3.0",
        "lines-and-columns": "^1.1.6"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "license": "MIT"
    },
    "node_modules/path-type": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/prop-types": {
      "version": "15.8.1",
      "resolved": "https://registry.npmjs.org/prop-types/-/prop-types-15.8.1.tgz",
      "integrity": "sha512-oj87CgZICdulUohogVAR7AjlC0327U4el4L6eAvOqCeudMDVU0NThNaV+b9Df4dXgSP1gXMTnPdhfe/2qDH5cg==",
      "license": "MIT",
      "dependencies": {
        "loose-envify": "^1.4.0",
        "object-assign": "^4.1.1",
        "react-is": "^16.13.1"
      }
    },
    "node_modules/prop-types/node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "license": "MIT"
    },
    "node_modules/proxy-from-env": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg==",
      "license": "MIT"
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/react": {
      "version": "19.2.0",
      "resolved": "https://registry.npmjs.org/react/-/react-19.2.0.tgz",
      "integrity": "sha512-tmbWg6W31tQLeB5cdIBOicJDJRR2KzXsV7uSK9iNfLWQ5bIZfxuPEHp7M8wiHyHnn0DD1i7w3Zmin0FtkrwoCQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-dom": {
      "version": "19.2.0",
      "resolved": "https://registry.npmjs.org/react-dom/-/react-dom-19.2.0.tgz",
      "integrity": "sha512-UlbRu4cAiGaIewkPyiRGJk0imDN2T3JjieT6spoL2UeSf5od4n5LB/mQ4ejmxhCFT1tYe8IvaFulzynWovsEFQ==",
      "license": "MIT",
      "dependencies": {
        "scheduler": "^0.27.0"
      },
      "peerDependencies": {
        "react": "^19.2.0"
      }
    },
    "node_modules/react-is": {
      "version": "19.2.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-19.2.1.tgz",
      "integrity": "sha512-L7BnWgRbMwzMAubQcS7sXdPdNLmKlucPlopgAzx7FtYbksWZgEWiuYM5x9T6UqS2Ne0rsgQTq5kY2SGqpzUkYA==",
      "license": "MIT"
    },
    "node_modules/react-leaflet": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/react-leaflet/-/react-leaflet-5.0.0.tgz",
      "integrity": "sha512-CWbTpr5vcHw5bt9i4zSlPEVQdTVcML390TjeDG0cK59z1ylexpqC6M1PJFjV8jD7CF+ACBFsLIDs6DRMoLEofw==",
      "license": "Hippocratic-2.1",
      "dependencies": {
        "@react-leaflet/core": "^3.0.0"
      },
      "peerDependencies": {
        "leaflet": "^1.9.0",
        "react": "^19.0.0",
        "react-dom": "^19.0.0"
      }
    },
    "node_modules/react-leaflet-cluster": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/react-leaflet-cluster/-/react-leaflet-cluster-4.0.0.tgz",
      "integrity": "sha512-Lu75+KOu2ruGyAx8LoCQvlHuw+3CLLJQGEoSk01ymsDN/YnCiRV6ChkpsvaruVyYBPzUHwiskFw4Jo7WHj5qNw==",
      "license": "SEE LICENSE IN <LICENSE>",
      "dependencies": {
        "leaflet.markercluster": "^1.5.3"
      },
      "peerDependencies": {
        "@react-leaflet/core": "^3.0.0",
        "leaflet": "^1.9.0",
        "react": "^19.0.0",
        "react-dom": "^19.0.0",
        "react-leaflet": "^5.0.0"
      }
    },
    "node_modules/react-redux": {
      "version": "9.2.0",
      "resolved": "https://registry.npmjs.org/react-redux/-/react-redux-9.2.0.tgz",
      "integrity": "sha512-ROY9fvHhwOD9ySfrF0wmvu//bKCQ6AeZZq1nJNtbDC+kk5DuSuNX/n6YWYF/SYy7bSba4D4FSz8DJeKY/S/r+g==",
      "license": "MIT",
      "dependencies": {
        "@types/use-sync-external-store": "^0.0.6",
        "use-sync-external-store": "^1.4.0"
      },
      "peerDependencies": {
        "@types/react": "^18.2.25 || ^19",
        "react": "^18.0 || ^19",
        "redux": "^5.0.0"
      },
      "peerDependenciesMeta": {
        "@types/react": {
          "optional": true
        },
        "redux": {
          "optional": true
        }
      }
    },
    "node_modules/react-refresh": {
      "version": "0.18.0",
      "resolved": "https://registry.npmjs.org/react-refresh/-/react-refresh-0.18.0.tgz",
      "integrity": "sha512-QgT5//D3jfjJb6Gsjxv0Slpj23ip+HtOpnNgnb2S5zU3CB26G/IDPGoy4RJB42wzFE46DRsstbW6tKHoKbhAxw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/react-router": {
      "version": "7.10.1",
      "resolved": "https://registry.npmjs.org/react-router/-/react-router-7.10.1.tgz",
      "integrity": "sha512-gHL89dRa3kwlUYtRQ+m8NmxGI6CgqN+k4XyGjwcFoQwwCWF6xXpOCUlDovkXClS0d0XJN/5q7kc5W3kiFEd0Yw==",
      "license": "MIT",
      "dependencies": {
        "cookie": "^1.0.1",
        "set-cookie-parser": "^2.6.0"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      },
      "peerDependenciesMeta": {
        "react-dom": {
          "optional": true
        }
      }
    },
    "node_modules/react-router-dom": {
      "version": "7.10.1",
      "resolved": "https://registry.npmjs.org/react-router-dom/-/react-router-dom-7.10.1.tgz",
      "integrity": "sha512-JNBANI6ChGVjA5bwsUIwJk7LHKmqB4JYnYfzFwyp2t12Izva11elds2jx7Yfoup2zssedntwU0oZ5DEmk5Sdaw==",
      "license": "MIT",
      "dependencies": {
        "react-router": "7.10.1"
      },
      "engines": {
        "node": ">=20.0.0"
      },
      "peerDependencies": {
        "react": ">=18",
        "react-dom": ">=18"
      }
    },
    "node_modules/react-transition-group": {
      "version": "4.4.5",
      "resolved": "https://registry.npmjs.org/react-transition-group/-/react-transition-group-4.4.5.tgz",
      "integrity": "sha512-pZcd1MCJoiKiBR2NRxeCRg13uCXbydPnmB4EOeRrY7480qNWO8IIgQG6zlDkm6uRMsURXPuKq0GWtiM59a5Q6g==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@babel/runtime": "^7.5.5",
        "dom-helpers": "^5.0.1",
        "loose-envify": "^1.4.0",
        "prop-types": "^15.6.2"
      },
      "peerDependencies": {
        "react": ">=16.6.0",
        "react-dom": ">=16.6.0"
      }
    },
    "node_modules/recharts": {
      "version": "3.5.1",
      "resolved": "https://registry.npmjs.org/recharts/-/recharts-3.5.1.tgz",
      "integrity": "sha512-+v+HJojK7gnEgG6h+b2u7k8HH7FhyFUzAc4+cPrsjL4Otdgqr/ecXzAnHciqlzV1ko064eNcsdzrYOM78kankA==",
      "license": "MIT",
      "workspaces": [
        "www"
      ],
      "dependencies": {
        "@reduxjs/toolkit": "1.x.x || 2.x.x",
        "clsx": "^2.1.1",
        "decimal.js-light": "^2.5.1",
        "es-toolkit": "^1.39.3",
        "eventemitter3": "^5.0.1",
        "immer": "^10.1.1",
        "react-redux": "8.x.x || 9.x.x",
        "reselect": "5.1.1",
        "tiny-invariant": "^1.3.3",
        "use-sync-external-store": "^1.2.2",
        "victory-vendor": "^37.0.2"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-dom": "^16.0.0 || ^17.0.0 || ^18.0.0 || ^19.0.0",
        "react-is": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/redux": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/redux/-/redux-5.0.1.tgz",
      "integrity": "sha512-M9/ELqF6fy8FwmkpnF0S3YKOqMyoWJ4+CS5Efg2ct3oY9daQvd/Pc71FpGZsVsbl3Cpb+IIcjBDUnnyBdQbq4w==",
      "license": "MIT"
    },
    "node_modules/redux-thunk": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/redux-thunk/-/redux-thunk-3.1.0.tgz",
      "integrity": "sha512-NW2r5T6ksUKXCabzhL9z+h206HQw/NJkcLm1GPImRQ8IzfXwRGqjVhKJGauHirT0DAuyy6hjdnMZaRoAcy0Klw==",
      "license": "MIT",
      "peerDependencies": {
        "redux": "^5.0.0"
      }
    },
    "node_modules/reselect": {
      "version": "5.1.1",
      "resolved": "https://registry.npmjs.org/reselect/-/reselect-5.1.1.tgz",
      "integrity": "sha512-K/BG6eIky/SBpzfHZv/dd+9JBFiS4SWV7FIujVyJRux6e45+73RaUHXLmIR1f7WOMaQ0U1km6qwklRQxpJJY0w==",
      "license": "MIT"
    },
    "node_modules/resolve": {
      "version": "1.22.11",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.11.tgz",
      "integrity": "sha512-RfqAvLnMl313r7c9oclB1HhUEAezcpLjz95wFH4LVuhk9JF/r22qmVP9AMmOU4vMX7Q8pN8jwNg/CSpdFnMjTQ==",
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.1",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rollup": {
      "version": "4.53.2",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.53.2.tgz",
      "integrity": "sha512-MHngMYwGJVi6Fmnk6ISmnk7JAHRNF0UkuucA0CUW3N3a4KnONPEZz+vUanQP/ZC/iY1Qkf3bwPWzyY84wEks1g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.53.2",
        "@rollup/rollup-android-arm64": "4.53.2",
        "@rollup/rollup-darwin-arm64": "4.53.2",
        "@rollup/rollup-darwin-x64": "4.53.2",
        "@rollup/rollup-freebsd-arm64": "4.53.2",
        "@rollup/rollup-freebsd-x64": "4.53.2",
        "@rollup/rollup-linux-arm-gnueabihf": "4.53.2",
        "@rollup/rollup-linux-arm-musleabihf": "4.53.2",
        "@rollup/rollup-linux-arm64-gnu": "4.53.2",
        "@rollup/rollup-linux-arm64-musl": "4.53.2",
        "@rollup/rollup-linux-loong64-gnu": "4.53.2",
        "@rollup/rollup-linux-ppc64-gnu": "4.53.2",
        "@rollup/rollup-linux-riscv64-gnu": "4.53.2",
        "@rollup/rollup-linux-riscv64-musl": "4.53.2",
        "@rollup/rollup-linux-s390x-gnu": "4.53.2",
        "@rollup/rollup-linux-x64-gnu": "4.53.2",
        "@rollup/rollup-linux-x64-musl": "4.53.2",
        "@rollup/rollup-openharmony-arm64": "4.53.2",
        "@rollup/rollup-win32-arm64-msvc": "4.53.2",
        "@rollup/rollup-win32-ia32-msvc": "4.53.2",
        "@rollup/rollup-win32-x64-gnu": "4.53.2",
        "@rollup/rollup-win32-x64-msvc": "4.53.2",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/scheduler": {
      "version": "0.27.0",
      "resolved": "https://registry.npmjs.org/scheduler/-/scheduler-0.27.0.tgz",
      "integrity": "sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "6.3.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.1.tgz",
      "integrity": "sha512-BR7VvDCVHO+q2xBEWskxS6DJE1qRnb7DxzUrogb71CWoSficBxYsiAGd+Kl0mmq/MprG9yArRkyrQxTO6XjMzA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/set-cookie-parser": {
      "version": "2.7.2",
      "resolved": "https://registry.npmjs.org/set-cookie-parser/-/set-cookie-parser-2.7.2.tgz",
      "integrity": "sha512-oeM1lpU/UvhTxw+g3cIfxXHyJRc/uidd3yK1P242gzHds0udQBYzs3y8j4gCCW+ZJ7ad0yctld8RYO+bdurlvw==",
      "license": "MIT"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/source-map": {
      "version": "0.5.7",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
      "integrity": "sha512-LbrmJOMUSdEVxIKvdcJzQC+nQhe8FUZQTXQy6+I75skNgn3OoQ0DZA8YnFa7gp8tqtL3KPf1kmo0R5DoApeSGQ==",
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/stylis": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/stylis/-/stylis-4.2.0.tgz",
      "integrity": "sha512-Orov6g6BB1sDfYgzWfTHDOxamtX1bE/zo104Dh9e6fqJ3PooipYyfJ0pUmrZO2wAvO8YbEyeFrkV91XTsGMSrw==",
      "license": "MIT"
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/tiny-invariant": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/tiny-invariant/-/tiny-invariant-1.3.3.tgz",
      "integrity": "sha512-+FbBPE1o9QAYvviau/qC5SE3caw21q3xkvWKBtja5vgqOWIHHJ3ioaq1VPfn/Szqctz2bU/oYeKd9/z5BL+PVg==",
      "license": "MIT"
    },
    "node_modules/tinyglobby": {
      "version": "0.2.15",
      "resolved": "https://registry.npmjs.org/tinyglobby/-/tinyglobby-0.2.15.tgz",
      "integrity": "sha512-j2Zq4NyQYG5XMST4cbs02Ak8iJUdxRM0XI5QyxXuZOzKOINmWurp3smXu3y5wDcJrptwpSjgXHzIQxR0omXljQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3"
      },
      "engines": {
        "node": ">=12.0.0"
      },
      "funding": {
        "url": "https://github.com/sponsors/SuperchupuDev"
      }
    },
    "node_modules/tinyglobby/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/tinyglobby/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-2.1.0.tgz",
      "integrity": "sha512-CUgTZL1irw8u29bzrOD/nH85jqyc74D6SshFgujOIA7osm2Rz7dYH77agkx7H4FBNxDq7Cjf+IjaX/8zwFW+ZQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18.12"
      },
      "peerDependencies": {
        "typescript": ">=4.8.4"
      }
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
      "integrity": "sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/typescript-eslint": {
      "version": "8.46.4",
      "resolved": "https://registry.npmjs.org/typescript-eslint/-/typescript-eslint-8.46.4.tgz",
      "integrity": "sha512-KALyxkpYV5Ix7UhvjTwJXZv76VWsHG+NjNlt/z+a17SOQSiOcBdUXdbJdyXi7RPxrBFECtFOiPwUJQusJuCqrg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/eslint-plugin": "8.46.4",
        "@typescript-eslint/parser": "8.46.4",
        "@typescript-eslint/typescript-estree": "8.46.4",
        "@typescript-eslint/utils": "8.46.4"
      },
      "engines": {
        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^8.57.0 || ^9.0.0",
        "typescript": ">=4.8.4 <6.0.0"
      }
    },
    "node_modules/undici-types": {
      "version": "7.16.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.16.0.tgz",
      "integrity": "sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/update-browserslist-db": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/update-browserslist-db/-/update-browserslist-db-1.1.4.tgz",
      "integrity": "sha512-q0SPT4xyU84saUX+tomz1WLkxUbuaJnR1xWt17M7fJtEJigJeWUNGUqrauFXsHnqev9y9JTRGwk13tFBuKby4A==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/browserslist"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/browserslist"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "escalade": "^3.2.0",
        "picocolors": "^1.1.1"
      },
      "bin": {
        "update-browserslist-db": "cli.js"
      },
      "peerDependencies": {
        "browserslist": ">= 4.21.0"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/use-sync-external-store": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/use-sync-external-store/-/use-sync-external-store-1.6.0.tgz",
      "integrity": "sha512-Pp6GSwGP/NrPIrxVFAIkOQeyw8lFenOHijQWkUTrDvrF4ALqylP2C/KCkeS9dpUM3KvYRQhna5vt7IL95+ZQ9w==",
      "license": "MIT",
      "peerDependencies": {
        "react": "^16.8.0 || ^17.0.0 || ^18.0.0 || ^19.0.0"
      }
    },
    "node_modules/victory-vendor": {
      "version": "37.3.6",
      "resolved": "https://registry.npmjs.org/victory-vendor/-/victory-vendor-37.3.6.tgz",
      "integrity": "sha512-SbPDPdDBYp+5MJHhBCAyI7wKM3d5ivekigc2Dk2s7pgbZ9wIgIBYGVw4zGHBml/qTFbexrofXW6Gu4noGxrOwQ==",
      "license": "MIT AND ISC",
      "dependencies": {
        "@types/d3-array": "^3.0.3",
        "@types/d3-ease": "^3.0.0",
        "@types/d3-interpolate": "^3.0.1",
        "@types/d3-scale": "^4.0.2",
        "@types/d3-shape": "^3.1.0",
        "@types/d3-time": "^3.0.0",
        "@types/d3-timer": "^3.0.0",
        "d3-array": "^3.1.6",
        "d3-ease": "^3.0.1",
        "d3-interpolate": "^3.0.1",
        "d3-scale": "^4.0.2",
        "d3-shape": "^3.1.0",
        "d3-time": "^3.0.0",
        "d3-timer": "^3.0.1"
      }
    },
    "node_modules/vite": {
      "version": "7.2.2",
      "resolved": "https://registry.npmjs.org/vite/-/vite-7.2.2.tgz",
      "integrity": "sha512-BxAKBWmIbrDgrokdGZH1IgkIk/5mMHDreLDmCJ0qpyJaAteP8NvMhkwr/ZCQNqNH97bw/dANTE9PDzqwJghfMQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.25.0",
        "fdir": "^6.5.0",
        "picomatch": "^4.0.3",
        "postcss": "^8.5.6",
        "rollup": "^4.43.0",
        "tinyglobby": "^0.2.15"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^20.19.0 || >=22.12.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^20.19.0 || >=22.12.0",
        "jiti": ">=1.21.0",
        "less": "^4.0.0",
        "lightningcss": "^1.21.0",
        "sass": "^1.70.0",
        "sass-embedded": "^1.70.0",
        "stylus": ">=0.54.8",
        "sugarss": "^5.0.0",
        "terser": "^5.16.0",
        "tsx": "^4.8.1",
        "yaml": "^2.4.2"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "jiti": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        },
        "tsx": {
          "optional": true
        },
        "yaml": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/fdir": {
      "version": "6.5.0",
      "resolved": "https://registry.npmjs.org/fdir/-/fdir-6.5.0.tgz",
      "integrity": "sha512-tIbYtZbucOs0BRGqPJkshJUYdL+SDH7dVM8gjy+ERp3WAUjLEFJE+02kanyHtwjWOnwrKYBiwAmM0p4kLJAnXg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12.0.0"
      },
      "peerDependencies": {
        "picomatch": "^3 || ^4"
      },
      "peerDependenciesMeta": {
        "picomatch": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/picomatch": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-4.0.3.tgz",
      "integrity": "sha512-5gTmgEY/sqK6gFXLIsQNH19lWb4ebPDLA4SdLP7dsWkIXHWlG66oPuVvXSGFPppYZz8ZDZq0dYYrbHfBCVUb1Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/yallist": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yallist/-/yallist-3.1.1.tgz",
      "integrity": "sha512-a4UGQaWPH59mOXUYnAG2ewncQS4i4F43Tv3JoAM+s2VDAmS9NsK8GpDMLrCHPksFT7h3K6TOoUNn2pb7RoXx4g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yaml": {
      "version": "2.8.2",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.8.2.tgz",
      "integrity": "sha512-mplynKqc1C2hTVYxd0PU2xQAc22TI1vShAYGksCCfxbn/dFwnHTNi1bvYsBTkhdUNtGIf5xNOg938rrSSYvS9A==",
      "dev": true,
      "license": "ISC",
      "optional": true,
      "peer": true,
      "bin": {
        "yaml": "bin.mjs"
      },
      "engines": {
        "node": ">= 14.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/eemeli"
      }
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    }
  }
}

</code>

## segfault-frontend\package.json
<code>
{
  "name": "segfault-frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "@mui/icons-material": "^5.18.0",
    "@mui/material": "^5.18.0",
    "@mui/system": "^5.18.0",
    "axios": "^1.13.2",
    "leaflet": "^1.9.4",
    "leaflet-defaulticon-compatibility": "^0.1.2",
    "leaflet.heat": "^0.2.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-leaflet": "^5.0.0",
    "react-leaflet-cluster": "^4.0.0",
    "react-router-dom": "^7.10.1",
    "recharts": "^3.5.1"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/leaflet": "^1.9.21",
    "@types/node": "^24.10.0",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.2",
    "@vitejs/plugin-react": "^5.1.0",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.3",
    "vite": "^7.2.2"
  }
}

</code>

## segfault-frontend\README.md
<code>
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

</code>

## segfault-frontend\tsconfig.app.json
<code>
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

</code>

## segfault-frontend\tsconfig.json
<code>
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

</code>

## segfault-frontend\tsconfig.node.json
<code>
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

</code>

## segfault-frontend\vite.config.ts
<code>
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})

</code>

## segfault-frontend\src\App.css
<code>
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

</code>

## segfault-frontend\src\App.tsx
<code>
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider, CssBaseline } from '@mui/material';
import theme from './theme';
import { AuthProvider, useAuth } from './state/authContext';
import Landing from './pages/Landing/Landing';
import Login from './pages/Login/Login';
import Register from './pages/Register/Register';
import Dashboard from './pages/Dashboard/Dashboard';
import AuthCallback from './pages/AuthCallback/AuthCallback';
import AdminDashboard from './pages/Admin/AdminDashboard';

// Protected route for admin only
const AdminRoute = ({ children }: { children: React.ReactNode }) => {
  const { user } = useAuth();
  if (!user || user.role !== 'ADMIN') {
    return <Navigate to="/dashboard" replace />;
  }
  return children;
};

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <AuthProvider>
        <Router>
          <Routes>
            <Route path="/" element={<Landing />} />
            <Route path="/login" element={<Login />} />
            <Route path="/register" element={<Register />} />
            <Route path="/forgot-password" element={<Login />} />
            <Route path="/dashboard" element={<Dashboard />} />
            <Route path="/auth/google/callback" element={<AuthCallback />} />
            <Route
              path="/admin"
              element={
                <AdminRoute>
                  <AdminDashboard />
                </AdminRoute>
              }
            />
          </Routes>
        </Router>
      </AuthProvider>
    </ThemeProvider>
  );
}

export default App;

</code>

## segfault-frontend\src\constants.ts
<code>
export const AZURE_BACKEND_URL = 'https://segfault-backend.politeriver-a25e3b65.westeurope.azurecontainerapps.io';
export const AZURE_FRONTEND_URL = 'https://segfault-frontend.politeriver-a25e3b65.westeurope.azurecontainerapps.io';

</code>

## segfault-frontend\src\index.css
<code>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  width: 100%;
  height: 100%;
  overflow-x: hidden;
}

body {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#root {
  width: 100%;
  min-height: 100vh;
}

a {
  color: inherit;
  text-decoration: none;
}

</code>

## segfault-frontend\src\main.tsx
<code>
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

</code>

## segfault-frontend\src\theme.ts
<code>
import { createTheme } from '@mui/material/styles';

 
const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2',
      light: '#42a5f5',
      dark: '#1565c0',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#d32f2f',
      light: '#ef5350',
      dark: '#c62828',
      contrastText: '#ffffff',
    },
    background: {
      default: '#f5f5f5',
      paper: '#ffffff',
    },
    text: {
      primary: '#212121',
      secondary: '#757575',
    },
  },
  typography: {
    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontWeight: 700,
      fontSize: '2.5rem',
      '@media (min-width:600px)': {
        fontSize: '3.5rem',
      },
    },
    h2: {
      fontWeight: 700,
      fontSize: '2rem',
      '@media (min-width:600px)': {
        fontSize: '2.5rem',
      },
    },
    h3: {
      fontWeight: 600,
      fontSize: '1.5rem',
    },
    h4: {
      fontWeight: 600,
      fontSize: '1.25rem',
    },
    h5: {
      fontWeight: 600,
      fontSize: '1rem',
    },
    h6: {
      fontWeight: 600,
      fontSize: '0.875rem',
    },
    button: {
      textTransform: 'none',
      fontWeight: 600,
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          padding: '10px 24px',
        },
        containedPrimary: {
          '&:hover': {
            backgroundColor: '#1565c0',
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
        },
      },
    },
    MuiTextField: {
      defaultProps: {
        variant: 'outlined',
        fullWidth: true,
      },
    },
  },
});

export default theme;

</code>

## segfault-frontend\src\api\axios.ts
<code>
import axios from 'axios';

import { AZURE_BACKEND_URL } from '../constants';

const API_BASE_URL = AZURE_BACKEND_URL;

const api = axios.create({
    baseURL: API_BASE_URL,
    withCredentials: true,
    headers: {
        'Content-Type': 'application/json',
    },
});


api.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('authToken');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);


api.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            // Handle unauthorized - redirect to login or clear auth state
            console.log('[Axios] 401 Unauthorized on:', error.config?.url);
            console.log('[Axios] Current authToken:', localStorage.getItem('authToken')?.substring(0, 30) + '...');
            localStorage.removeItem('authToken');
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);

export default api;


export const authAPI = {
    loginWithGoogle: async (code: string) => {
        const response = await api.post('/auth/google', { code });
        return response.data;
    },

    loginAsGuest: async () => {
        const response = await api.post('/auth/guest');
        return response.data;
    },


    login: async (email: string, password: string) => {
        const response = await api.post('/auth/login', { email, password });
        return response.data;
    },

    verify2FA: async (userId: number, code: string) => {
        const response = await api.post('/auth/verify-2fa', { userId, code });
        return response.data;
    },


    register: async (email: string, password: string, name?: string) => {
        const response = await api.post('/auth/register', { email, password, name });
        return response.data;
    },

    logout: async () => {
        const response = await api.post('/auth/logout');
        localStorage.removeItem('authToken');
        return response.data;
    },
};

</code>

## segfault-frontend\src\api\routes.ts
<code>
import api from './axios';

export interface IssueFilters {
    issueType?: string;
    statusOpen?: boolean;
    statusInProgress?: boolean;
    urgency?: string;
    showResolved?: boolean;
}

export interface IssueReportData {
    type: string;
    lat?: number;
    lng?: number;
    description: string;
    isAnonymous: boolean;
    files?: File[];
}

export interface Issue {
    id: string;
    title: string;
    type: string;
    status: string;
    urgency: string;
    location: string;
    description: string;
    voteCount: number;
    reportedAt: string;
    reporterId?: string;
}

export interface Bounds {
    minLat: number;
    maxLat: number;
    minLng: number;
    maxLng: number;
}

export interface MapIssue {
    id: string;
    title: string;
    type: string;
    status: string;
    description: string;
    lat: number;
    lng: number;
    voteCount: number;
    commentCount: number;
    urgencyScore: number;
    reportedAt: string;
}

export interface IssueType {
    id: string;
    name: string;
    description: string;
    department: string;
}

export interface Comment {
    id: string;
    content: string;
    createdAt: string;
    author: {
        id: string;
        name: string;
        credibility?: number;
        badges?: string[];
    };
    upvoteCount: number;
    hasUpvoted: boolean;
    isFlagged: boolean;
}

export interface Analytics {
    totalIssues: number;
    resolvedIssues: number;
    averageResolutionTime: number;
    issuesByType: Record<string, number>;
    issuesByStatus: Record<string, number>;
    trendData: Array<{ date: string; count: number }>;
}

export interface Notification {
    id: string;
    type: string;
    message: string;
    read: boolean;
    createdAt: string;
}

export const authRoutes = {
    logout: async (): Promise<{ success: boolean }> => {
        const response = await api.post('/auth/logout');
        return response.data;
    },

    register: async (email: string, password: string, name?: string): Promise<{ ok: boolean; token: string }> => {
        const response = await api.post('/auth/register', { email, password, name });
        return response.data;
    },

    login: async (email: string, password: string): Promise<{ ok: boolean; token: string }> => {
        const response = await api.post('/auth/login', { email, password });
        return response.data;
    },

    changePassword: async (oldPassword: string, newPassword: string): Promise<{ success: boolean }> => {
        const response = await api.post('/auth/change-password', { oldPassword, newPassword });
        return response.data;
    },
};

export const issueRoutes = {
    getIssues: async (filters?: IssueFilters): Promise<Issue[]> => {
        const response = await api.get('/issues', { params: filters });
        return response.data;
    },

    getIssueById: async (id: string): Promise<Issue> => {
        const response = await api.get(`/issues/${id}`);
        return response.data;
    },

    reportIssue: async (data: IssueReportData): Promise<Issue> => {
        // If files are present, send as FormData for multer to process
        if (data.files && data.files.length > 0) {
            const formData = new FormData();
            formData.append('type', data.type);
            formData.append('description', data.description);
            formData.append('isAnonymous', String(data.isAnonymous));
            if (data.lat !== undefined) {
                formData.append('lat', String(data.lat));
            }
            if (data.lng !== undefined) {
                formData.append('lng', String(data.lng));
            }
            // Backend expects single file with field name 'file'
            formData.append('file', data.files[0]);

            const response = await api.post('/issues/report', formData, {
                headers: { 'Content-Type': 'multipart/form-data' },
            });
            return response.data;
        }

        // No files, send as JSON
        const payload = {
            type: data.type,
            description: data.description,
            isAnonymous: data.isAnonymous,
            lat: data.lat,
            lng: data.lng,
        };
        const response = await api.post('/issues/report', payload);
        return response.data;
    },

    getIssueTypes: async (): Promise<IssueType[]> => {
        const response = await api.get('/issues/types');
        return response.data;
    },

    voteOnIssue: async (id: string, location?: { lat: number; lng: number }): Promise<{ voteCount: number; hasVoted: boolean }> => {
        const response = await api.post(`/issues/${id}/vote`, {
            userLat: location?.lat,
            userLng: location?.lng,
        });
        return response.data;
    },

    validatePhoto: async (file: File): Promise<{ valid: boolean; reason?: string }> => {
        const formData = new FormData();
        formData.append('file', file);
        const response = await api.post('/issues/validate-photo', formData, {
            headers: { 'Content-Type': 'multipart/form-data' },
        });
        return response.data;
    },

    getMapIssues: async (bounds: Bounds, filters?: IssueFilters): Promise<MapIssue[]> => {
        // LocalStorage cache key based on bounds (rounded to reduce cache misses)
        const cacheKey = `map_issues_${Math.round(bounds.minLat * 100)}_${Math.round(bounds.maxLat * 100)}_${Math.round(bounds.minLng * 100)}_${Math.round(bounds.maxLng * 100)}_${filters?.showResolved || false}`;
        const cacheTTL = 5 * 60 * 1000;

        // Check localStorage cache first
        try {
            const cached = localStorage.getItem(cacheKey);
            if (cached) {
                const { data, timestamp } = JSON.parse(cached);
                if (Date.now() - timestamp < cacheTTL) {
                    console.log('[Cache] localStorage hit for map issues');
                    return data;
                }
                // Expired, remove from cache
                localStorage.removeItem(cacheKey);
            }
        } catch (e) {
            // localStorage not available or parse error, continue to API
        }

        // Fetch from API (which hits Redis -> PostgreSQL)
        const response = await api.get('/issues/map', {
            params: {
                minLat: bounds.minLat,
                maxLat: bounds.maxLat,
                minLng: bounds.minLng,
                maxLng: bounds.maxLng,
                type: filters?.issueType || undefined,
                statusOpen: filters?.statusOpen,
                statusInProgress: filters?.statusInProgress,
                urgency: filters?.urgency || undefined,
                showResolved: filters?.showResolved,
            },
        });

        // Cache in localStorage
        try {
            localStorage.setItem(cacheKey, JSON.stringify({
                data: response.data,
                timestamp: Date.now(),
            }));
            console.log('[Cache] Cached map issues in localStorage');
        } catch (e) {
            // localStorage full or not available, ignore
        }

        return response.data;
    },
};

export const commentRoutes = {
    getComments: async (issueId: string): Promise<Comment[]> => {
        const response = await api.get(`/issues/${issueId}/comments`);
        return response.data;
    },

    addComment: async (issueId: string, content: string, location?: { lat: number; lng: number }): Promise<Comment> => {
        const response = await api.post(`/issues/${issueId}/comments`, {
            content,
            userLat: location?.lat,
            userLng: location?.lng,
        });
        return response.data;
    },

    deleteComment: async (commentId: string): Promise<{ success: boolean }> => {
        const response = await api.delete(`/comments/${commentId}`);
        return response.data;
    },

    upvoteComment: async (commentId: string): Promise<{ upvoteCount: number; hasUpvoted: boolean }> => {
        const response = await api.post(`/comments/${commentId}/upvote`);
        return response.data;
    },

    flagComment: async (commentId: string, reason?: string): Promise<{ success: boolean }> => {
        const response = await api.post(`/comments/${commentId}/flag`, { reason });
        return response.data;
    },
};

export interface AnalyticsSummary {
    personalImpact: {
        issuesReported: number;
        issuesResolved: number;
        resolutionRate: number;
    } | null;
    communityHealth: {
        avgResolutionTimeHours: number;
        reopenRate: number;
        totalActiveIssues: number;
    };
    trend: Array<{ date: string; reported: number; resolved: number }>;
}

export interface HeatmapPoint {
    lat: number;
    lng: number;
    weight: number;
}

export const analyticsRoutes = {
    getSummary: async (timeRange?: string): Promise<AnalyticsSummary> => {
        const response = await api.get('/api/analytics/summary', { params: { timeRange } });
        return response.data;
    },

    getHeatmap: async (bounds: Bounds): Promise<HeatmapPoint[]> => {
        const response = await api.get('/api/analytics/heatmap', { params: bounds });
        return response.data;
    },

    exportData: async (format: 'csv' | 'json'): Promise<void> => {
        const response = await api.get('/api/analytics/export', {
            params: { format },
            responseType: 'blob',
        });

        const blob = new Blob([response.data], {
            type: format === 'csv' ? 'text/csv' : 'application/json',
        });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `my-civic-report.${format}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
    },
};

export const notificationRoutes = {
    getNotifications: async (): Promise<Notification[]> => {
        const response = await api.get('/notifications');
        return response.data;
    },

    markAsRead: async (id: string): Promise<{ success: boolean }> => {
        const response = await api.patch(`/notifications/${id}/read`);
        return response.data;
    },

    markAllAsRead: async (): Promise<{ success: boolean }> => {
        const response = await api.patch('/notifications/read-all');
        return response.data;
    },
};

export interface UserProfile {
    id: string;
    name: string | null;
    email: string;
    picture: string | null;
    role: string;
    credibility: number;
    badges: Array<{ id: number; name: string; awardedAt: string }>;
    stats: {
        issuesReported: number;
        commentsPosted: number;
        points: number;
    };
}

export interface UserIssue {
    id: string;
    title: string;
    type: string;
    status: string;
    location: string;
    lat: number;
    lng: number;
    voteCount: number;
    commentCount: number;
    reportedAt: string;
}

export interface UserComment {
    id: string;
    content: string;
    createdAt: string;
    issueId: string;
    issueTitle: string;
    upvoteCount: number;
}

export const userRoutes = {
    getMe: async (): Promise<UserProfile> => {
        const response = await api.get('/api/user/me');
        return response.data;
    },

    getMyIssues: async (): Promise<UserIssue[]> => {
        const response = await api.get('/api/user/me/issues');
        return response.data;
    },

    getMyComments: async (): Promise<UserComment[]> => {
        const response = await api.get('/api/user/me/comments');
        return response.data;
    }
};

export interface RouteResult {
    path: Array<{ lat: number; lng: number }>;
    totalDistance: number;
    estimatedTime: number;
}

export const routeRoutes = {
    findRoute: async (
        start: { lat: number; lng: number },
        end: { lat: number; lng: number }
    ): Promise<RouteResult> => {
        const response = await api.post('/api/route', { start, end });
        return response.data;
    },
};

// Admin routes
export interface ModerationItem {
    id: string;
    title: string;
    description: string;
    type: string;
    status: string;
    error: string;
    authorized: string;
    severity: number | null;
    imageBlobId: string | null;
    createdAt: string;
    reporter: { id: string; name: string; email: string };
}

export interface AdminUser {
    id: string;
    name: string;
    email: string;
    role: string;
    isBanned: boolean;
    createdAt: string;
}

export const adminRoutes = {
    getModerationQueue: async (): Promise<ModerationItem[]> => {
        const response = await api.get('/admin/moderation');
        return response.data;
    },

    resolveModeration: async (issueId: string, action: 'APPROVE' | 'REJECT'): Promise<{ success: boolean; message: string }> => {
        const response = await api.post(`/admin/moderation/${issueId}/resolve`, { action });
        return response.data;
    },

    getUsers: async (page?: number): Promise<{ users: AdminUser[]; total: number; page: number; pageSize: number }> => {
        const response = await api.get('/admin/users', { params: { page } });
        return response.data;
    },

    banUser: async (userId: string, reason?: string): Promise<{ success: boolean; message: string }> => {
        const response = await api.post(`/admin/users/${userId}/ban`, { reason });
        return response.data;
    },
};

export default {
    auth: authRoutes,
    issues: issueRoutes,
    comments: commentRoutes,
    analytics: analyticsRoutes,
    notifications: notificationRoutes,
    route: routeRoutes,
    user: userRoutes,
    admin: adminRoutes,
};

</code>

## segfault-frontend\src\assets\react.svg
<code>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</code>

## segfault-frontend\src\auth\ProtectedRoute.tsx
<code>

</code>

## segfault-frontend\src\components\atoms\Button\Button.css
<code>

</code>

## segfault-frontend\src\components\atoms\Button\Button.tsx
<code>

</code>

## segfault-frontend\src\components\Dashboard\CategoryFilterPanel.tsx
<code>
import {
    Box,
    Typography,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    FormControlLabel,
    Checkbox,
    Switch,
    Divider,
    Button,
} from '@mui/material';
import FilterListIcon from '@mui/icons-material/FilterList';
import DirectionsIcon from '@mui/icons-material/Directions';

interface FilterState {
    issueType: string;
    statusOpen: boolean;
    statusInProgress: boolean;
    urgency: string;
    showResolved: boolean;
}

interface CategoryFilterPanelProps {
    filters: FilterState;
    onFilterChange: (filters: Partial<FilterState>) => void;
    onToggleResolved: () => void;
    showRouting?: boolean;
    onToggleRouting?: () => void;
}

const ISSUE_TYPES = [
    { value: '', label: 'All Types' },
    { value: 'POTHOLE', label: 'Pothole' },
    { value: 'ROAD_DAMAGE', label: 'Road Damage' },
    { value: 'STREETLIGHT_FAULT', label: 'Streetlight Fault' },
    { value: 'GARBAGE_UNCOLLECTED', label: 'Garbage Uncollected' },
    { value: 'ILLEGAL_DUMPING', label: 'Illegal Dumping' },
    { value: 'DRAINAGE_BLOCKED', label: 'Drainage Blocked' },
    { value: 'SEWAGE_OVERFLOW', label: 'Sewage Overflow' },
    { value: 'WATER_SUPPLY_ISSUE', label: 'Water Supply' },
    { value: 'LOW_WATER_PRESSURE', label: 'Low Water Pressure' },
    { value: 'OPEN_MANHOLE', label: 'Open Manhole' },
    { value: 'BROKEN_FOOTPATH', label: 'Broken Footpath' },
    { value: 'ILLEGAL_ENCROACHMENT', label: 'Illegal Encroachment' },
    { value: 'STRAY_CATTLE', label: 'Stray Cattle' },
    { value: 'TREE_FALL', label: 'Tree Fall' },
    { value: 'TRAFFIC_LIGHT_FAULT', label: 'Traffic Light Fault' },
    { value: 'MOSQUITO_BREEDING', label: 'Mosquito Breeding' },
    { value: 'NOISE_COMPLAINT', label: 'Noise Complaint' },
    { value: 'BUILDING_SAFETY', label: 'Building Safety' },
];

const URGENCY_LEVELS = [
    { value: '', label: 'All Urgencies' },
    { value: 'LOW', label: 'Low' },
    { value: 'MEDIUM', label: 'Medium' },
    { value: 'HIGH', label: 'High' },
    { value: 'CRITICAL', label: 'Critical' },
];

const CategoryFilterPanel = ({
    filters,
    onFilterChange,
    onToggleResolved,
    showRouting,
    onToggleRouting,
}: CategoryFilterPanelProps) => {
    return (
        <Box sx={{ p: 2 }}>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <FilterListIcon sx={{ mr: 1, color: 'primary.main' }} />
                <Typography variant="h6" fontWeight={600}>
                    Filters
                </Typography>
            </Box>

            {onToggleRouting && (
                <Button
                    variant="outlined"
                    fullWidth
                    startIcon={<DirectionsIcon />}
                    onClick={onToggleRouting}
                    sx={{ mb: 3, justifyContent: 'flex-start', textTransform: 'none', borderColor: 'rgba(255,255,255,0.2)', color: 'white' }}
                >
                    Find Route
                </Button>
            )}

            <FormControl fullWidth sx={{ mb: 3 }}>
                <InputLabel id="issue-type-label">Issue Type</InputLabel>
                <Select
                    labelId="issue-type-label"
                    value={filters.issueType}
                    label="Issue Type"
                    onChange={(e) => onFilterChange({ issueType: e.target.value })}
                    sx={{
                        '& .MuiOutlinedInput-notchedOutline': {
                            borderColor: 'divider',
                        },
                    }}
                >
                    {ISSUE_TYPES.map((type) => (
                        <MenuItem key={type.value} value={type.value}>
                            {type.label}
                        </MenuItem>
                    ))}
                </Select>
            </FormControl>

            <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
                Status
            </Typography>
            <Box sx={{ mb: 2 }}>
                <FormControlLabel
                    control={
                        <Checkbox
                            checked={filters.statusOpen}
                            onChange={(e) => onFilterChange({ statusOpen: e.target.checked })}
                            color="primary"
                        />
                    }
                    label="Open"
                />
                <FormControlLabel
                    control={
                        <Checkbox
                            checked={filters.statusInProgress}
                            onChange={(e) => onFilterChange({ statusInProgress: e.target.checked })}
                            color="primary"
                        />
                    }
                    label="In Progress"
                />
            </Box>

            <FormControl fullWidth sx={{ mb: 3 }}>
                <InputLabel id="urgency-label">Urgency</InputLabel>
                <Select
                    labelId="urgency-label"
                    value={filters.urgency}
                    label="Urgency"
                    onChange={(e) => onFilterChange({ urgency: e.target.value })}
                    sx={{
                        '& .MuiOutlinedInput-notchedOutline': {
                            borderColor: 'divider',
                        },
                    }}
                >
                    {URGENCY_LEVELS.map((level) => (
                        <MenuItem key={level.value} value={level.value}>
                            {level.label}
                        </MenuItem>
                    ))}
                </Select>
            </FormControl>

            <Divider sx={{ my: 2 }} />

            <FormControlLabel
                control={
                    <Switch
                        checked={filters.showResolved}
                        onChange={onToggleResolved}
                        color="primary"
                    />
                }
                label={
                    <Typography variant="body2" fontWeight={500}>
                        Show Resolved Issues
                    </Typography>
                }
                sx={{
                    '& .MuiFormControlLabel-label': {
                        ml: 1,
                    },
                }}
            />

            {onToggleRouting && (
                <FormControlLabel
                    control={
                        <Switch
                            checked={!!showRouting}
                            onChange={onToggleRouting}
                            color="secondary"
                        />
                    }
                    label={
                        <Box sx={{ display: 'flex', alignItems: 'center' }}>
                            <Typography variant="body2" fontWeight={500}>
                                Show Routing
                            </Typography>
                        </Box>
                    }
                    sx={{
                        mt: 1,
                        '& .MuiFormControlLabel-label': {
                            ml: 1,
                        },
                    }}
                />
            )}
        </Box>
    );
};

export default CategoryFilterPanel;

</code>

## segfault-frontend\src\components\Dashboard\ChangePasswordModal.tsx
<code>
import { useState } from 'react';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    DialogActions,
    TextField,
    Button,
    Alert,
    CircularProgress,
    Box
} from '@mui/material';
import { authRoutes } from '../../api/routes';

interface ChangePasswordModalProps {
    open: boolean;
    onClose: () => void;
}

const ChangePasswordModal = ({ open, onClose }: ChangePasswordModalProps) => {
    const [oldPassword, setOldPassword] = useState('');
    const [newPassword, setNewPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [error, setError] = useState<string | null>(null);
    const [success, setSuccess] = useState(false);
    const [loading, setLoading] = useState(false);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        setSuccess(false);

        if (newPassword !== confirmPassword) {
            setError("New passwords do not match");
            return;
        }

        if (newPassword.length < 6) {
            setError("Password must be at least 6 characters");
            return;
        }

        setLoading(true);
        try {
            await authRoutes.changePassword(oldPassword, newPassword);
            setSuccess(true);
            setOldPassword('');
            setNewPassword('');
            setConfirmPassword('');
            setTimeout(() => {
                onClose();
                setSuccess(false);
            }, 1500);
        } catch (err: any) {
            setError(err.response?.data?.error || "Failed to change password");
        } finally {
            setLoading(false);
        }
    };

    return (
        <Dialog open={open} onClose={loading ? undefined : onClose} maxWidth="sm" fullWidth>
            <DialogTitle>Change Password</DialogTitle>
            <form onSubmit={handleSubmit}>
                <DialogContent>
                    {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
                    {success && <Alert severity="success" sx={{ mb: 2 }}>Password changed successfully!</Alert>}

                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        <TextField
                            label="Current Password"
                            type="password"
                            fullWidth
                            value={oldPassword}
                            onChange={(e) => setOldPassword(e.target.value)}
                            disabled={loading || success}
                            required
                        />
                        <TextField
                            label="New Password"
                            type="password"
                            fullWidth
                            value={newPassword}
                            onChange={(e) => setNewPassword(e.target.value)}
                            disabled={loading || success}
                            required
                        />
                        <TextField
                            label="Confirm New Password"
                            type="password"
                            fullWidth
                            value={confirmPassword}
                            onChange={(e) => setConfirmPassword(e.target.value)}
                            disabled={loading || success}
                            required
                        />
                    </Box>
                </DialogContent>
                <DialogActions>
                    <Button onClick={onClose} disabled={loading}>Cancel</Button>
                    <Button
                        type="submit"
                        variant="contained"
                        disabled={loading || success}
                        startIcon={loading ? <CircularProgress size={20} /> : undefined}
                    >
                        Change Password
                    </Button>
                </DialogActions>
            </form>
        </Dialog>
    );
};

export default ChangePasswordModal;

</code>

## segfault-frontend\src\components\Dashboard\DashboardLayout.tsx
<code>
import { useState } from 'react';
import {
    Box,
    AppBar,
    Toolbar,
    Typography,
    IconButton,
    Drawer,
    useMediaQuery,
    useTheme,
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import NotificationBell from './NotificationBell';
import UserMenu from './UserMenu';
import CategoryFilterPanel from './CategoryFilterPanel';

const DRAWER_WIDTH = 280;

// Move FilterState to a shared location or export it
export interface FilterState {
    issueType: string;
    statusOpen: boolean;
    statusInProgress: boolean;
    urgency: string;
    showResolved: boolean;
}

interface DashboardLayoutProps {
    children: React.ReactNode;
    onIssueClick?: (issueId: string) => void;
    filters: FilterState;
    onFilterChange: (newFilters: Partial<FilterState>) => void;
    showRouting?: boolean;
    onToggleRouting?: () => void;
}

const DashboardLayout = ({ children, onIssueClick, filters, onFilterChange, showRouting, onToggleRouting }: DashboardLayoutProps) => {
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));
    const [drawerOpen, setDrawerOpen] = useState(!isMobile);

    const handleDrawerToggle = () => {
        setDrawerOpen(!drawerOpen);
    };

    const toggleResolvedVisibility = () => {
        onFilterChange({ showResolved: !filters.showResolved });
    };

    const drawerContent = (
        <CategoryFilterPanel
            filters={filters}
            onFilterChange={onFilterChange}
            onToggleResolved={toggleResolvedVisibility}
            showRouting={showRouting}
            onToggleRouting={onToggleRouting}
        />
    );

    return (
        <Box sx={{ display: 'flex', minHeight: '100vh', bgcolor: '#020617', color: '#f8fafc', fontFamily: '"Geist Mono", "Inter", sans-serif' }}>
            {/* Grid Background Pattern */}
            <Box sx={{
                position: 'fixed',
                inset: 0,
                backgroundImage: `
          linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px)
        `,
                backgroundSize: '32px 32px',
                maskImage: 'linear-gradient(to bottom, black 40%, transparent 100%)',
                zIndex: 0,
                pointerEvents: 'none'
            }} />

            {/* Ambient Glows */}
            <Box sx={{
                position: 'fixed',
                top: '-15%',
                right: '-5%',
                width: '40vw',
                height: '40vw',
                background: 'radial-gradient(circle, rgba(124, 58, 237, 0.05) 0%, rgba(0,0,0,0) 70%)',
                filter: 'blur(80px)',
                zIndex: 0,
                pointerEvents: 'none'
            }} />

            <AppBar
                position="fixed"
                elevation={0}
                sx={{
                    zIndex: theme.zIndex.drawer + 1,
                    background: 'rgba(2, 6, 23, 0.7)',
                    backdropFilter: 'blur(12px)',
                    borderBottom: '1px solid rgba(255, 255, 255, 0.05)',
                }}
            >
                <Toolbar>
                    <IconButton
                        color="inherit"
                        aria-label="toggle drawer"
                        edge="start"
                        onClick={handleDrawerToggle}
                        sx={{ mr: 2, color: '#94a3b8' }}
                    >
                        <MenuIcon />
                    </IconButton>
                    <Typography
                        variant="h6"
                        noWrap
                        component="div"
                        sx={{
                            flexGrow: 1,
                            fontWeight: 600,
                            letterSpacing: '-0.5px',
                            fontFamily: '"Geist Mono", "Inter", sans-serif',
                            color: '#f1f5f9'
                        }}
                    >
                        Segfault<Box component="span" sx={{ color: '#64748b', fontWeight: 400 }}>IssueTracker</Box>
                    </Typography>
                    <NotificationBell />
                    <UserMenu onIssueClick={onIssueClick} />
                </Toolbar>
            </AppBar>

            <Drawer
                variant={isMobile ? 'temporary' : 'persistent'}
                open={drawerOpen}
                onClose={handleDrawerToggle}
                sx={{
                    width: drawerOpen ? DRAWER_WIDTH : 0,
                    flexShrink: 0,
                    '& .MuiDrawer-paper': {
                        width: DRAWER_WIDTH,
                        boxSizing: 'border-box',
                        borderRight: '1px solid rgba(255, 255, 255, 0.05)',
                        background: 'rgba(2, 6, 23, 0.8)',
                        backdropFilter: 'blur(12px)',
                        color: '#cbd5e1',
                    },
                }}
                ModalProps={{
                    keepMounted: true,
                }}
            >
                <Toolbar />
                <Box sx={{ p: 2 }}>
                    {drawerContent}
                </Box>
            </Drawer>

            <Box
                component="main"
                sx={{
                    flexGrow: 1,
                    p: 3,
                    width: '100%',
                    minHeight: '100vh',
                    backgroundColor: 'transparent',
                    position: 'relative',
                    zIndex: 1,
                }}
            >
                <Toolbar />
                {children}
            </Box>
        </Box>
    );
};

export default DashboardLayout;

</code>

## segfault-frontend\src\components\Dashboard\DashboardView.tsx
<code>
import { useState, useEffect } from 'react';
import { Box, Typography, ToggleButtonGroup, ToggleButton, CircularProgress, Alert } from '@mui/material';
import StatsGrid from './StatsGrid';
import TrendChart from './TrendChart';
import ExportButton from './ExportButton';
import { analyticsRoutes } from '../../api/routes';
import type { AnalyticsSummary } from '../../api/routes';

type TimeRange = '7d' | '30d' | '90d';

const DashboardView = () => {
    const [timeRange, setTimeRange] = useState<TimeRange>('30d');
    const [data, setData] = useState<AnalyticsSummary | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        const fetchData = async () => {
            setLoading(true);
            setError(null);
            try {
                const summary = await analyticsRoutes.getSummary(timeRange);
                setData(summary);
            } catch (err) {
                console.error('Failed to fetch analytics:', err);
                setError('Failed to load analytics data');
            } finally {
                setLoading(false);
            }
        };

        fetchData();
    }, [timeRange]);

    const handleTimeRangeChange = (_: React.MouseEvent<HTMLElement>, newRange: TimeRange | null) => {
        if (newRange) {
            setTimeRange(newRange);
        }
    };

    return (
        <Box sx={{ width: '100%', maxWidth: '100%', px: 2 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 4, flexWrap: 'wrap', gap: 2 }}>
                <Box>
                    <Typography variant="h4" fontWeight={700} gutterBottom sx={{ color: '#f8fafc' }}>
                        Analytics Dashboard
                    </Typography>
                    <Typography variant="body1" sx={{ color: '#94a3b8' }}>
                        Track community health and your personal impact
                    </Typography>
                </Box>
                <Box sx={{ display: 'flex', gap: 2, alignItems: 'center' }}>
                    <ToggleButtonGroup
                        value={timeRange}
                        exclusive
                        onChange={handleTimeRangeChange}
                        size="small"
                        sx={{
                            bgcolor: 'rgba(255, 255, 255, 0.03)',
                            border: '1px solid rgba(255, 255, 255, 0.05)',
                            borderRadius: 2,
                            '& .MuiToggleButton-root': {
                                color: '#94a3b8',
                                border: 'none',
                                '&.Mui-selected': {
                                    bgcolor: 'rgba(124, 58, 237, 0.2)',
                                    color: '#f8fafc',
                                    '&:hover': { bgcolor: 'rgba(124, 58, 237, 0.3)' }
                                },
                                '&:hover': { bgcolor: 'rgba(255, 255, 255, 0.05)' }
                            }
                        }}
                    >
                        <ToggleButton value="7d">Last Week</ToggleButton>
                        <ToggleButton value="30d">Last Month</ToggleButton>
                        <ToggleButton value="90d">Last 90 Days</ToggleButton>
                    </ToggleButtonGroup>
                    <ExportButton />
                </Box>
            </Box>

            {loading && (
                <Box sx={{ display: 'flex', justifyContent: 'center', py: 8 }}>
                    <CircularProgress />
                </Box>
            )}

            {error && (
                <Alert severity="error" sx={{ mb: 3 }}>
                    {error}
                </Alert>
            )}

            {!loading && !error && data && (
                <>
                    <StatsGrid
                        personalImpact={data.personalImpact}
                        communityHealth={data.communityHealth}
                    />
                    <Box sx={{ mt: 4 }}>
                        <TrendChart data={data.trend} />
                    </Box>
                </>
            )}
        </Box>
    );
};

export default DashboardView;

</code>

## segfault-frontend\src\components\Dashboard\ExportButton.tsx
<code>
import { useState } from "react";
import { Button, Menu, MenuItem, CircularProgress } from "@mui/material";
import DownloadIcon from "@mui/icons-material/Download";
import { analyticsRoutes } from "../../api/routes";

const ExportButton = () => {
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const [loading, setLoading] = useState(false);

    const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
        setAnchorEl(event.currentTarget);
    };

    const handleClose = () => {
        setAnchorEl(null);
    };

    const handleExport = async (format: "csv" | "json") => {
        handleClose();
        setLoading(true);
        try {
            await analyticsRoutes.exportData(format);
        } catch (error) {
            console.error("Export failed:", error);
        } finally {
            setLoading(false);
        }
    };

    return (
        <>
            <Button
                variant="outlined"
                startIcon={loading ? <CircularProgress size={16} /> : <DownloadIcon />}
                onClick={handleClick}
                disabled={loading}
                sx={{ textTransform: "none" }}
            >
                Export Data
            </Button>
            <Menu
                anchorEl={anchorEl}
                open={Boolean(anchorEl)}
                onClose={handleClose}
            >
                <MenuItem onClick={() => handleExport("csv")}>Download CSV</MenuItem>
                <MenuItem onClick={() => handleExport("json")}>Download JSON</MenuItem>
            </Menu>
        </>
    );
};

export default ExportButton;

</code>

## segfault-frontend\src\components\Dashboard\HeatmapLayer.tsx
<code>
import { useEffect, useRef } from "react";
import { useMap } from "react-leaflet";
import L from "leaflet";
import "leaflet.heat";

interface HeatmapPoint {
    lat: number;
    lng: number;
    weight: number;
}

interface HeatmapLayerProps {
    points: HeatmapPoint[];
    visible: boolean;
}

declare module "leaflet" {
    function heatLayer(
        latlngs: Array<[number, number, number]>,
        options?: {
            radius?: number;
            blur?: number;
            maxZoom?: number;
            max?: number;
            gradient?: Record<number, string>;
        }
    ): L.Layer;
}

const HeatmapLayer = ({ points, visible }: HeatmapLayerProps) => {
    const map = useMap();
    const heatLayerRef = useRef<L.Layer | null>(null);

    useEffect(() => {
        if (!visible) {
            if (heatLayerRef.current) {
                map.removeLayer(heatLayerRef.current);
                heatLayerRef.current = null;
            }
            return;
        }

        if (heatLayerRef.current) {
            map.removeLayer(heatLayerRef.current);
        }

        if (points.length === 0) return;

        const heatData: Array<[number, number, number]> = points.map((p) => [
            p.lat,
            p.lng,
            p.weight,
        ]);

        heatLayerRef.current = L.heatLayer(heatData, {
            radius: 25,
            blur: 15,
            maxZoom: 17,
            max: 1.0,
            gradient: {
                0.0: "#3b82f6",
                0.25: "#22c55e",
                0.5: "#f59e0b",
                0.75: "#f97316",
                1.0: "#ef4444",
            },
        });

        heatLayerRef.current.addTo(map);

        return () => {
            if (heatLayerRef.current) {
                map.removeLayer(heatLayerRef.current);
            }
        };
    }, [map, points, visible]);

    return null;
};

export default HeatmapLayer;

</code>

## segfault-frontend\src\components\Dashboard\IssueDetailPage.tsx
<code>
import { useState, useEffect } from 'react';
import {
  Drawer,
  Box,
  Typography,
  IconButton,
  Chip,
  Divider,
  Button,
  TextField,
  Avatar,
  Paper,
  CircularProgress,
  Alert,
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import ThumbUpIcon from '@mui/icons-material/ThumbUp';
import ThumbUpOutlinedIcon from '@mui/icons-material/ThumbUpOutlined';
import LocationOnIcon from '@mui/icons-material/LocationOn';
import AccessTimeIcon from '@mui/icons-material/AccessTime';
import { issueRoutes, commentRoutes, type Issue, type Comment } from '../../api/routes';
import { useAuth } from '../../state/authContext';
import UserBadge from '../Shared/UserBadge';

interface IssueDetailPageProps {
  open: boolean;
  onClose: () => void;
  issueId: string | null;
}

const IssueDetailPage = ({ open, onClose, issueId }: IssueDetailPageProps) => {
  const { isGuest } = useAuth();
  const [issue, setIssue] = useState<Issue | null>(null);
  const [comments, setComments] = useState<Comment[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasVoted, setHasVoted] = useState(false);
  const [voteCount, setVoteCount] = useState(0);
  const [newComment, setNewComment] = useState('');
  const [submittingComment, setSubmittingComment] = useState(false);

  useEffect(() => {
    if (open && issueId) {
      fetchIssueDetails();
    } else {
      setIssue(null);
      setComments([]);
      setError(null);
    }
  }, [open, issueId]);

  const fetchIssueDetails = async () => {
    if (!issueId) return;

    try {
      setLoading(true);
      setError(null);

      const [issueData, commentsData] = await Promise.all([
        issueRoutes.getIssueById(issueId),
        commentRoutes.getComments(issueId),
      ]);

      setIssue(issueData);
      setComments(commentsData);
      setVoteCount(issueData.voteCount || 0);
      setHasVoted((issueData as unknown as { hasVoted?: boolean }).hasVoted || false);
    } catch (err) {
      console.error('Failed to fetch issue details:', err);
      setError('Failed to load issue details');
    } finally {
      setLoading(false);
    }
  };

  const handleVote = async () => {
    if (!issueId || isGuest) return;

    if (!navigator.geolocation) {
      alert('Geolocation is not supported by your browser');
      return;
    }

    navigator.geolocation.getCurrentPosition(
      async (position) => {
        try {
          const result = await issueRoutes.voteOnIssue(issueId, {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          });
          setVoteCount(result.voteCount);
          setHasVoted(result.hasVoted);
        } catch (err: any) {
          const msg = err?.response?.data?.error || 'Failed to vote';
          alert(msg);
        }
      },
      (err) => {
        alert('Location access is required to verify you are an affected user.');
        console.error('Geolocation error:', err);
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );
  };

  const handleSubmitComment = async () => {
    if (!issueId || !newComment.trim() || isGuest) return;

    if (!navigator.geolocation) {
      alert('Geolocation is not supported by your browser');
      return;
    }

    navigator.geolocation.getCurrentPosition(
      async (position) => {
        try {
          setSubmittingComment(true);
          const comment = await commentRoutes.addComment(issueId, newComment.trim(), {
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          });
          setComments((prev) => [...prev, comment]);
          setNewComment('');
        } catch (err: any) {
          const msg = err?.response?.data?.error || 'Failed to submit comment';
          alert(msg);
        } finally {
          setSubmittingComment(false);
        }
      },
      (err) => {
        alert('Location access is required to verify you are an affected user.');
        console.error('Geolocation error:', err);
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );
  };

  const handleUpvoteComment = async (commentId: string) => {
    if (isGuest) return;

    try {
      const result = await commentRoutes.upvoteComment(commentId);
      setComments((prev) =>
        prev.map((c) =>
          c.id === commentId
            ? { ...c, upvoteCount: result.upvoteCount, hasUpvoted: result.hasUpvoted }
            : c
        )
      );
    } catch (err) {
      console.error('Failed to upvote comment:', err);
    }
  };

  const getStatusColor = (status: string) => {
    switch (status?.toLowerCase()) {
      case 'pending':
        return 'warning';
      case 'in_progress':
        return 'info';
      case 'resolved':
        return 'success';
      default:
        return 'default';
    }
  };

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    });
  };

  const formatTimeAgo = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffDays > 0) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
    if (diffHours > 0) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    if (diffMins > 0) return `${diffMins} min${diffMins > 1 ? 's' : ''} ago`;
    return 'Just now';
  };

  return (
    <Drawer
      anchor="right"
      open={open}
      onClose={onClose}
      PaperProps={{
        sx: {
          width: { xs: '100%', sm: 420 },
          p: 0,
        },
      }}
    >
      <Box
        sx={{
          p: 2,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          borderBottom: '1px solid',
          borderColor: 'divider',
          backgroundColor: 'primary.main',
          color: 'white',
        }}
      >
        <Typography variant="h6" fontWeight={600}>
          Issue Details
        </Typography>
        <IconButton onClick={onClose} sx={{ color: 'white' }}>
          <CloseIcon />
        </IconButton>
      </Box>

      <Box sx={{ p: 3, overflowY: 'auto', flex: 1 }}>
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
            <CircularProgress />
          </Box>
        ) : error ? (
          <Alert severity="error">{error}</Alert>
        ) : issue ? (
          <>
            <Typography variant="h5" fontWeight={700} gutterBottom>
              {issue.title}
            </Typography>

            <Box sx={{ display: 'flex', gap: 1, mb: 2, flexWrap: 'wrap' }}>
              <Chip
                label={issue.status?.replace('_', ' ')}
                color={getStatusColor(issue.status)}
                size="small"
              />
              <Chip label={issue.type} size="small" variant="outlined" />
            </Box>

            <Box sx={{ display: 'flex', alignItems: 'center', mb: 1, color: 'text.secondary' }}>
              <LocationOnIcon sx={{ fontSize: 18, mr: 0.5 }} />
              <Typography variant="body2">{issue.location}</Typography>
            </Box>

            <Box sx={{ display: 'flex', alignItems: 'center', mb: 3, color: 'text.secondary' }}>
              <AccessTimeIcon sx={{ fontSize: 18, mr: 0.5 }} />
              <Typography variant="body2">Reported on {formatDate(issue.reportedAt)}</Typography>
            </Box>

            <Typography variant="body1" sx={{ mb: 3 }}>
              {issue.description}
            </Typography>

            <Paper
              elevation={0}
              sx={{
                p: 2,
                mb: 3,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                backgroundColor: 'grey.100',
                borderRadius: 2,
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'center' }}>
                <Typography variant="h4" fontWeight={700} sx={{ mr: 1 }}>
                  {voteCount}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  people find this important
                </Typography>
              </Box>
              <Button
                variant={hasVoted ? 'contained' : 'outlined'}
                color="primary"
                startIcon={hasVoted ? <ThumbUpIcon /> : <ThumbUpOutlinedIcon />}
                onClick={handleVote}
                disabled={isGuest}
              >
                {hasVoted ? 'Voted' : 'Vote'}
              </Button>
            </Paper>

            <Divider sx={{ my: 3 }} />

            <Typography variant="h6" fontWeight={600} gutterBottom>
              Comments ({comments.length})
            </Typography>

            {comments.length === 0 ? (
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                No comments yet. Be the first to comment!
              </Typography>
            ) : (
              comments.map((comment) => (
                <Box key={comment.id} sx={{ display: 'flex', gap: 2, mb: 2 }}>
                  <Avatar sx={{ width: 32, height: 32, fontSize: 14 }}>
                    {comment.author.name[0]}
                  </Avatar>
                  <Box sx={{ flex: 1 }}>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5, flexWrap: 'wrap' }}>
                      <Typography variant="body2" fontWeight={600}>
                        {comment.author.name}
                      </Typography>
                      {comment.author.credibility !== undefined && (
                        <UserBadge
                          score={comment.author.credibility}
                          badges={comment.author.badges || []}
                          compact
                        />
                      )}
                      <Typography variant="caption" color="text.secondary">
                        {formatTimeAgo(comment.createdAt)}
                      </Typography>
                    </Box>
                    <Typography variant="body2" sx={{ mb: 0.5 }}>
                      {comment.content}
                    </Typography>
                    <Button
                      size="small"
                      startIcon={
                        comment.hasUpvoted ? (
                          <ThumbUpIcon fontSize="small" />
                        ) : (
                          <ThumbUpOutlinedIcon fontSize="small" />
                        )
                      }
                      onClick={() => handleUpvoteComment(comment.id)}
                      disabled={isGuest}
                      sx={{ minWidth: 'auto', p: 0.5 }}
                    >
                      {comment.upvoteCount}
                    </Button>
                  </Box>
                </Box>
              ))
            )}

            <Box sx={{ mt: 3 }}>
              {isGuest ? (
                <Alert severity="info" sx={{ mb: 2 }}>
                  Sign in to comment and vote
                </Alert>
              ) : (
                <>
                  <TextField
                    placeholder="Add a comment..."
                    value={newComment}
                    onChange={(e) => setNewComment(e.target.value)}
                    fullWidth
                    multiline
                    rows={2}
                    sx={{ mb: 1 }}
                  />
                  <Button
                    variant="contained"
                    size="small"
                    disabled={!newComment.trim() || submittingComment}
                    onClick={handleSubmitComment}
                  >
                    {submittingComment ? 'Posting...' : 'Post Comment'}
                  </Button>
                </>
              )}
            </Box>
          </>
        ) : (
          <Typography variant="body2" color="text.secondary">
            Select an issue to view details
          </Typography>
        )}
      </Box>
    </Drawer>
  );
};

export default IssueDetailPage;

</code>

## segfault-frontend\src\components\Dashboard\IssueReportForm.tsx
<code>
import { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  FormControlLabel,
  Switch,
  Box,
  Typography,
  IconButton,
  Stepper,
  Step,
  StepLabel,
  CircularProgress,
  Alert,
  InputAdornment,
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import MyLocationIcon from '@mui/icons-material/MyLocation';
import PhotoUploader from './PhotoUploader';
import LocationPicker from '../Map/LocationPicker';
import { issueRoutes, type IssueType } from '../../api/routes';

interface IssueReportFormProps {
  open: boolean;
  onClose: () => void;
}

interface FormData {
  type: string;
  lat: number | null;
  lng: number | null;
  address: string;
  description: string;
  anonymous: boolean;
  photos: File[];
}

const STEPS = ['Issue Details', 'Location & Photos', 'Review & Submit'];

const IssueReportForm = ({ open, onClose }: IssueReportFormProps) => {
  const [activeStep, setActiveStep] = useState(0);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitSuccess, setSubmitSuccess] = useState(false);
  const [submitError, setSubmitError] = useState<string | null>(null);
  const [locationLoading, setLocationLoading] = useState(false);
  const [issueTypes, setIssueTypes] = useState<IssueType[]>([]);
  const [typesLoading, setTypesLoading] = useState(false);
  const [formData, setFormData] = useState<FormData>({
    type: '',
    lat: null,
    lng: null,
    address: '',
    description: '',
    anonymous: false,
    photos: [],
  });

  useEffect(() => {
    const fetchIssueTypes = async () => {
      try {
        setTypesLoading(true);
        const types = await issueRoutes.getIssueTypes();
        setIssueTypes(types);
      } catch (error) {
        console.error('Failed to fetch issue types:', error);
      } finally {
        setTypesLoading(false);
      }
    };

    if (open) {
      fetchIssueTypes();
    }
  }, [open]);

  useEffect(() => {
    if (!open) {
      setActiveStep(0);
      setSubmitSuccess(false);
      setSubmitError(null);
      setFormData({
        type: '',
        lat: null,
        lng: null,
        address: '',
        description: '',
        anonymous: false,
        photos: [],
      });
    }
  }, [open]);

  const selectedType = issueTypes.find((t) => t.id === formData.type);

  const handleNext = () => {
    setActiveStep((prev) => prev + 1);
  };

  const handleBack = () => {
    setActiveStep((prev) => prev - 1);
  };

  const handleUseMyLocation = () => {
    if (!navigator.geolocation) {
      setSubmitError('Geolocation is not supported by your browser');
      return;
    }

    setLocationLoading(true);
    navigator.geolocation.getCurrentPosition(
      (position) => {
        setFormData((prev) => ({
          ...prev,
          lat: position.coords.latitude,
          lng: position.coords.longitude,
        }));
        setLocationLoading(false);
      },
      (error) => {
        setSubmitError(`Location error: ${error.message}`);
        setLocationLoading(false);
      },
      { enableHighAccuracy: true, timeout: 10000 }
    );
  };

  const submitIssue = async () => {
    setIsSubmitting(true);
    setSubmitError(null);

    try {
      const submitData = {
        type: formData.type,
        description: formData.description,
        isAnonymous: formData.anonymous,
        lat: formData.lat ?? undefined,
        lng: formData.lng ?? undefined,
        files: formData.photos,
      };

      await issueRoutes.reportIssue(submitData);
      setSubmitSuccess(true);
      setTimeout(() => {
        onClose();
      }, 2000);
    } catch (error) {
      setSubmitError('Failed to submit issue. Please try again.');
    } finally {
      setIsSubmitting(false);
    }
  };

  const isStepValid = (step: number): boolean => {
    switch (step) {
      case 0:
        return Boolean(formData.type && formData.description.trim());
      case 1:
        return Boolean(formData.lat || formData.address.trim());
      case 2:
        return true;
      default:
        return false;
    }
  };

  const renderStepContent = (step: number) => {
    switch (step) {
      case 0:
        return (
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
            <FormControl fullWidth>
              <InputLabel id="issue-type-label">Issue Type</InputLabel>
              <Select
                labelId="issue-type-label"
                value={formData.type}
                label="Issue Type"
                onChange={(e) => setFormData((prev) => ({ ...prev, type: e.target.value }))}
                disabled={typesLoading}
              >
                {typesLoading ? (
                  <MenuItem disabled>Loading...</MenuItem>
                ) : (
                  issueTypes.map((type) => (
                    <MenuItem key={type.id} value={type.id}>
                      {type.name}
                    </MenuItem>
                  ))
                )}
              </Select>
              {selectedType && (
                <Typography variant="caption" color="primary" sx={{ mt: 1 }}>
                  Associated Department: {selectedType.department}
                </Typography>
              )}
            </FormControl>

            <TextField
              label="Description"
              placeholder="Describe the issue in detail..."
              value={formData.description}
              onChange={(e) => setFormData((prev) => ({ ...prev, description: e.target.value }))}
              multiline
              rows={4}
              fullWidth
            />
          </Box>
        );

      case 1:
        return (
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
            <Box>
              <TextField
                label="Coordinates"
                value={formData.lat && formData.lng ? `${formData.lat.toFixed(6)}, ${formData.lng.toFixed(6)}` : ''}
                placeholder="Click button or use map to set location"
                fullWidth
                InputProps={{
                  readOnly: true,
                  endAdornment: (
                    <InputAdornment position="end">
                      <Button
                        variant="contained"
                        size="small"
                        startIcon={locationLoading ? <CircularProgress size={16} color="inherit" /> : <MyLocationIcon />}
                        onClick={handleUseMyLocation}
                        disabled={locationLoading}
                        sx={{ whiteSpace: 'nowrap' }}
                      >
                        {locationLoading ? 'Getting...' : 'Use My Location'}
                      </Button>
                    </InputAdornment>
                  ),
                }}
              />
            </Box>

            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>
                Or select on map
              </Typography>
              <LocationPicker
                lat={formData.lat}
                lng={formData.lng}
                onChange={(lat, lng) => setFormData((prev) => ({ ...prev, lat, lng }))}
              />
            </Box>

            <TextField
              label="Address Description"
              placeholder="e.g., Near the bus stop on Main Street"
              value={formData.address}
              onChange={(e) => setFormData((prev) => ({ ...prev, address: e.target.value }))}
              fullWidth
              helperText="Provide a description to help locate the issue"
            />

            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>
                Photos (Optional)
              </Typography>
              <PhotoUploader
                photos={formData.photos}
                onPhotosChange={(photos) => setFormData((prev) => ({ ...prev, photos }))}
                maxFiles={2}
              />
            </Box>
          </Box>
        );

      case 2:
        return (
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
            <Typography variant="h6" gutterBottom>
              Review Your Report
            </Typography>

            <Box sx={{ backgroundColor: 'grey.50', p: 2, borderRadius: 2 }}>
              <Typography variant="subtitle2" color="text.secondary">
                Issue Type
              </Typography>
              <Typography variant="body1" sx={{ mb: 2 }}>
                {selectedType?.name || '-'}
              </Typography>

              <Typography variant="subtitle2" color="text.secondary">
                Description
              </Typography>
              <Typography variant="body1" sx={{ mb: 2 }}>
                {formData.description || '-'}
              </Typography>

              <Typography variant="subtitle2" color="text.secondary">
                Location
              </Typography>
              <Typography variant="body1" sx={{ mb: 2 }}>
                {formData.lat && formData.lng
                  ? `${formData.lat.toFixed(6)}, ${formData.lng.toFixed(6)}`
                  : formData.address || '-'}
              </Typography>

              <Typography variant="subtitle2" color="text.secondary">
                Photos
              </Typography>
              <Typography variant="body1">
                {formData.photos.length} photo(s) attached
              </Typography>
            </Box>

            <FormControlLabel
              control={
                <Switch
                  checked={formData.anonymous}
                  onChange={(e) => setFormData((prev) => ({ ...prev, anonymous: e.target.checked }))}
                  color="primary"
                />
              }
              label={
                <Box>
                  <Typography variant="body1" fontWeight={500}>
                    Report Anonymously
                  </Typography>
                  <Typography variant="caption" color="text.secondary">
                    Your identity will not be associated with this report
                  </Typography>
                </Box>
              }
            />

            {submitSuccess && (
              <Alert severity="success">
                Issue reported successfully! Closing...
              </Alert>
            )}

            {submitError && (
              <Alert severity="error" onClose={() => setSubmitError(null)}>
                {submitError}
              </Alert>
            )}
          </Box>
        );

      default:
        return null;
    }
  };

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="sm"
      fullWidth
      PaperProps={{ sx: { borderRadius: 3 } }}
    >
      <DialogTitle sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', pb: 1 }}>
        <Typography variant="h5" fontWeight={700}>
          Report an Issue
        </Typography>
        <IconButton onClick={onClose} size="small">
          <CloseIcon />
        </IconButton>
      </DialogTitle>

      <Box sx={{ px: 3, pb: 2 }}>
        <Stepper activeStep={activeStep} alternativeLabel>
          {STEPS.map((label) => (
            <Step key={label}>
              <StepLabel>{label}</StepLabel>
            </Step>
          ))}
        </Stepper>
      </Box>

      <DialogContent dividers sx={{ minHeight: 300 }}>
        {renderStepContent(activeStep)}
      </DialogContent>

      <DialogActions sx={{ p: 2.5 }}>
        <Button onClick={onClose} color="inherit" disabled={isSubmitting}>
          Cancel
        </Button>
        <Box sx={{ flex: 1 }} />
        {activeStep > 0 && (
          <Button onClick={handleBack} disabled={isSubmitting}>
            Back
          </Button>
        )}
        {activeStep < STEPS.length - 1 ? (
          <Button
            variant="contained"
            onClick={handleNext}
            disabled={!isStepValid(activeStep)}
          >
            Next
          </Button>
        ) : (
          <Button
            variant="contained"
            onClick={submitIssue}
            disabled={isSubmitting || submitSuccess}
            startIcon={isSubmitting ? <CircularProgress size={20} color="inherit" /> : null}
          >
            {isSubmitting ? 'Submitting...' : 'Submit Report'}
          </Button>
        )}
      </DialogActions>
    </Dialog>
  );
};

export default IssueReportForm;

</code>

## segfault-frontend\src\components\Dashboard\IssuesList.tsx
<code>
import { useState, useEffect } from 'react';
import {
    Box,
    Card,
    CardContent,
    Typography,
    Chip,
    IconButton,
    FormControl,
    InputLabel,
    Select,
    MenuItem,
    TextField,
    InputAdornment,
    CircularProgress,
    Alert,
    Tooltip,
} from '@mui/material';
import ThumbUpOutlinedIcon from '@mui/icons-material/ThumbUpOutlined';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import LocationOnIcon from '@mui/icons-material/LocationOn';
import AccessTimeIcon from '@mui/icons-material/AccessTime';
import SearchIcon from '@mui/icons-material/Search';
import SortIcon from '@mui/icons-material/Sort';
import { issueRoutes, type Issue } from '../../api/routes';
import { useAuth } from '../../state/authContext';
import { AZURE_BACKEND_URL } from '../../constants';

interface IssuesListProps {
    onIssueClick?: (issueId: string) => void;
}

const ISSUE_TYPES = [
    'POTHOLE', 'ROAD_DAMAGE', 'STREETLIGHT_FAULT', 'GARBAGE_UNCOLLECTED',
    'ILLEGAL_DUMPING', 'DRAINAGE_BLOCKED', 'SEWAGE_OVERFLOW', 'WATER_SUPPLY_ISSUE',
    'LOW_WATER_PRESSURE', 'OPEN_MANHOLE', 'BROKEN_FOOTPATH', 'ILLEGAL_ENCROACHMENT',
    'STRAY_CATTLE', 'TREE_FALL', 'TRAFFIC_LIGHT_FAULT', 'MOSQUITO_BREEDING',
    'NOISE_COMPLAINT', 'BUILDING_SAFETY',
];

const IssuesList = ({ onIssueClick }: IssuesListProps) => {
    const { user, isGuest } = useAuth();
    const isGov = user?.isGov || false;

    const [issues, setIssues] = useState<Issue[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    // Filters
    const [typeFilter, setTypeFilter] = useState('');
    const [statusFilter, setStatusFilter] = useState('');
    const [searchQuery, setSearchQuery] = useState('');
    const [sortBy, setSortBy] = useState<'votes' | 'date' | 'location'>('date');
    const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');

    useEffect(() => {
        fetchIssues();
    }, [typeFilter, statusFilter]);

    const fetchIssues = async () => {
        try {
            setLoading(true);
            setError(null);
            const filters: Record<string, string> = {};
            if (typeFilter) filters.type = typeFilter;
            if (statusFilter) filters.status = statusFilter;
            const data = await issueRoutes.getIssues(filters);
            setIssues(data);
        } catch (err) {
            console.error('Failed to fetch issues:', err);
            setError('Failed to load issues');
        } finally {
            setLoading(false);
        }
    };

    const handleVote = async (issueId: string, e: React.MouseEvent) => {
        e.stopPropagation();
        if (isGuest) return;

        // Get user's location for geofencing
        if (!navigator.geolocation) {
            alert('Geolocation is not supported by your browser');
            return;
        }

        navigator.geolocation.getCurrentPosition(
            async (position) => {
                try {
                    const result = await issueRoutes.voteOnIssue(issueId, {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                    });
                    setIssues(prev => prev.map(issue =>
                        issue.id === issueId
                            ? { ...issue, voteCount: result.voteCount }
                            : issue
                    ));
                } catch (err: any) {
                    const msg = err?.response?.data?.error || 'Failed to vote';
                    alert(msg);
                }
            },
            (err) => {
                alert('Location access is required to verify you are an affected user. Please enable it and try again.');
                console.error('Geolocation error:', err);
            },
            { enableHighAccuracy: true, timeout: 10000 }
        );
    };

    const handleMarkResolved = async (issueId: string, e: React.MouseEvent) => {
        e.stopPropagation();
        if (!isGov) return;
        try {
            await fetch(`${AZURE_BACKEND_URL}/issues/${issueId}/status`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
                },
                body: JSON.stringify({ status: 'RESOLVED' }),
                credentials: 'include',
            });
            fetchIssues();
        } catch (err) {
            console.error('Failed to mark resolved:', err);
        }
    };

    const getStatusColor = (status: string) => {
        switch (status?.toLowerCase()) {
            case 'pending': return 'warning';
            case 'in_progress': return 'info';
            case 'resolved': return 'success';
            default: return 'default';
        }
    };

    const formatDate = (dateString: string) => {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
        if (diffDays === 0) return 'Today';
        if (diffDays === 1) return 'Yesterday';
        if (diffDays < 7) return `${diffDays} days ago`;
        return date.toLocaleDateString();
    };

    const filteredAndSortedIssues = issues
        .filter(issue => {
            if (searchQuery) {
                const query = searchQuery.toLowerCase();
                return (
                    issue.title.toLowerCase().includes(query) ||
                    issue.description?.toLowerCase().includes(query) ||
                    issue.location?.toLowerCase().includes(query)
                );
            }
            return true;
        })
        .sort((a, b) => {
            let comparison = 0;
            if (sortBy === 'votes') {
                comparison = (b.voteCount || 0) - (a.voteCount || 0);
            } else if (sortBy === 'date') {
                comparison = new Date(b.reportedAt).getTime() - new Date(a.reportedAt).getTime();
            }
            return sortOrder === 'asc' ? -comparison : comparison;
        });

    return (
        <Box sx={{ height: '100%', display: 'flex', flexDirection: 'column', p: 2 }}>
            {/* Filters Bar */}
            <Box sx={{ display: 'flex', gap: 2, mb: 3, flexWrap: 'wrap', alignItems: 'center' }}>
                <TextField
                    size="small"
                    placeholder="Search issues..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    InputProps={{
                        startAdornment: (
                            <InputAdornment position="start">
                                <SearchIcon />
                            </InputAdornment>
                        ),
                    }}
                    sx={{ minWidth: 200, flex: 1 }}
                />
                <FormControl size="small" sx={{ minWidth: 140 }}>
                    <InputLabel>Type</InputLabel>
                    <Select value={typeFilter} onChange={(e) => setTypeFilter(e.target.value)} label="Type">
                        <MenuItem value="">All Types</MenuItem>
                        {ISSUE_TYPES.map(type => (
                            <MenuItem key={type} value={type}>{type.replace(/_/g, ' ')}</MenuItem>
                        ))}
                    </Select>
                </FormControl>
                <FormControl size="small" sx={{ minWidth: 120 }}>
                    <InputLabel>Status</InputLabel>
                    <Select value={statusFilter} onChange={(e) => setStatusFilter(e.target.value)} label="Status">
                        <MenuItem value="">All</MenuItem>
                        <MenuItem value="PENDING">Pending</MenuItem>
                        <MenuItem value="IN_PROGRESS">In Progress</MenuItem>
                    </Select>
                </FormControl>
                <FormControl size="small" sx={{ minWidth: 100 }}>
                    <InputLabel>Sort</InputLabel>
                    <Select value={sortBy} onChange={(e) => setSortBy(e.target.value as any)} label="Sort">
                        <MenuItem value="date">Date</MenuItem>
                        <MenuItem value="votes">Votes</MenuItem>
                    </Select>
                </FormControl>
                <IconButton onClick={() => setSortOrder(o => o === 'asc' ? 'desc' : 'asc')} size="small">
                    <SortIcon sx={{ transform: sortOrder === 'asc' ? 'scaleY(-1)' : 'none' }} />
                </IconButton>
            </Box>

            {/* Gov Badge */}
            {isGov && (
                <Alert severity="info" sx={{ mb: 2 }}>
                    <strong>Government Official Mode:</strong> You can mark issues as resolved directly.
                </Alert>
            )}

            {/* Issues List */}
            <Box sx={{ flex: 1, overflowY: 'auto' }}>
                {loading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', py: 4 }}>
                        <CircularProgress />
                    </Box>
                ) : error ? (
                    <Alert severity="error">{error}</Alert>
                ) : filteredAndSortedIssues.length === 0 ? (
                    <Typography color="text.secondary" textAlign="center" py={4}>
                        No issues found
                    </Typography>
                ) : (
                    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                        {filteredAndSortedIssues.map((issue) => (
                            <Card
                                key={issue.id}
                                elevation={0}
                                onClick={() => onIssueClick?.(issue.id)}
                                sx={{
                                    cursor: 'pointer',
                                    transition: 'all 0.2s ease',
                                    bgcolor: 'rgba(255, 255, 255, 0.03)',
                                    border: '1px solid rgba(255, 255, 255, 0.05)',
                                    backdropFilter: 'blur(10px)',
                                    borderRadius: 2,
                                    '&:hover': {
                                        transform: 'translateY(-2px)',
                                        bgcolor: 'rgba(255, 255, 255, 0.05)',
                                        borderColor: 'rgba(124, 58, 237, 0.3)',
                                        boxShadow: '0 4px 20px rgba(0,0,0,0.2)',
                                    },
                                }}
                            >
                                <CardContent sx={{ p: 2, '&:last-child': { pb: 2 } }}>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 1 }}>
                                        <Box sx={{ flex: 1 }}>
                                            <Typography variant="h6" fontWeight={600} sx={{ mb: 0.5, color: '#f1f5f9', fontSize: '1rem' }}>
                                                {issue.title}
                                            </Typography>
                                            <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap', mb: 1 }}>
                                                <Chip
                                                    label={issue.status?.replace('_', ' ')}
                                                    size="small"
                                                    color={getStatusColor(issue.status) as any}
                                                    sx={{ height: 20, fontSize: '0.7rem' }}
                                                />
                                                <Chip
                                                    label={issue.type?.replace(/_/g, ' ')}
                                                    size="small"
                                                    variant="outlined"
                                                    sx={{
                                                        height: 20,
                                                        fontSize: '0.7rem',
                                                        color: '#94a3b8',
                                                        borderColor: 'rgba(255,255,255,0.1)'
                                                    }}
                                                />
                                            </Box>
                                        </Box>
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                            {isGov ? (
                                                <Tooltip title="Mark as Resolved">
                                                    <IconButton
                                                        size="small"
                                                        onClick={(e) => handleMarkResolved(issue.id, e)}
                                                        disabled={issue.status === 'RESOLVED'}
                                                        sx={{ color: '#22c55e' }}
                                                    >
                                                        <CheckCircleIcon />
                                                    </IconButton>
                                                </Tooltip>
                                            ) : (
                                                <Tooltip title={isGuest ? 'Sign in to vote' : 'Upvote'}>
                                                    <IconButton
                                                        size="small"
                                                        onClick={(e) => handleVote(issue.id, e)}
                                                        disabled={isGuest}
                                                        sx={{ color: '#a78bfa' }}
                                                    >
                                                        <ThumbUpOutlinedIcon />
                                                    </IconButton>
                                                </Tooltip>
                                            )}
                                            <Typography variant="body2" fontWeight={700} sx={{ color: '#a78bfa' }}>
                                                {issue.voteCount || 0}
                                            </Typography>
                                        </Box>
                                    </Box>
                                    <Typography variant="body2" sx={{ mb: 1.5, color: '#94a3b8' }} noWrap>
                                        {issue.description}
                                    </Typography>
                                    <Box sx={{ display: 'flex', gap: 2, color: '#64748b' }}>
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                            <LocationOnIcon sx={{ fontSize: 14 }} />
                                            <Typography variant="caption">{issue.location || 'Unknown'}</Typography>
                                        </Box>
                                        <Box sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                                            <AccessTimeIcon sx={{ fontSize: 14 }} />
                                            <Typography variant="caption">{formatDate(issue.reportedAt)}</Typography>
                                        </Box>
                                    </Box>
                                </CardContent>
                            </Card>
                        ))}
                    </Box>
                )}
            </Box>
        </Box>
    );
};

export default IssuesList;

</code>

## segfault-frontend\src\components\Dashboard\MapInterface.tsx
<code>
import { useState, useEffect, useCallback, useRef } from "react";
import { MapContainer, TileLayer, useMapEvents } from "react-leaflet";
import MarkerClusterGroup from "react-leaflet-cluster";
import {
    Box,
    Paper,
    ToggleButtonGroup,
    ToggleButton,
    Fab,
    CircularProgress,
    Typography,
    Tooltip,
} from "@mui/material";
import MyLocationIcon from "@mui/icons-material/MyLocation";
import DirectionsIcon from "@mui/icons-material/Directions";
import MapEvents, { type Bounds } from "../Map/MapEvents";
import IssueMarker, { type VisualizationMode } from "../Map/IssueMarker";
import { createClusterIcon } from "../Map/markerIcons";
import RouteRenderer from "../Routing/RouteRenderer";
import { issueRoutes, routeRoutes, type MapIssue, type RouteResult } from "../../api/routes";

// Leaflet CSS imports
import "leaflet/dist/leaflet.css";
import "leaflet-defaulticon-compatibility/dist/leaflet-defaulticon-compatibility.css";
import "leaflet-defaulticon-compatibility";

import type { FilterState } from "./DashboardLayout";

interface MapInterfaceProps {
    onPinClick: (issueId: string) => void;
    filters?: FilterState;
    showRouting?: boolean;
    onToggleRouting?: (show: boolean) => void;
}

// Default center (Delhi, India - can be changed to any default location)
const DEFAULT_CENTER: [number, number] = [28.6139, 77.209];
const DEFAULT_ZOOM = 13;

// Component to handle map click for route selection
const RoutePointSelector = ({
    onPointSelect,
    isActive,
}: {
    onPointSelect: (lat: number, lng: number) => void;
    isActive: boolean;
}) => {
    useMapEvents({
        click: (e) => {
            if (isActive) {
                onPointSelect(e.latlng.lat, e.latlng.lng);
            }
        },
    });
    return null;
};

const MapInterface = ({ onPinClick, filters, showRouting: propShowRouting, onToggleRouting }: MapInterfaceProps) => {
    const [issues, setIssues] = useState<MapIssue[]>([]);
    const [viewMode, setViewMode] = useState<VisualizationMode>("status");
    const [userLocation, setUserLocation] = useState<[number, number] | null>(null);
    const [loading, setLoading] = useState(false);
    const [mapReady, setMapReady] = useState(false);
    const mapRef = useRef<L.Map | null>(null);
    const boundsRef = useRef<Bounds | null>(null);

    // Routing state
    // Use prop if available, otherwise local state (though we are moving to controlled)
    const [localShowRouting, setLocalShowRouting] = useState(false);

    // Effective state
    const showRouting = propShowRouting !== undefined ? propShowRouting : localShowRouting;

    const handleToggleRouting = (show: boolean) => {
        if (onToggleRouting) {
            onToggleRouting(show);
        } else {
            setLocalShowRouting(show);
        }
    };
    const [routeLoading, setRouteLoading] = useState(false);
    const [routeResult, setRouteResult] = useState<RouteResult | null>(null);
    const [selectingPoint, setSelectingPoint] = useState<"start" | "end" | null>(null);
    const [routeStart, setRouteStart] = useState<{ lat: number; lng: number } | null>(null);
    const [routeEnd, setRouteEnd] = useState<{ lat: number; lng: number } | null>(null);

    // Get user location on mount
    useEffect(() => {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    setUserLocation([position.coords.latitude, position.coords.longitude]);
                },
                (error) => {
                    console.warn("Geolocation error:", error.message);
                },
                { enableHighAccuracy: true, timeout: 10000 }
            );
        }
    }, []);

    // Fetch issues when bounds change
    const fetchIssues = useCallback(async (bounds: Bounds) => {
        boundsRef.current = bounds;
        setLoading(true);
        try {
            const issuesFilters = filters ? {
                issueType: filters.issueType || undefined,
                statusOpen: filters.statusOpen,
                statusInProgress: filters.statusInProgress,
                urgency: filters.urgency || undefined,
                showResolved: filters.showResolved
            } : undefined;

            const data = await issueRoutes.getMapIssues(bounds, issuesFilters);
            setIssues(data);
        } catch (error) {
            console.error("Failed to fetch map issues:", error);
        } finally {
            setLoading(false);
        }
    }, [filters]);

    const handleBoundsChange = useCallback(
        (bounds: Bounds) => {
            fetchIssues(bounds);
        },
        [fetchIssues]
    );

    // Refetch when filters change (using current bounds)
    useEffect(() => {
        if (boundsRef.current) {
            fetchIssues(boundsRef.current);
        }
    }, [filters, fetchIssues]);

    const handleViewModeChange = (
        _event: React.MouseEvent<HTMLElement>,
        newMode: VisualizationMode | null
    ) => {
        if (newMode) {
            setViewMode(newMode);
        }
    };

    const handleRecenter = () => {
        const targetLocation = userLocation || DEFAULT_CENTER;
        if (mapRef.current) {
            mapRef.current.setView(targetLocation, DEFAULT_ZOOM);
        }
    };

    // Routing handlers
    const handleFindRoute = async (
        start: { lat: number; lng: number },
        end: { lat: number; lng: number }
    ) => {
        setRouteLoading(true);
        setRouteResult(null);
        try {
            const result = await routeRoutes.findRoute(start, end);
            setRouteResult(result);
        } catch (error) {
            console.error("Failed to find route:", error);
            alert("Could not find a route. Make sure the graph data is loaded for this area.");
        } finally {
            setRouteLoading(false);
        }
    };

    const handleCloseRouting = () => {
        handleToggleRouting(false);
        setRouteResult(null);
        setSelectingPoint(null);
        setRouteStart(null);
        setRouteEnd(null);
    };

    const handlePointSelect = (lat: number, lng: number) => {
        if (selectingPoint === "start") {
            setRouteStart({ lat, lng });
        } else if (selectingPoint === "end") {
            setRouteEnd({ lat, lng });
        }
        setSelectingPoint(null);
    };

    const initialCenter = userLocation || DEFAULT_CENTER;

    return (
        <Paper
            elevation={0}
            sx={{
                height: "calc(100vh - 200px)",
                minHeight: 400,
                position: "relative",
                borderRadius: 3,
                overflow: "hidden",
                border: '1px solid rgba(255, 255, 255, 0.05)',
                bgcolor: '#0f172a', // Slate 900 base for map container
            }}
        >
            <MapContainer
                center={initialCenter}
                zoom={DEFAULT_ZOOM}
                style={{ height: "100%", width: "100%", cursor: selectingPoint ? "crosshair" : undefined, background: '#0f172a' }}
                ref={(map) => {
                    if (map) {
                        mapRef.current = map;
                        if (!mapReady) {
                            setMapReady(true);
                        }
                    }
                }}
                scrollWheelZoom={true}
            >
                <TileLayer
                    attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                />

                <MapEvents onBoundsChange={handleBoundsChange} />
                <RoutePointSelector onPointSelect={handlePointSelect} isActive={selectingPoint !== null} />

                <MarkerClusterGroup
                    chunkedLoading
                    iconCreateFunction={createClusterIcon}
                    maxClusterRadius={50}
                    spiderfyOnMaxZoom={true}
                    showCoverageOnHover={false}
                >
                    {issues.map((issue) => (
                        <IssueMarker
                            key={issue.id}
                            issue={issue}
                            visualizationMode={viewMode}
                            onClick={onPinClick}
                        />
                    ))}
                </MarkerClusterGroup>

                {/* Render route if available */}
                {routeResult && <RouteRenderer path={routeResult.path} />}
            </MapContainer>

            {/* Loading indicator */}
            {loading && (
                <Box
                    sx={{
                        position: "absolute",
                        top: 16,
                        left: "50%",
                        transform: "translateX(-50%)",
                        zIndex: 1000,
                        backgroundColor: "rgba(255,255,255,0.9)",
                        borderRadius: 2,
                        px: 2,
                        py: 1,
                        display: "flex",
                        alignItems: "center",
                        gap: 1,
                        boxShadow: 2,
                    }}
                >
                    <CircularProgress size={16} />
                    <Typography variant="body2">Loading issues...</Typography>
                </Box>
            )}

            {/* Routing Panel */}
            {showRouting && (
                <RouteInputWrapper
                    onFindRoute={handleFindRoute}
                    onClose={handleCloseRouting}
                    isLoading={routeLoading}
                    selectingPoint={selectingPoint}
                    onSelectPoint={setSelectingPoint}
                    start={routeStart}
                    end={routeEnd}
                />
            )}

            {/* Route Info */}
            {routeResult && (
                <Box
                    sx={{
                        position: "absolute",
                        bottom: 80,
                        left: 16,
                        zIndex: 1000,
                        backgroundColor: "rgba(255,255,255,0.95)",
                        borderRadius: 2,
                        px: 2,
                        py: 1.5,
                        boxShadow: 3,
                    }}
                >
                    <Typography variant="subtitle2" fontWeight={600}>
                        Route Found
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                        Distance: {(routeResult.totalDistance / 1000).toFixed(1)} km
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                        Est. Time: {routeResult.estimatedTime} min
                    </Typography>
                </Box>
            )}

            {/* Visualization Mode Toggle - Top Right */}
            <Box
                sx={{
                    position: "absolute",
                    top: 16,
                    right: 16,
                    zIndex: 1000,
                }}
            >
                <Paper elevation={3} sx={{ borderRadius: 2 }}>
                    <ToggleButtonGroup
                        value={viewMode}
                        exclusive
                        onChange={handleViewModeChange}
                        size="small"
                        sx={{
                            "& .MuiToggleButton-root": {
                                px: 2,
                                py: 1,
                                textTransform: "none",
                            },
                        }}
                    >
                        <ToggleButton value="status">Status</ToggleButton>
                        <ToggleButton value="urgency">Urgency</ToggleButton>
                    </ToggleButtonGroup>
                </Paper>
            </Box>

            {/* Issue count badge - only show when routing is not active */}
            {!showRouting && (
                <Box
                    sx={{
                        position: "absolute",
                        top: 16,
                        left: 16,
                        zIndex: 1000,
                        backgroundColor: "rgba(255,255,255,0.95)",
                        borderRadius: 2,
                        px: 2,
                        py: 1,
                        boxShadow: 2,
                    }}
                >
                    <Typography variant="body2" fontWeight={600}>
                        {issues.length} issue{issues.length !== 1 ? "s" : ""} in view
                    </Typography>
                </Box>
            )}

            {/* Directions FAB - Top Right (below view toggle) */}
            <Tooltip title="Find Route">
                <Fab
                    color={showRouting ? "secondary" : "primary"}
                    size="medium"
                    onClick={() => handleToggleRouting(!showRouting)}
                    sx={{
                        position: "absolute",
                        top: 80,
                        right: 16,
                        zIndex: 2000, // High z-index to ensure it sits above all map layers
                    }}
                >
                    <DirectionsIcon />
                </Fab>
            </Tooltip>

            <Fab
                color="primary"
                size="medium"
                onClick={handleRecenter}
                sx={{
                    position: "absolute",
                    bottom: 24,
                    right: 16,
                    zIndex: 1000,
                }}
                title="Center on my location"
            >
                <MyLocationIcon />
            </Fab>

            {/* Map styles */}
            <style>{`
        .custom-marker-icon {
          background: transparent;
          border: none;
        }
        .custom-cluster-container {
          background: transparent;
          border: none;
        }
        .route-marker-icon {
          background: transparent;
          border: none;
        }
        .cluster-icon {
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          color: white;
          font-weight: 700;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .cluster-small {
          width: 40px;
          height: 40px;
          background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
          font-size: 14px;
        }
        .cluster-medium {
          width: 48px;
          height: 48px;
          background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
          font-size: 16px;
        }
        .cluster-large {
          width: 56px;
          height: 56px;
          background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
          font-size: 18px;
        }
      `}</style>
        </Paper>
    );
};

// Wrapper for RouteInput to handle the controlled state
const RouteInputWrapper = ({
    onFindRoute,
    onClose,
    isLoading,
    selectingPoint,
    onSelectPoint,
    start,
    end,
}: {
    onFindRoute: (start: { lat: number; lng: number }, end: { lat: number; lng: number }) => Promise<void>;
    onClose: () => void;
    isLoading: boolean;
    selectingPoint: "start" | "end" | null;
    onSelectPoint: (point: "start" | "end") => void;
    start: { lat: number; lng: number } | null;
    end: { lat: number; lng: number } | null;
}) => {
    const [startCoords, setStartCoords] = useState(start);
    const [endCoords, setEndCoords] = useState(end);

    // Sync with parent state
    useEffect(() => {
        if (start) setStartCoords(start);
    }, [start]);

    useEffect(() => {
        if (end) setEndCoords(end);
    }, [end]);

    const handleSubmit = async () => {
        if (startCoords && endCoords) {
            await onFindRoute(startCoords, endCoords);
        }
    };

    return (
        <Box
            sx={{
                position: "absolute",
                top: 16,
                left: 16,
                zIndex: 1000,
                width: 300,
            }}
        >
            <Paper elevation={4} sx={{ p: 2, borderRadius: 2 }}>
                <Typography variant="subtitle1" fontWeight={600} gutterBottom sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                    <DirectionsIcon fontSize="small" /> Find Route
                </Typography>
                <Box sx={{ display: "flex", flexDirection: "column", gap: 1.5 }}>
                    <Box>
                        <Typography variant="caption" color="text.secondary">Start</Typography>
                        <Typography variant="body2">
                            {startCoords ? `${startCoords.lat.toFixed(5)}, ${startCoords.lng.toFixed(5)}` : "Click 'Select' then click map"}
                        </Typography>
                        <Box
                            component="button"
                            onClick={() => onSelectPoint("start")}
                            sx={{
                                mt: 0.5,
                                px: 1,
                                py: 0.5,
                                fontSize: "0.75rem",
                                border: "1px solid",
                                borderColor: selectingPoint === "start" ? "primary.main" : "divider",
                                borderRadius: 1,
                                backgroundColor: selectingPoint === "start" ? "primary.light" : "transparent",
                                cursor: "pointer",
                            }}
                        >
                            {selectingPoint === "start" ? "Click on map..." : "Select on map"}
                        </Box>
                    </Box>
                    <Box>
                        <Typography variant="caption" color="text.secondary">Destination</Typography>
                        <Typography variant="body2">
                            {endCoords ? `${endCoords.lat.toFixed(5)}, ${endCoords.lng.toFixed(5)}` : "Click 'Select' then click map"}
                        </Typography>
                        <Box
                            component="button"
                            onClick={() => onSelectPoint("end")}
                            sx={{
                                mt: 0.5,
                                px: 1,
                                py: 0.5,
                                fontSize: "0.75rem",
                                border: "1px solid",
                                borderColor: selectingPoint === "end" ? "primary.main" : "divider",
                                borderRadius: 1,
                                backgroundColor: selectingPoint === "end" ? "primary.light" : "transparent",
                                cursor: "pointer",
                            }}
                        >
                            {selectingPoint === "end" ? "Click on map..." : "Select on map"}
                        </Box>
                    </Box>
                    <Box sx={{ display: "flex", gap: 1, mt: 1 }}>
                        <Box
                            component="button"
                            onClick={handleSubmit}
                            disabled={!startCoords || !endCoords || isLoading}
                            sx={{
                                flex: 1,
                                py: 1,
                                backgroundColor: "primary.main",
                                color: "white",
                                border: "none",
                                borderRadius: 1,
                                cursor: startCoords && endCoords && !isLoading ? "pointer" : "not-allowed",
                                opacity: startCoords && endCoords && !isLoading ? 1 : 0.5,
                            }}
                        >
                            {isLoading ? "Finding..." : "Find Route"}
                        </Box>
                        <Box
                            component="button"
                            onClick={onClose}
                            sx={{
                                px: 2,
                                py: 1,
                                backgroundColor: "transparent",
                                border: "1px solid",
                                borderColor: "divider",
                                borderRadius: 1,
                                cursor: "pointer",
                            }}
                        >
                            Close
                        </Box>
                    </Box>
                </Box>
            </Paper>
        </Box>
    );
};

export default MapInterface;

</code>

## segfault-frontend\src\components\Dashboard\NotificationBell.tsx
<code>
import { useState, useEffect } from 'react';
import { IconButton, Badge, Menu, MenuItem, Typography, Box, Divider, Button, CircularProgress } from '@mui/material';
import NotificationsIcon from '@mui/icons-material/Notifications';
import CircleIcon from '@mui/icons-material/Circle';
import { notificationRoutes, type Notification } from '../../api/routes';
import { useAuth } from '../../state/authContext';

const NotificationBell = () => {
  const { isGuest } = useAuth();
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [loading, setLoading] = useState(false);

  const fetchNotifications = async () => {
    if (isGuest) {
      setNotifications([]);
      setUnreadCount(0);
      return;
    }

    try {
      setLoading(true);
      const data = await notificationRoutes.getNotifications();
      setNotifications(data);
      setUnreadCount(data.filter((n) => !n.read).length);
    } catch (error) {
      console.error('Failed to fetch notifications:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchNotifications();
  }, [isGuest]);

  const handleOpen = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleNotificationClick = async (notification: Notification) => {
    if (!notification.read) {
      try {
        await notificationRoutes.markAsRead(notification.id);
        setNotifications((prev) =>
          prev.map((n) => (n.id === notification.id ? { ...n, read: true } : n))
        );
        setUnreadCount((prev) => Math.max(0, prev - 1));
      } catch (error) {
        console.error('Failed to mark notification as read:', error);
      }
    }
    handleClose();
  };

  const handleMarkAllAsRead = async () => {
    try {
      await notificationRoutes.markAllAsRead();
      setNotifications((prev) => prev.map((n) => ({ ...n, read: true })));
      setUnreadCount(0);
    } catch (error) {
      console.error('Failed to mark all as read:', error);
    }
  };

  const formatNotificationTitle = (type: string): string => {
    switch (type) {
      case 'ISSUE_STATUS_UPDATE':
        return 'Issue Updated';
      case 'NEW_COMMENT':
        return 'New Comment';
      case 'UPVOTE_RECEIVED':
        return 'New Upvote';
      case 'BAN_NOTICE':
        return 'Account Notice';
      default:
        return 'Notification';
    }
  };

  return (
    <>
      <IconButton
        color="inherit"
        onClick={handleOpen}
        sx={{
          mr: 1,
          '&:hover': {
            backgroundColor: 'rgba(255,255,255,0.1)',
          },
        }}
      >
        <Badge
          badgeContent={unreadCount}
          color="error"
          sx={{
            '& .MuiBadge-badge': {
              fontSize: '0.7rem',
              fontWeight: 700,
            },
          }}
        >
          <NotificationsIcon />
        </Badge>
      </IconButton>

      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleClose}
        PaperProps={{
          sx: {
            width: 320,
            maxHeight: 400,
            mt: 1,
            boxShadow: '0 4px 20px rgba(0,0,0,0.15)',
            borderRadius: 2,
          },
        }}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <Box sx={{ px: 2, py: 1.5, display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
          <Typography variant="h6" fontWeight={600}>
            Notifications
          </Typography>
          {unreadCount > 0 && (
            <Button size="small" onClick={handleMarkAllAsRead}>
              Mark all read
            </Button>
          )}
        </Box>
        <Divider />
        {loading ? (
          <Box sx={{ display: 'flex', justifyContent: 'center', py: 3 }}>
            <CircularProgress size={24} />
          </Box>
        ) : notifications.length === 0 ? (
          <MenuItem disabled>
            <Typography variant="body2" color="text.secondary">
              {isGuest ? 'Sign in to view notifications' : 'No notifications'}
            </Typography>
          </MenuItem>
        ) : (
          notifications.map((notification) => (
            <MenuItem
              key={notification.id}
              onClick={() => handleNotificationClick(notification)}
              sx={{
                py: 1.5,
                px: 2,
                backgroundColor: notification.read ? 'transparent' : 'action.hover',
                '&:hover': {
                  backgroundColor: 'action.selected',
                },
              }}
            >
              <Box sx={{ display: 'flex', alignItems: 'flex-start', width: '100%' }}>
                {!notification.read && (
                  <CircleIcon
                    sx={{
                      fontSize: 8,
                      color: 'primary.main',
                      mr: 1,
                      mt: 0.8,
                    }}
                  />
                )}
                <Box sx={{ flex: 1 }}>
                  <Typography variant="body2" fontWeight={notification.read ? 400 : 600}>
                    {formatNotificationTitle(notification.type)}
                  </Typography>
                  <Typography variant="caption" color="text.secondary">
                    {notification.message}
                  </Typography>
                </Box>
              </Box>
            </MenuItem>
          ))
        )}
      </Menu>
    </>
  );
};

export default NotificationBell;

</code>

## segfault-frontend\src\components\Dashboard\PhotoUploader.tsx
<code>
import { useState, useRef } from 'react';
import {
  Box,
  IconButton,
  Typography,
  Snackbar,
  Alert,
} from '@mui/material';
import CloudUploadIcon from '@mui/icons-material/CloudUpload';
import CloseIcon from '@mui/icons-material/Close';

interface PhotoUploaderProps {
  photos: File[];
  onPhotosChange: (photos: File[]) => void;
  maxFiles?: number;
}

const PhotoUploader = ({ photos, onPhotosChange, maxFiles = 2 }: PhotoUploaderProps) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [error, setError] = useState<string | null>(null);
  const [isDragOver, setIsDragOver] = useState(false);

  const validateFile = (file: File): boolean => {
    const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    if (!validTypes.includes(file.type)) {
      setError('Only image files (JPG, PNG, GIF, WebP) are allowed');
      return false;
    }
    return true;
  };

  const handleFiles = (files: FileList | null) => {
    if (!files) return;

    const newFiles = Array.from(files);
    const validFiles: File[] = [];

    for (const file of newFiles) {
      if (photos.length + validFiles.length >= maxFiles) {
        setError(`Maximum ${maxFiles} photos allowed`);
        break;
      }
      if (validateFile(file)) {
        validFiles.push(file);
      }
    }

    if (validFiles.length > 0) {
      onPhotosChange([...photos, ...validFiles]);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(false);
    handleFiles(e.dataTransfer.files);
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragOver(true);
  };

  const handleDragLeave = () => {
    setIsDragOver(false);
  };

  const handleRemove = (index: number) => {
    const updated = photos.filter((_, i) => i !== index);
    onPhotosChange(updated);
  };

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <Box>
      <input
        ref={fileInputRef}
        type="file"
        accept="image/*"
        multiple
        onChange={(e) => handleFiles(e.target.files)}
        style={{ display: 'none' }}
      />

      <Box
        onClick={handleClick}
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        sx={{
          border: '2px dashed',
          borderColor: isDragOver ? 'primary.main' : 'grey.300',
          borderRadius: 2,
          p: 3,
          textAlign: 'center',
          cursor: 'pointer',
          backgroundColor: isDragOver ? 'action.hover' : 'transparent',
          transition: 'all 0.2s',
          '&:hover': {
            borderColor: 'primary.main',
            backgroundColor: 'action.hover',
          },
        }}
      >
        <CloudUploadIcon sx={{ fontSize: 40, color: 'grey.400', mb: 1 }} />
        <Typography variant="body2" color="text.secondary">
          Click or drag photos here
        </Typography>
        <Typography variant="caption" color="text.secondary">
          Max {maxFiles} images (JPG, PNG, GIF, WebP)
        </Typography>
      </Box>

      {photos.length > 0 && (
        <Box sx={{ display: 'flex', gap: 1, mt: 2, flexWrap: 'wrap' }}>
          {photos.map((photo, index) => (
            <Box
              key={index}
              sx={{
                position: 'relative',
                width: 80,
                height: 80,
                borderRadius: 1,
                overflow: 'hidden',
                border: '1px solid',
                borderColor: 'divider',
              }}
            >
              <img
                src={URL.createObjectURL(photo)}
                alt={`Upload ${index + 1}`}
                style={{
                  width: '100%',
                  height: '100%',
                  objectFit: 'cover',
                }}
              />
              <IconButton
                size="small"
                onClick={(e) => {
                  e.stopPropagation();
                  handleRemove(index);
                }}
                sx={{
                  position: 'absolute',
                  top: 2,
                  right: 2,
                  backgroundColor: 'rgba(0,0,0,0.6)',
                  color: 'white',
                  p: 0.3,
                  '&:hover': {
                    backgroundColor: 'rgba(0,0,0,0.8)',
                  },
                }}
              >
                <CloseIcon sx={{ fontSize: 14 }} />
              </IconButton>
            </Box>
          ))}
        </Box>
      )}

      <Snackbar
        open={Boolean(error)}
        autoHideDuration={4000}
        onClose={() => setError(null)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert severity="error" onClose={() => setError(null)}>
          {error}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default PhotoUploader;

</code>

## segfault-frontend\src\components\Dashboard\ProfileModal.tsx
<code>
import { useState, useEffect } from 'react';
import {
    Dialog,
    DialogTitle,
    DialogContent,
    Tabs,
    Tab,
    Box,
    Typography,
    Avatar,
    Paper,
    List,
    ListItem,
    ListItemButton,
    ListItemText,
    Chip,
    CircularProgress,
    IconButton
} from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import { userRoutes } from '../../api/routes';
import type { UserProfile, UserIssue, UserComment } from '../../api/routes';
import EmojiEventsIcon from '@mui/icons-material/EmojiEvents';

interface ProfileModalProps {
    open: boolean;
    onClose: () => void;
    onIssueClick?: (issueId: string) => void;
}

const ProfileModal = ({ open, onClose, onIssueClick }: ProfileModalProps) => {
    const [tab, setTab] = useState(0);
    const [profile, setProfile] = useState<UserProfile | null>(null);
    const [issues, setIssues] = useState<UserIssue[]>([]);
    const [comments, setComments] = useState<UserComment[]>([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        if (open) {
            setLoading(true);
            Promise.all([
                userRoutes.getMe().catch(() => null),
                userRoutes.getMyIssues().catch(() => []),
                userRoutes.getMyComments().catch(() => [])
            ]).then(([p, i, c]) => {
                setProfile(p);
                setIssues(i as UserIssue[]);
                setComments(c as UserComment[]);
                setLoading(false);
            });
        }
    }, [open]);

    const handleIssueClick = (id: string) => {
        onClose();
        if (onIssueClick) {
            onIssueClick(id);
        }
    };

    if (!profile && !loading) {
        return (
            <Dialog open={open} onClose={onClose}>
                <DialogContent>Failed to load profile.</DialogContent>
            </Dialog>
        );
    }

    return (
        <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
            <DialogTitle sx={{ m: 0, p: 2, display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                <Typography variant="h6">User Profile</Typography>
                <IconButton onClick={onClose}><CloseIcon /></IconButton>
            </DialogTitle>
            <DialogContent dividers sx={{ p: 0, minHeight: 400 }}>
                {loading ? (
                    <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
                        <CircularProgress />
                    </Box>
                ) : (
                    <>
                        <Box sx={{ borderBottom: 1, borderColor: 'divider', px: 2 }}>
                            <Tabs value={tab} onChange={(_, v) => setTab(v)}>
                                <Tab label="Overview" />
                                <Tab label={`My Issues (${issues.length})`} />
                                <Tab label={`My Comments (${comments.length})`} />
                            </Tabs>
                        </Box>

                        <Box sx={{ p: 3 }}>
                            {/* Overview Tab */}
                            {tab === 0 && profile && (
                                <Box>
                                    <Box sx={{ display: 'flex', alignItems: 'center', mb: 4 }}>
                                        <Avatar
                                            src={profile.picture || undefined}
                                            sx={{ width: 80, height: 80, mr: 3, fontSize: '2rem' }}
                                        >
                                            {profile.name?.charAt(0) || profile.email.charAt(0)}
                                        </Avatar>
                                        <Box>
                                            <Typography variant="h5" fontWeight="bold">
                                                {profile.name || "Anonymous User"}
                                            </Typography>
                                            <Typography variant="body1" color="text.secondary">
                                                {profile.email}
                                            </Typography>
                                            <Box sx={{ mt: 1, display: 'flex', gap: 1 }}>
                                                <Chip label={profile.role} size="small" color="primary" variant="outlined" />
                                                <Chip
                                                    icon={<EmojiEventsIcon />}
                                                    label={`${profile.stats.points} Points`}
                                                    size="small"
                                                    color="secondary"
                                                />
                                            </Box>
                                        </Box>
                                    </Box>

                                    <Typography variant="h6" gutterBottom>Statistics</Typography>
                                    <Typography variant="h6" gutterBottom>Statistics</Typography>
                                    <Box sx={{ display: 'flex', gap: 2, flexWrap: 'wrap', mb: 4 }}>
                                        <Box sx={{ flex: '1 1 200px' }}>
                                            <Paper sx={{ p: 2, textAlign: 'center', bgcolor: 'background.default' }}>
                                                <Typography variant="h4" color="primary.main">{profile.stats.issuesReported}</Typography>
                                                <Typography variant="body2" color="text.secondary">Issues Reported</Typography>
                                            </Paper>
                                        </Box>
                                        <Box sx={{ flex: '1 1 200px' }}>
                                            <Paper sx={{ p: 2, textAlign: 'center', bgcolor: 'background.default' }}>
                                                <Typography variant="h4" color="secondary.main">{profile.stats.commentsPosted}</Typography>
                                                <Typography variant="body2" color="text.secondary">Comments Posted</Typography>
                                            </Paper>
                                        </Box>
                                    </Box>

                                    <Typography variant="h6" gutterBottom>Badges</Typography>
                                    {profile.badges.length > 0 ? (
                                        <Box sx={{ display: 'flex', gap: 1, flexWrap: 'wrap' }}>
                                            {profile.badges.map(b => (
                                                <Chip key={b.id} label={b.name} color="success" />
                                            ))}
                                        </Box>
                                    ) : (
                                        <Typography variant="body2" color="text.secondary">No badges earned yet.</Typography>
                                    )}
                                </Box>
                            )}

                            {/* Issues Tab */}
                            {tab === 1 && (
                                <List>
                                    {issues.length === 0 ? <Typography color="text.secondary">No issues reported.</Typography> : null}
                                    {issues.map(issue => (
                                        <ListItemButton
                                            key={issue.id}
                                            onClick={() => handleIssueClick(issue.id)}
                                            sx={{ borderBottom: '1px solid', borderColor: 'divider' }}
                                        >
                                            <ListItemText
                                                primary={
                                                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                                                        <Typography variant="subtitle1" component="span">{issue.title}</Typography>
                                                        <Chip label={issue.status} size="small" color={issue.status === 'RESOLVED' ? 'success' : 'warning'} />
                                                    </Box>
                                                }
                                                secondary={`${new Date(issue.reportedAt).toLocaleDateString()}  ${issue.voteCount} votes  ${issue.commentCount} comments`}
                                            />
                                        </ListItemButton>
                                    ))}
                                </List>
                            )}

                            {/* Comments Tab */}
                            {tab === 2 && (
                                <List>
                                    {comments.length === 0 ? <Typography color="text.secondary">No comments posted.</Typography> : null}
                                    {comments.map(comment => (
                                        <ListItem key={comment.id} sx={{ borderBottom: '1px solid', borderColor: 'divider', display: 'block' }}>
                                            <Typography variant="body2" color="text.secondary" gutterBottom>
                                                On <b>{comment.issueTitle}</b>  {new Date(comment.createdAt).toLocaleDateString()}
                                            </Typography>
                                            <Typography variant="body1">{comment.content}</Typography>
                                            <Typography variant="caption" sx={{ mt: 0.5, display: 'block' }}>
                                                {comment.upvoteCount} upvotes
                                            </Typography>
                                        </ListItem>
                                    ))}
                                </List>
                            )}
                        </Box>
                    </>
                )}
            </DialogContent>
        </Dialog>
    );
};

export default ProfileModal;

</code>

## segfault-frontend\src\components\Dashboard\StatsGrid.tsx
<code>
import { Box, Paper, Typography } from "@mui/material";
import TrendingUpIcon from "@mui/icons-material/TrendingUp";
import AccessTimeIcon from "@mui/icons-material/AccessTime";
import ReplayIcon from "@mui/icons-material/Replay";
import ReportProblemIcon from "@mui/icons-material/ReportProblem";

interface PersonalImpact {
    issuesReported: number;
    issuesResolved: number;
    resolutionRate: number;
}

interface CommunityHealth {
    avgResolutionTimeHours: number;
    reopenRate: number;
    totalActiveIssues: number;
}

interface StatsGridProps {
    personalImpact: PersonalImpact | null;
    communityHealth: CommunityHealth;
}

interface StatCardProps {
    title: string;
    value: string | number;
    subtitle?: string;
    icon: React.ReactNode;
    color?: string;
    warning?: boolean;
}

const StatCard = ({ title, value, subtitle, icon, color = "#3b82f6", warning }: StatCardProps) => (
    <Paper
        elevation={0}
        sx={{
            p: 2.5,
            height: "100%",
            borderRadius: 2,
            borderLeft: `4px solid ${warning ? "#ef4444" : color}`,
            bgcolor: 'rgba(255, 255, 255, 0.03)',
            border: '1px solid rgba(255, 255, 255, 0.05)',
            borderLeftWidth: '4px',
            backdropFilter: 'blur(10px)',
            transition: "transform 0.2s, box-shadow 0.2s",
            "&:hover": {
                transform: "translateY(-2px)",
                bgcolor: 'rgba(255, 255, 255, 0.05)',
                boxShadow: '0 4px 20px rgba(0,0,0,0.2)',
            },
        }}
    >
        <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "flex-start" }}>
            <Box>
                <Typography variant="caption" sx={{ textTransform: "uppercase", letterSpacing: 0.5, color: '#94a3b8' }}>
                    {title}
                </Typography>
                <Typography variant="h4" fontWeight={700} sx={{ color: warning ? "#ef4444" : "#f8fafc", mt: 0.5 }}>
                    {value}
                </Typography>
                {subtitle && (
                    <Typography variant="body2" sx={{ mt: 0.5, color: '#64748b' }}>
                        {subtitle}
                    </Typography>
                )}
            </Box>
            <Box sx={{ color: warning ? "#ef4444" : color, opacity: 0.9 }}>
                {icon}
            </Box>
        </Box>
    </Paper>
);

const StatsGrid = ({ personalImpact, communityHealth }: StatsGridProps) => {
    return (
        <Box sx={{ mb: 3 }}>
            <Typography variant="h6" fontWeight={600} sx={{ mb: 2, color: '#f8fafc' }}>
                Dashboard Metrics
            </Typography>
            <Box sx={{ display: "flex", flexWrap: "wrap", gap: 2 }}>
                {personalImpact && (
                    <>
                        <Box sx={{ flex: "1 1 calc(25% - 16px)", minWidth: 200 }}>
                            <StatCard
                                title="Issues Reported"
                                value={personalImpact.issuesReported}
                                subtitle="by you"
                                icon={<ReportProblemIcon sx={{ fontSize: 32 }} />}
                                color="#8b5cf6"
                            />
                        </Box>
                        <Box sx={{ flex: "1 1 calc(25% - 16px)", minWidth: 200 }}>
                            <StatCard
                                title="Resolution Rate"
                                value={`${personalImpact.resolutionRate}%`}
                                subtitle={`${personalImpact.issuesResolved} resolved`}
                                icon={<TrendingUpIcon sx={{ fontSize: 32 }} />}
                                color="#22c55e"
                            />
                        </Box>
                    </>
                )}
                <Box sx={{ flex: personalImpact ? "1 1 calc(25% - 16px)" : "1 1 calc(33% - 16px)", minWidth: 200 }}>
                    <StatCard
                        title="Avg Fix Time"
                        value={communityHealth.avgResolutionTimeHours < 24
                            ? `${communityHealth.avgResolutionTimeHours}h`
                            : `${Math.round(communityHealth.avgResolutionTimeHours / 24)}d`}
                        subtitle="community average"
                        icon={<AccessTimeIcon sx={{ fontSize: 32 }} />}
                        color="#f59e0b"
                    />
                </Box>
                <Box sx={{ flex: personalImpact ? "1 1 calc(25% - 16px)" : "1 1 calc(33% - 16px)", minWidth: 200 }}>
                    <StatCard
                        title="Reopen Rate"
                        value={`${communityHealth.reopenRate}%`}
                        subtitle={communityHealth.reopenRate > 10 ? "low accountability" : "healthy"}
                        icon={<ReplayIcon sx={{ fontSize: 32 }} />}
                        warning={communityHealth.reopenRate > 10}
                    />
                </Box>
                <Box sx={{ flex: personalImpact ? "1 1 calc(20% - 16px)" : "1 1 calc(33% - 16px)", minWidth: 200 }}>
                    <StatCard
                        title="Active Issues"
                        value={communityHealth.totalActiveIssues}
                        subtitle="awaiting resolution"
                        icon={<ReportProblemIcon sx={{ fontSize: 32 }} />}
                        color="#ef4444"
                    />
                </Box>
            </Box>
        </Box>
    );
};

export default StatsGrid;

</code>

## segfault-frontend\src\components\Dashboard\TrendChart.tsx
<code>
import { Box, Paper, Typography } from "@mui/material";
import {
    LineChart,
    Line,
    XAxis,
    YAxis,
    CartesianGrid,
    Tooltip,
    Legend,
    ResponsiveContainer,
} from "recharts";

interface TrendDataPoint {
    date: string;
    reported: number;
    resolved: number;
}

interface TrendChartProps {
    data: TrendDataPoint[];
}

const TrendChart = ({ data }: TrendChartProps) => {
    const formattedData = data.map((point) => ({
        ...point,
        date: new Date(point.date).toLocaleDateString("en-US", { month: "short", day: "numeric" }),
    }));

    return (
        <Paper elevation={0} sx={{
            p: 3,
            borderRadius: 2,
            bgcolor: 'rgba(255, 255, 255, 0.03)',
            border: '1px solid rgba(255, 255, 255, 0.05)',
            backdropFilter: 'blur(10px)',
        }}>
            <Typography variant="h6" fontWeight={600} sx={{ mb: 2, color: '#f8fafc' }}>
                Issue Trends
            </Typography>
            <Typography variant="body2" sx={{ mb: 3, color: '#94a3b8' }}>
                New issues reported vs resolved over time
            </Typography>
            <Box sx={{ width: "100%", height: 300 }}>
                <ResponsiveContainer>
                    <LineChart data={formattedData} margin={{ top: 5, right: 30, left: 0, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" stroke="rgba(255,255,255,0.1)" />
                        <XAxis
                            dataKey="date"
                            tick={{ fontSize: 12, fill: '#94a3b8' }}
                            tickLine={false}
                            axisLine={{ stroke: "rgba(255,255,255,0.1)" }}
                        />
                        <YAxis
                            tick={{ fontSize: 12, fill: '#94a3b8' }}
                            tickLine={false}
                            axisLine={{ stroke: "rgba(255,255,255,0.1)" }}
                            allowDecimals={false}
                        />
                        <Tooltip
                            contentStyle={{
                                backgroundColor: "rgba(15, 23, 42, 0.95)",
                                border: "1px solid rgba(255, 255, 255, 0.1)",
                                borderRadius: 8,
                                boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.5)",
                                color: "#f8fafc"
                            }}
                            itemStyle={{ color: '#f8fafc' }}
                            labelStyle={{ color: '#94a3b8' }}
                        />
                        <Legend />
                        <Line
                            type="monotone"
                            dataKey="reported"
                            name="New Issues"
                            stroke="#ef4444"
                            strokeWidth={2}
                            dot={{ fill: "#ef4444", r: 3 }}
                            activeDot={{ r: 5 }}
                        />
                        <Line
                            type="monotone"
                            dataKey="resolved"
                            name="Resolved"
                            stroke="#22c55e"
                            strokeWidth={2}
                            dot={{ fill: "#22c55e", r: 3 }}
                            activeDot={{ r: 5 }}
                        />
                    </LineChart>
                </ResponsiveContainer>
            </Box>
        </Paper>
    );
};

export default TrendChart;

</code>

## segfault-frontend\src\components\Dashboard\UserMenu.tsx
<code>
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  IconButton,
  Avatar,
  Menu,
  MenuItem,
  ListItemIcon,
  ListItemText,
  Divider,
  Typography,
  Box,
} from '@mui/material';
import LogoutIcon from '@mui/icons-material/Logout';
import PersonIcon from '@mui/icons-material/Person';
import SettingsIcon from '@mui/icons-material/Settings';
import { authAPI } from '../../api/axios';
import { useAuth } from '../../state/authContext';
import ChangePasswordModal from './ChangePasswordModal';
import ProfileModal from './ProfileModal';

interface UserMenuProps {
  onIssueClick?: (issueId: string) => void;
}

const UserMenu = ({ onIssueClick }: UserMenuProps) => {
  const navigate = useNavigate();
  const { user, logout, isGuest } = useAuth();
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const [profileOpen, setProfileOpen] = useState(false);
  const [passwordOpen, setPasswordOpen] = useState(false);

  const handleOpen = (event: React.MouseEvent<HTMLElement>) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleLogout = async () => {
    handleClose();
    try {
      await authAPI.logout();
    } catch {
    }
    logout();
    navigate('/login');
  };

  const handleProfileClick = () => {
    handleClose();
    setProfileOpen(true);
  };

  const handleSettingsClick = () => {
    handleClose();
    setPasswordOpen(true);
  };

  const getUserInitial = (): string => {
    if (!user) return 'U';
    if (user.name) return user.name.charAt(0).toUpperCase();
    if (user.email) return user.email.charAt(0).toUpperCase();
    return 'U';
  };

  const getDisplayName = (): string => {
    if (!user) return 'User';
    if (isGuest) return 'Guest User';
    return user.name || user.email?.split('@')[0] || 'User';
  };

  const getDisplayEmail = (): string => {
    if (!user) return '';
    if (isGuest) return 'Anonymous session';
    return user.email || '';
  };

  return (
    <>
      <IconButton
        onClick={handleOpen}
        sx={{
          p: 0.5,
          '&:hover': {
            backgroundColor: 'rgba(255,255,255,0.1)',
          },
        }}
      >
        <Avatar
          src={user?.picture || undefined}
          sx={{
            width: 36,
            height: 36,
            bgcolor: isGuest ? 'grey.500' : 'secondary.main',
            fontSize: '1rem',
            fontWeight: 600,
          }}
        >
          {getUserInitial()}
        </Avatar>
      </IconButton>

      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleClose}
        PaperProps={{
          sx: {
            width: 220,
            mt: 1,
            boxShadow: '0 4px 20px rgba(0,0,0,0.15)',
            borderRadius: 2,
          },
        }}
        transformOrigin={{ horizontal: 'right', vertical: 'top' }}
        anchorOrigin={{ horizontal: 'right', vertical: 'bottom' }}
      >
        <Box sx={{ px: 2, py: 1.5 }}>
          <Typography variant="subtitle1" fontWeight={600}>
            {getDisplayName()}
          </Typography>
          <Typography variant="body2" color="text.secondary">
            {getDisplayEmail()}
          </Typography>
        </Box>
        <Divider />
        {!isGuest && (
            <MenuItem onClick={handleProfileClick} sx={{ py: 1.5 }}>
              <ListItemIcon>
                <PersonIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText>Profile</ListItemText>
            </MenuItem>
        )}
        {!isGuest && (
            <MenuItem onClick={handleSettingsClick} sx={{ py: 1.5 }}>
              <ListItemIcon>
                <SettingsIcon fontSize="small" />
              </ListItemIcon>
              <ListItemText>Settings</ListItemText>
            </MenuItem>
        )}
        {!isGuest && <Divider />}
        <MenuItem
          onClick={handleLogout}
          sx={{
            py: 1.5,
            color: 'error.main',
            '&:hover': {
              backgroundColor: 'error.light',
              color: 'error.contrastText',
            },
          }}
        >
          <ListItemIcon>
            <LogoutIcon fontSize="small" sx={{ color: 'inherit' }} />
          </ListItemIcon>
          <ListItemText>Logout</ListItemText>
        </MenuItem>
      </Menu>

      <ChangePasswordModal open={passwordOpen} onClose={() => setPasswordOpen(false)} />
      <ProfileModal
        open={profileOpen}
        onClose={() => setProfileOpen(false)}
        onIssueClick={onIssueClick}
      />
    </>
  );
};

export default UserMenu;

</code>

## segfault-frontend\src\components\Map\IssueMarker.tsx
<code>
import { Marker, Popup } from "react-leaflet";
import { Box, Typography, Button, Chip } from "@mui/material";
import { getStatusIcon, getUrgencyIcon } from "./markerIcons";
import type { MapIssue } from "../../api/routes";

export type VisualizationMode = "status" | "urgency";

interface IssueMarkerProps {
  issue: MapIssue;
  visualizationMode: VisualizationMode;
  onClick: (id: string) => void;
}

const STATUS_LABELS: Record<string, { label: string; color: "error" | "warning" | "success" }> = {
  PENDING: { label: "Pending", color: "error" },
  IN_PROGRESS: { label: "In Progress", color: "warning" },
  RESOLVED: { label: "Resolved", color: "success" },
};

const IssueMarker = ({ issue, visualizationMode, onClick }: IssueMarkerProps) => {
  const icon =
    visualizationMode === "status"
      ? getStatusIcon(issue.status)
      : getUrgencyIcon(issue.urgencyScore);

  const statusInfo = STATUS_LABELS[issue.status] || STATUS_LABELS.PENDING;

  // Format issue type for display
  const formatType = (type: string) => {
    return type
      .split("_")
      .map((word) => word.charAt(0) + word.slice(1).toLowerCase())
      .join(" ");
  };

  return (
    <Marker position={[issue.lat, issue.lng]} icon={icon}>
      <Popup>
        <Box sx={{ minWidth: 200, p: 0.5 }}>
          <Typography variant="subtitle1" fontWeight={600} gutterBottom>
            {issue.title}
          </Typography>

          <Box sx={{ display: "flex", gap: 1, mb: 1, flexWrap: "wrap" }}>
            <Chip
              label={formatType(issue.type)}
              size="small"
              variant="outlined"
              sx={{ fontSize: "0.7rem" }}
            />
            <Chip
              label={statusInfo.label}
              size="small"
              color={statusInfo.color}
              sx={{ fontSize: "0.7rem" }}
            />
          </Box>

          {visualizationMode === "urgency" && (
            <Typography variant="caption" color="text.secondary" display="block" gutterBottom>
              Urgency Score: {issue.urgencyScore}/100
            </Typography>
          )}

          <Typography variant="body2" color="text.secondary" sx={{ mb: 1.5 }}>
            {issue.voteCount} votes  {issue.commentCount} comments
          </Typography>

          <Button
            variant="contained"
            size="small"
            fullWidth
            onClick={() => onClick(issue.id)}
            sx={{ textTransform: "none" }}
          >
            View Details
          </Button>
        </Box>
      </Popup>
    </Marker>
  );
};

export default IssueMarker;

</code>

## segfault-frontend\src\components\Map\LocationPicker.tsx
<code>
import { useState, useMemo, useCallback } from "react";
import { MapContainer, TileLayer, Marker, useMapEvents } from "react-leaflet";
import L from "leaflet";
import { Box, Typography } from "@mui/material";
import "leaflet/dist/leaflet.css";
import "leaflet-defaulticon-compatibility/dist/leaflet-defaulticon-compatibility.css";
import "leaflet-defaulticon-compatibility";

interface LocationPickerProps {
  lat: number | null;
  lng: number | null;
  onChange: (lat: number, lng: number) => void;
}

// Inner component to handle draggable marker
const DraggableMarker = ({
  position,
  onDragEnd,
}: {
  position: [number, number];
  onDragEnd: (lat: number, lng: number) => void;
}) => {
  const markerRef = React.useRef<L.Marker>(null);

  const eventHandlers = useMemo(
    () => ({
      dragend() {
        const marker = markerRef.current;
        if (marker) {
          const latlng = marker.getLatLng();
          onDragEnd(latlng.lat, latlng.lng);
        }
      },
    }),
    [onDragEnd]
  );

  return <Marker draggable={true} eventHandlers={eventHandlers} position={position} ref={markerRef} />;
};

// Component to handle map clicks
const MapClickHandler = ({ onClick }: { onClick: (lat: number, lng: number) => void }) => {
  useMapEvents({
    click: (e) => {
      onClick(e.latlng.lat, e.latlng.lng);
    },
  });
  return null;
};

// Need to import React for the ref
import React from "react";

/**
 * LocationPicker - A simplified map for selecting a location by dragging a pin
 */
const LocationPicker = ({ lat, lng, onChange }: LocationPickerProps) => {
  // Default to a central location if no coordinates provided
  const defaultLat = 28.6139; // Delhi, India (example default)
  const defaultLng = 77.209;

  const [position, setPosition] = useState<[number, number]>([lat ?? defaultLat, lng ?? defaultLng]);

  const handleDragEnd = useCallback(
    (newLat: number, newLng: number) => {
      setPosition([newLat, newLng]);
      onChange(newLat, newLng);
    },
    [onChange]
  );

  const handleClick = useCallback(
    (clickLat: number, clickLng: number) => {
      setPosition([clickLat, clickLng]);
      onChange(clickLat, clickLng);
    },
    [onChange]
  );

  return (
    <Box sx={{ height: 300, width: "100%", borderRadius: 2, overflow: "hidden", border: "1px solid", borderColor: "divider" }}>
      <Typography
        variant="caption"
        sx={{
          position: "absolute",
          top: 8,
          left: 8,
          zIndex: 1000,
          backgroundColor: "rgba(255,255,255,0.9)",
          px: 1,
          py: 0.5,
          borderRadius: 1,
          fontWeight: 500,
        }}
      >
        Drag marker or click to set location
      </Typography>
      <MapContainer
        center={position}
        zoom={15}
        style={{ height: "100%", width: "100%" }}
        scrollWheelZoom={true}
      >
        <TileLayer
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        />
        <MapClickHandler onClick={handleClick} />
        <DraggableMarker position={position} onDragEnd={handleDragEnd} />
      </MapContainer>
    </Box>
  );
};

export default LocationPicker;

</code>

## segfault-frontend\src\components\Map\MapEvents.tsx
<code>
import { useMapEvents } from "react-leaflet";

export interface Bounds {
  minLat: number;
  maxLat: number;
  minLng: number;
  maxLng: number;
}

interface MapEventsProps {
  onBoundsChange: (bounds: Bounds) => void;
}

/**
 * A helper component that listens for map events (pan/zoom) and
 * notifies the parent when bounds change.
 */
const MapEvents = ({ onBoundsChange }: MapEventsProps) => {
  useMapEvents({
    moveend: (e) => {
      const map = e.target;
      const bounds = map.getBounds();
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();

      onBoundsChange({
        minLat: sw.lat,
        maxLat: ne.lat,
        minLng: sw.lng,
        maxLng: ne.lng,
      });
    },
    // Also trigger on initial load
    load: (e) => {
      const map = e.target;
      const bounds = map.getBounds();
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();

      onBoundsChange({
        minLat: sw.lat,
        maxLat: ne.lat,
        minLng: sw.lng,
        maxLng: ne.lng,
      });
    },
  });

  return null;
};

export default MapEvents;

</code>

## segfault-frontend\src\components\Map\markerIcons.ts
<code>
import L from "leaflet";

/**
 * Creates a Leaflet DivIcon with a colored SVG marker based on issue status
 */
export function getStatusIcon(status: string): L.DivIcon {
    const colors: Record<string, string> = {
        PENDING: "#ef4444", // Red
        IN_PROGRESS: "#f59e0b", // Yellow/Amber
        RESOLVED: "#22c55e", // Green
    };

    const color = colors[status] || colors.PENDING;

    return createMarkerIcon(color);
}

/**
 * Creates a Leaflet DivIcon with a color interpolated from Green (0) -> Yellow (50) -> Red (100)
 * based on urgency score
 */
export function getUrgencyIcon(urgencyScore: number): L.DivIcon {
    const color = interpolateColor(urgencyScore);
    return createMarkerIcon(color);
}

/**
 * Interpolates color from green (low) to yellow (mid) to red (high)
 */
function interpolateColor(score: number): string {
    // Clamp score between 0 and 100
    const clamped = Math.max(0, Math.min(100, score));

    let r: number, g: number, b: number;

    if (clamped <= 50) {
        // Green to Yellow (0-50)
        const ratio = clamped / 50;
        r = Math.round(34 + (245 - 34) * ratio); // 34 -> 245
        g = Math.round(197 + (158 - 197) * ratio); // 197 -> 158
        b = Math.round(94 + (11 - 94) * ratio); // 94 -> 11
    } else {
        // Yellow to Red (50-100)
        const ratio = (clamped - 50) / 50;
        r = Math.round(245 + (239 - 245) * ratio); // 245 -> 239
        g = Math.round(158 + (68 - 158) * ratio); // 158 -> 68
        b = Math.round(11 + (68 - 11) * ratio); // 11 -> 68
    }

    return `rgb(${r}, ${g}, ${b})`;
}

/**
 * Creates a colored marker icon as SVG
 */
function createMarkerIcon(color: string): L.DivIcon {
    const svg = `
    <svg width="32" height="42" viewBox="0 0 32 42" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
          <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity="0.3"/>
        </filter>
      </defs>
      <path 
        d="M16 0C7.163 0 0 7.163 0 16c0 8.837 16 26 16 26s16-17.163 16-26C32 7.163 24.837 0 16 0z" 
        fill="${color}" 
        filter="url(#shadow)"
      />
      <circle cx="16" cy="14" r="6" fill="white" opacity="0.9"/>
    </svg>
  `;

    return L.divIcon({
        html: svg,
        className: "custom-marker-icon",
        iconSize: [32, 42],
        iconAnchor: [16, 42],
        popupAnchor: [0, -42],
    });
}

/**
 * Creates a cluster icon with the count displayed
 */
export function createClusterIcon(cluster: { getChildCount: () => number }): L.DivIcon {
    const count = cluster.getChildCount();
    let size = "small";
    let dimension = 40;

    if (count >= 100) {
        size = "large";
        dimension = 56;
    } else if (count >= 10) {
        size = "medium";
        dimension = 48;
    }

    return L.divIcon({
        html: `<div class="cluster-icon cluster-${size}"><span>${count}</span></div>`,
        className: "custom-cluster-container",
        iconSize: L.point(dimension, dimension),
    });
}

</code>

## segfault-frontend\src\components\Routing\RouteInput.tsx
<code>
import { useState } from "react";
import {
  Box,
  Paper,
  TextField,
  Button,
  Typography,
  IconButton,
  CircularProgress,
  InputAdornment,
} from "@mui/material";
import DirectionsIcon from "@mui/icons-material/Directions";
import MyLocationIcon from "@mui/icons-material/MyLocation";
import CloseIcon from "@mui/icons-material/Close";
import SwapVertIcon from "@mui/icons-material/SwapVert";

interface Coordinates {
  lat: number;
  lng: number;
}

interface RouteInputProps {
  onFindRoute: (start: Coordinates, end: Coordinates) => Promise<void>;
  onClose: () => void;
  isLoading: boolean;
  selectingPoint: "start" | "end" | null;
  onSelectPoint: (point: "start" | "end") => void;
}

const RouteInput = ({
  onFindRoute,
  onClose,
  isLoading,
  selectingPoint,
  onSelectPoint,
}: RouteInputProps) => {
  const [start, setStart] = useState<Coordinates | null>(null);
  const [end, setEnd] = useState<Coordinates | null>(null);
  const [startText, setStartText] = useState("");
  const [endText, setEndText] = useState("");

  const handleUseMyLocation = (field: "start" | "end") => {
    if (!navigator.geolocation) return;

    navigator.geolocation.getCurrentPosition(
      (position) => {
        const coords = {
          lat: position.coords.latitude,
          lng: position.coords.longitude,
        };
        if (field === "start") {
          setStart(coords);
          setStartText(`${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}`);
        } else {
          setEnd(coords);
          setEndText(`${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}`);
        }
      },
      (error) => {
        console.error("Location error:", error);
      }
    );
  };

  const handleSwapLocations = () => {
    const tempStart = start;
    const tempStartText = startText;
    setStart(end);
    setStartText(endText);
    setEnd(tempStart);
    setEndText(tempStartText);
  };

  const handleSubmit = async () => {
    if (start && end) {
      await onFindRoute(start, end);
    }
  };

  // Update coordinates when map selection happens
  const updateFromSelection = (coords: Coordinates) => {
    if (selectingPoint === "start") {
      setStart(coords);
      setStartText(`${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}`);
    } else if (selectingPoint === "end") {
      setEnd(coords);
      setEndText(`${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}`);
    }
  };

  // Expose update method via component key pattern (parent calls this)
  (RouteInput as any).updateFromSelection = updateFromSelection;

  return (
    <Paper
      elevation={4}
      sx={{
        position: "absolute",
        top: 16,
        left: 16,
        zIndex: 1000,
        width: 320,
        borderRadius: 3,
        overflow: "hidden",
      }}
    >
      {/* Header */}
      <Box
        sx={{
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          px: 2,
          py: 1.5,
          backgroundColor: "primary.main",
          color: "white",
        }}
      >
        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
          <DirectionsIcon />
          <Typography variant="subtitle1" fontWeight={600}>
            Find Route
          </Typography>
        </Box>
        <IconButton size="small" onClick={onClose} sx={{ color: "white" }}>
          <CloseIcon />
        </IconButton>
      </Box>

      {/* Inputs */}
      <Box sx={{ p: 2, display: "flex", flexDirection: "column", gap: 2 }}>
        <Box sx={{ display: "flex", gap: 1, alignItems: "flex-start" }}>
          <Box sx={{ flex: 1 }}>
            <TextField
              size="small"
              fullWidth
              label="Start"
              value={startText}
              placeholder="Select on map or use location"
              InputProps={{
                readOnly: true,
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      size="small"
                      onClick={() => handleUseMyLocation("start")}
                      title="Use my location"
                    >
                      <MyLocationIcon fontSize="small" />
                    </IconButton>
                  </InputAdornment>
                ),
              }}
              sx={{
                "& .MuiOutlinedInput-root": {
                  backgroundColor: selectingPoint === "start" ? "action.selected" : undefined,
                },
              }}
            />
            <Button
              size="small"
              onClick={() => onSelectPoint("start")}
              sx={{ mt: 0.5, textTransform: "none" }}
              variant={selectingPoint === "start" ? "contained" : "text"}
            >
              {selectingPoint === "start" ? "Click map..." : "Select on map"}
            </Button>
          </Box>
        </Box>

        <Box sx={{ display: "flex", justifyContent: "center" }}>
          <IconButton size="small" onClick={handleSwapLocations} title="Swap locations">
            <SwapVertIcon />
          </IconButton>
        </Box>

        <Box sx={{ display: "flex", gap: 1, alignItems: "flex-start" }}>
          <Box sx={{ flex: 1 }}>
            <TextField
              size="small"
              fullWidth
              label="Destination"
              value={endText}
              placeholder="Select on map or use location"
              InputProps={{
                readOnly: true,
                endAdornment: (
                  <InputAdornment position="end">
                    <IconButton
                      size="small"
                      onClick={() => handleUseMyLocation("end")}
                      title="Use my location"
                    >
                      <MyLocationIcon fontSize="small" />
                    </IconButton>
                  </InputAdornment>
                ),
              }}
              sx={{
                "& .MuiOutlinedInput-root": {
                  backgroundColor: selectingPoint === "end" ? "action.selected" : undefined,
                },
              }}
            />
            <Button
              size="small"
              onClick={() => onSelectPoint("end")}
              sx={{ mt: 0.5, textTransform: "none" }}
              variant={selectingPoint === "end" ? "contained" : "text"}
            >
              {selectingPoint === "end" ? "Click map..." : "Select on map"}
            </Button>
          </Box>
        </Box>

        <Button
          variant="contained"
          fullWidth
          onClick={handleSubmit}
          disabled={!start || !end || isLoading}
          startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : <DirectionsIcon />}
          sx={{ mt: 1, py: 1.2 }}
        >
          {isLoading ? "Finding Route..." : "Find Route"}
        </Button>
      </Box>
    </Paper>
  );
};

export default RouteInput;

</code>

## segfault-frontend\src\components\Routing\RouteRenderer.tsx
<code>
import { Polyline, Marker } from "react-leaflet";
import L from "leaflet";

interface PathPoint {
  lat: number;
  lng: number;
}

interface RouteRendererProps {
  path: PathPoint[];
  totalDistance?: number;
  estimatedTime?: number;
}

// Custom icons for start/end markers
const startIcon = L.divIcon({
  html: `
    <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
      <circle cx="16" cy="16" r="14" fill="#22c55e" stroke="white" stroke-width="3"/>
      <circle cx="16" cy="16" r="6" fill="white"/>
    </svg>
  `,
  className: "route-marker-icon",
  iconSize: [32, 32],
  iconAnchor: [16, 16],
});

const endIcon = L.divIcon({
  html: `
    <svg width="32" height="32" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
      <circle cx="16" cy="16" r="14" fill="#ef4444" stroke="white" stroke-width="3"/>
      <rect x="10" y="10" width="12" height="12" fill="white" rx="2"/>
    </svg>
  `,
  className: "route-marker-icon",
  iconSize: [32, 32],
  iconAnchor: [16, 16],
});

/**
 * Renders a route polyline on the map with start/end markers
 */
const RouteRenderer = ({ path }: RouteRendererProps) => {
  if (!path || path.length < 2) return null;

  const positions: [number, number][] = path.map((p) => [p.lat, p.lng]);
  const startPoint = path[0];
  const endPoint = path[path.length - 1];

  return (
    <>
      {/* Route polyline */}
      <Polyline
        positions={positions}
        pathOptions={{
          color: "#3b82f6",
          weight: 5,
          opacity: 0.8,
          lineCap: "round",
          lineJoin: "round",
        }}
      />

      {/* Shadow line for depth effect */}
      <Polyline
        positions={positions}
        pathOptions={{
          color: "#1e40af",
          weight: 8,
          opacity: 0.3,
          lineCap: "round",
          lineJoin: "round",
        }}
      />

      {/* Start marker */}
      <Marker position={[startPoint.lat, startPoint.lng]} icon={startIcon} />

      {/* End marker */}
      <Marker position={[endPoint.lat, endPoint.lng]} icon={endIcon} />
    </>
  );
};

export default RouteRenderer;

</code>

## segfault-frontend\src\components\Shared\UserBadge.tsx
<code>
import { Box, Tooltip, Typography, Chip } from "@mui/material";
import StarIcon from "@mui/icons-material/Star";
import ShieldIcon from "@mui/icons-material/Shield";
import EmojiEventsIcon from "@mui/icons-material/EmojiEvents";
import VisibilityIcon from "@mui/icons-material/Visibility";

interface UserBadgeProps {
    score: number;
    badges: string[];
    compact?: boolean;
}

const BADGE_CONFIG: Record<string, { icon: React.ReactNode; color: string; label: string }> = {
    Observer: {
        icon: <VisibilityIcon sx={{ fontSize: 16 }} />,
        color: "#cd7f32",
        label: "Observer (10+ pts)",
    },
    Activist: {
        icon: <ShieldIcon sx={{ fontSize: 16 }} />,
        color: "#c0c0c0",
        label: "Activist (100+ pts)",
    },
    Guardian: {
        icon: <EmojiEventsIcon sx={{ fontSize: 16 }} />,
        color: "#ffd700",
        label: "Guardian (500+ pts)",
    },
};

const UserBadge = ({ score, badges, compact = false }: UserBadgeProps) => {
    const highestBadge = [...badges].reverse()[0];
    const badgeConfig = highestBadge ? BADGE_CONFIG[highestBadge] : null;

    if (compact) {
        return (
            <Box sx={{ display: "inline-flex", alignItems: "center", gap: 0.5 }}>
                {badgeConfig && (
                    <Tooltip title={badgeConfig.label}>
                        <Box sx={{ color: badgeConfig.color, display: "flex", alignItems: "center" }}>
                            {badgeConfig.icon}
                        </Box>
                    </Tooltip>
                )}
                <Typography variant="caption" color="text.secondary">
                    {score} pts
                </Typography>
            </Box>
        );
    }

    return (
        <Box sx={{ display: "flex", alignItems: "center", gap: 1, flexWrap: "wrap" }}>
            <Chip
                icon={<StarIcon sx={{ fontSize: 16 }} />}
                label={`${score} pts`}
                size="small"
                variant="outlined"
                sx={{ fontSize: "0.75rem" }}
            />
            {badges.map((badge) => {
                const config = BADGE_CONFIG[badge];
                if (!config) return null;
                return (
                    <Tooltip key={badge} title={config.label}>
                        <Chip
                            icon={<Box sx={{ color: config.color }}>{config.icon}</Box>}
                            label={badge}
                            size="small"
                            sx={{
                                fontSize: "0.75rem",
                                borderColor: config.color,
                                "& .MuiChip-icon": { color: config.color },
                            }}
                            variant="outlined"
                        />
                    </Tooltip>
                );
            })}
        </Box>
    );
};

export default UserBadge;

</code>

## segfault-frontend\src\pages\Admin\AdminDashboard.tsx
<code>
import { useState, useEffect } from 'react';
import {
    Box,
    Typography,
    Tabs,
    Tab,
    Paper,
    Table,
    TableBody,
    TableCell,
    TableContainer,
    TableHead,
    TableRow,
    Button,
    Chip,
    CircularProgress,
    Alert,
    Avatar,
    IconButton,
    Tooltip,
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import CancelIcon from '@mui/icons-material/Cancel';
import BlockIcon from '@mui/icons-material/Block';
import { adminRoutes, type ModerationItem, type AdminUser } from '../../api/routes';
import { AZURE_BACKEND_URL } from '../../constants';

const AdminDashboard = () => {
    const [tab, setTab] = useState(0);
    const [moderationQueue, setModerationQueue] = useState<ModerationItem[]>([]);
    const [users, setUsers] = useState<AdminUser[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [successMsg, setSuccessMsg] = useState<string | null>(null);

    useEffect(() => {
        if (tab === 0) {
            fetchModeration();
        } else {
            fetchUsers();
        }
    }, [tab]);

    const fetchModeration = async () => {
        setLoading(true);
        setError(null);
        try {
            const data = await adminRoutes.getModerationQueue();
            setModerationQueue(data);
        } catch (err) {
            setError('Failed to fetch moderation queue');
        } finally {
            setLoading(false);
        }
    };

    const fetchUsers = async () => {
        setLoading(true);
        setError(null);
        try {
            const data = await adminRoutes.getUsers();
            setUsers(data.users);
        } catch (err) {
            setError('Failed to fetch users');
        } finally {
            setLoading(false);
        }
    };

    const handleResolve = async (id: string, action: 'APPROVE' | 'REJECT') => {
        try {
            const result = await adminRoutes.resolveModeration(id, action);
            setSuccessMsg(result.message);
            fetchModeration();
        } catch (err) {
            setError('Failed to resolve moderation');
        }
    };

    const handleBan = async (userId: string) => {
        if (!confirm('Are you sure you want to ban this user?')) return;
        try {
            const result = await adminRoutes.banUser(userId);
            setSuccessMsg(result.message);
            fetchUsers();
        } catch (err) {
            setError('Failed to ban user');
        }
    };

    return (
        <Box sx={{ p: 4, maxWidth: 1400, mx: 'auto' }}>
            <Typography variant="h4" fontWeight={700} gutterBottom>
                Admin Dashboard
            </Typography>

            <Paper sx={{ mb: 3 }}>
                <Tabs value={tab} onChange={(_, v) => setTab(v)}>
                    <Tab label="Moderation Queue" />
                    <Tab label="User Management" />
                </Tabs>
            </Paper>

            {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
            {successMsg && (
                <Alert severity="success" sx={{ mb: 2 }} onClose={() => setSuccessMsg(null)}>
                    {successMsg}
                </Alert>
            )}

            {loading ? (
                <Box sx={{ display: 'flex', justifyContent: 'center', py: 6 }}>
                    <CircularProgress />
                </Box>
            ) : tab === 0 ? (
                <TableContainer component={Paper}>
                    <Table>
                        <TableHead>
                            <TableRow>
                                <TableCell>Image</TableCell>
                                <TableCell>Title</TableCell>
                                <TableCell>Type</TableCell>
                                <TableCell>Error</TableCell>
                                <TableCell>Reporter</TableCell>
                                <TableCell>Actions</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {moderationQueue.length === 0 ? (
                                <TableRow>
                                    <TableCell colSpan={6} align="center">
                                        No items pending moderation
                                    </TableCell>
                                </TableRow>
                            ) : (
                                moderationQueue.map((item) => (
                                    <TableRow key={item.id}>
                                        <TableCell>
                                            {item.imageBlobId ? (
                                                <Avatar
                                                    variant="rounded"
                                                    src={`${AZURE_BACKEND_URL}/uploads/${item.imageBlobId}`}
                                                    sx={{ width: 60, height: 60 }}
                                                />
                                            ) : (
                                                <Avatar variant="rounded" sx={{ width: 60, height: 60 }}>N/A</Avatar>
                                            )}
                                        </TableCell>
                                        <TableCell>{item.title}</TableCell>
                                        <TableCell>
                                            <Chip label={item.type} size="small" />
                                        </TableCell>
                                        <TableCell>
                                            <Chip
                                                label={item.error || 'Pending'}
                                                size="small"
                                                color={item.error !== 'NONE' ? 'error' : 'default'}
                                            />
                                        </TableCell>
                                        <TableCell>{item.reporter.name}</TableCell>
                                        <TableCell>
                                            <Tooltip title="Approve">
                                                <IconButton
                                                    color="success"
                                                    onClick={() => handleResolve(item.id, 'APPROVE')}
                                                >
                                                    <CheckCircleIcon />
                                                </IconButton>
                                            </Tooltip>
                                            <Tooltip title="Reject">
                                                <IconButton
                                                    color="error"
                                                    onClick={() => handleResolve(item.id, 'REJECT')}
                                                >
                                                    <CancelIcon />
                                                </IconButton>
                                            </Tooltip>
                                        </TableCell>
                                    </TableRow>
                                ))
                            )}
                        </TableBody>
                    </Table>
                </TableContainer>
            ) : (
                <TableContainer component={Paper}>
                    <Table>
                        <TableHead>
                            <TableRow>
                                <TableCell>Name</TableCell>
                                <TableCell>Email</TableCell>
                                <TableCell>Role</TableCell>
                                <TableCell>Status</TableCell>
                                <TableCell>Actions</TableCell>
                            </TableRow>
                        </TableHead>
                        <TableBody>
                            {users.length === 0 ? (
                                <TableRow>
                                    <TableCell colSpan={5} align="center">
                                        No users found
                                    </TableCell>
                                </TableRow>
                            ) : (
                                users.map((user) => (
                                    <TableRow key={user.id}>
                                        <TableCell>{user.name}</TableCell>
                                        <TableCell>{user.email}</TableCell>
                                        <TableCell>
                                            <Chip
                                                label={user.role}
                                                size="small"
                                                color={user.role === 'ADMIN' ? 'primary' : 'default'}
                                            />
                                        </TableCell>
                                        <TableCell>
                                            <Chip
                                                label={user.isBanned ? 'Banned' : 'Active'}
                                                size="small"
                                                color={user.isBanned ? 'error' : 'success'}
                                            />
                                        </TableCell>
                                        <TableCell>
                                            {!user.isBanned && user.role !== 'ADMIN' && (
                                                <Button
                                                    variant="outlined"
                                                    color="error"
                                                    size="small"
                                                    startIcon={<BlockIcon />}
                                                    onClick={() => handleBan(user.id)}
                                                >
                                                    Ban
                                                </Button>
                                            )}
                                        </TableCell>
                                    </TableRow>
                                ))
                            )}
                        </TableBody>
                    </Table>
                </TableContainer>
            )}
        </Box>
    );
};

export default AdminDashboard;

</code>

## segfault-frontend\src\pages\AuthCallback\AuthCallback.tsx
<code>
import { useEffect, useState, useRef } from 'react';
import { useNavigate, useSearchParams } from 'react-router-dom';
import { Box, CircularProgress, Typography, Alert } from '@mui/material';

const AuthCallback = () => {
  const navigate = useNavigate();
  const [searchParams] = useSearchParams();
  const [error, setError] = useState<string | null>(null);
  const processedRef = useRef(false);

  useEffect(() => {
    // Prevent running multiple times (React StrictMode or re-renders)
    if (processedRef.current) return;
    processedRef.current = true;

    const token = searchParams.get('token');
    const errorParam = searchParams.get('error');

    if (errorParam) {
      setError(decodeURIComponent(errorParam));
      setTimeout(() => navigate('/login'), 3000);
      return;
    }

    if (token) {
      // Store the token directly in localStorage to avoid dependency on login
      localStorage.setItem('authToken', token);
      // Force a page navigation which will reinitialize auth state
      window.location.href = '/dashboard';
    } else {
      setError('No authentication token received');
      setTimeout(() => navigate('/login'), 3000);
    }
  }, []); // Empty dependency array - run only once on mount

  if (error) {
    return (
      <Box
        sx={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          gap: 2,
        }}
      >
        <Alert severity="error">{error}</Alert>
        <Typography variant="body2" color="text.secondary">
          Redirecting to login...
        </Typography>
      </Box>
    );
  }

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: 2,
      }}
    >
      <CircularProgress />
      <Typography variant="body1">Processing login...</Typography>
    </Box>
  );
};

export default AuthCallback;

</code>

## segfault-frontend\src\pages\Dashboard\Dashboard.tsx
<code>
import { useState } from 'react';
import { Box, Tabs, Tab, Fab } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import MapIcon from '@mui/icons-material/Map';
import BarChartIcon from '@mui/icons-material/BarChart';
import ListAltIcon from '@mui/icons-material/ListAlt';
import DashboardLayout from '../../components/Dashboard/DashboardLayout';
import type { FilterState } from '../../components/Dashboard/DashboardLayout';
import MapInterface from '../../components/Dashboard/MapInterface';
import DashboardView from '../../components/Dashboard/DashboardView';
import IssuesList from '../../components/Dashboard/IssuesList';
import IssueReportForm from '../../components/Dashboard/IssueReportForm';
import IssueDetailPage from '../../components/Dashboard/IssueDetailPage';

const Dashboard = () => {
    const [activeTab, setActiveTab] = useState(0);
    const [reportFormOpen, setReportFormOpen] = useState(false);
    const [detailDrawerOpen, setDetailDrawerOpen] = useState(false);
    const [selectedIssueId, setSelectedIssueId] = useState<string | null>(null);

    const [filters, setFilters] = useState<FilterState>({
        issueType: '',
        statusOpen: true,
        statusInProgress: true,
        urgency: '',
        showResolved: false,
    });

    const handleFilterChange = (newFilters: Partial<FilterState>) => {
        setFilters((prev) => ({ ...prev, ...newFilters }));
    };

    const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {
        setActiveTab(newValue);
    };

    const handlePinClick = (issueId: string) => {
        setSelectedIssueId(issueId);
        setDetailDrawerOpen(true);
    };

    const handleDetailClose = () => {
        setDetailDrawerOpen(false);
        setSelectedIssueId(null);
    };

    const [showRouting, setShowRouting] = useState(false);

    const handleToggleRouting = () => {
        setShowRouting(!showRouting);
        // If we are opening routing, ensure we are on the map tab
        if (!showRouting && activeTab !== 0) {
            setActiveTab(0);
        }
    };

    return (
        <DashboardLayout
            onIssueClick={handlePinClick}
            filters={filters}
            onFilterChange={handleFilterChange}
            showRouting={showRouting}
            onToggleRouting={handleToggleRouting}
        >
            <Box sx={{ mb: 3 }}>
                <Tabs
                    value={activeTab}
                    onChange={handleTabChange}
                    sx={{
                        backgroundColor: 'rgba(255, 255, 255, 0.03)',
                        borderRadius: 3,
                        p: 0.5,
                        border: '1px solid rgba(255, 255, 255, 0.05)',
                        '& .MuiTabs-indicator': {
                            height: '100%',
                            borderRadius: 2,
                            zIndex: 0,
                            backgroundColor: 'rgba(124, 58, 237, 0.2)', // Violet tint
                        },
                        '& .MuiTab-root': {
                            zIndex: 1,
                            minHeight: 48,
                            textTransform: 'none',
                            fontWeight: 600,
                            color: '#94a3b8',
                            '&.Mui-selected': {
                                color: '#f8fafc',
                            },
                        },
                    }}
                >
                    <Tab
                        icon={<MapIcon sx={{ mr: 1 }} />}
                        iconPosition="start"
                        label="Map"
                    />
                    <Tab
                        icon={<ListAltIcon sx={{ mr: 1 }} />}
                        iconPosition="start"
                        label="List"
                    />
                    <Tab
                        icon={<BarChartIcon sx={{ mr: 1 }} />}
                        iconPosition="start"
                        label="Analytics"
                    />
                </Tabs>
            </Box>

            {activeTab === 0 && (
                <MapInterface
                    onPinClick={handlePinClick}
                    filters={filters}
                    showRouting={showRouting}
                    onToggleRouting={setShowRouting}
                />
            )}
            {activeTab === 1 && <IssuesList onIssueClick={handlePinClick} />}
            {activeTab === 2 && <DashboardView />}

            <Fab
                color="primary"
                aria-label="add issue"
                onClick={() => setReportFormOpen(true)}
                sx={{
                    position: 'fixed',
                    bottom: 24,
                    right: 24,
                    width: 64,
                    height: 64,
                    boxShadow: '0 4px 20px rgba(25, 118, 210, 0.4)',
                    '&:hover': {
                        boxShadow: '0 6px 24px rgba(25, 118, 210, 0.5)',
                        transform: 'scale(1.05)',
                    },
                    transition: 'all 0.2s ease',
                }}
            >
                <AddIcon sx={{ fontSize: 32 }} />
            </Fab>

            <IssueReportForm
                open={reportFormOpen}
                onClose={() => setReportFormOpen(false)}
            />

            <IssueDetailPage
                open={detailDrawerOpen}
                onClose={handleDetailClose}
                issueId={selectedIssueId}
            />
        </DashboardLayout>
    );
};

export default Dashboard;

</code>

## segfault-frontend\src\pages\Landing\Landing.tsx
<code>
import React from 'react';
import { useNavigate } from 'react-router-dom';
import {
    Box,
    Button,
    Container,
    Typography,
    Stack,
    Paper,
    useMediaQuery,
    useTheme,
    Chip
} from '@mui/material';
import Grid from '@mui/material/Unstable_Grid2';
import {
    Map as MapIcon,
    Security as SecurityIcon,
    TrendingUp as TrendingUpIcon,
    ArrowForward as ArrowIcon,
    EmojiEvents as TrophyIcon,
    Public as PublicIcon
} from '@mui/icons-material';

const Landing = () => {
    const navigate = useNavigate();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('md'));

    const handleLogin = () => navigate('/login');
    const handleGuest = () => navigate('/dashboard');

    return (
        <Box
            sx={{
                minHeight: '100vh',
                width: '100%',
                bgcolor: '#020617',
                color: '#f8fafc',
                overflowX: 'hidden',
                position: 'relative',
                fontFamily: '"Geist Mono", "Inter", sans-serif',
            }}
        >
            <Box sx={{
                position: 'absolute',
                inset: 0,
                backgroundImage: `
          linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px)
        `,
                backgroundSize: '32px 32px',
                maskImage: 'linear-gradient(to bottom, black 40%, transparent 100%)',
                zIndex: 0,
            }} />

            <Box sx={{
                position: 'absolute',
                top: '-15%',
                right: '-5%',
                width: '40vw',
                height: '40vw',
                background: 'radial-gradient(circle, rgba(124, 58, 237, 0.08) 0%, rgba(0,0,0,0) 70%)', // Violet glow
                filter: 'blur(80px)',
                zIndex: 0,
                pointerEvents: 'none'
            }} />
            <Box sx={{
                position: 'absolute',
                bottom: '-10%',
                left: '-10%',
                width: '50vw',
                height: '50vw',
                background: 'radial-gradient(circle, rgba(13, 148, 136, 0.06) 0%, rgba(0,0,0,0) 70%)', // Teal glow
                filter: 'blur(80px)',
                zIndex: 0,
                pointerEvents: 'none'
            }} />

            <Container maxWidth="lg" sx={{ position: 'relative', zIndex: 1, pt: 3, pb: 8 }}>

                <Stack direction="row" justifyContent="space-between" alignItems="center" sx={{ mb: { xs: 8, md: 12 } }}>
                    <Stack direction="row" alignItems="center" spacing={1.5}>
                        <Box sx={{
                            color: '#a78bfa',
                            bgcolor: 'rgba(167, 139, 250, 0.1)',
                            p: 0.5,
                            borderRadius: 1,
                            display: 'flex'
                        }}>
                            <PublicIcon fontSize="small" />
                        </Box>
                        <Typography variant="h6" sx={{ fontWeight: 600, letterSpacing: -0.5, color: '#f1f5f9' }}>
                            Segfault<Box component="span" sx={{ color: '#64748b', fontWeight: 400 }}>IssueTracker</Box>
                        </Typography>
                    </Stack>
                    <Button
                        variant="text"
                        onClick={handleLogin}
                        sx={{
                            color: '#94a3b8',
                            textTransform: 'none',
                            fontWeight: 500,
                            fontSize: '0.95rem',
                            '&:hover': { color: '#f8fafc', bgcolor: 'transparent' }
                        }}
                    >
                        Log in
                    </Button>
                </Stack>

                <Grid container spacing={{ xs: 6, md: 4 }} alignItems="center">
                    <Grid xs={12} md={7}>
                        <Box sx={{ mb: 3 }}>
                            <Chip
                                label="v1.0 Public Beta"
                                size="small"
                                sx={{
                                    bgcolor: 'rgba(124, 58, 237, 0.1)',
                                    color: '#a78bfa',
                                    border: '1px solid rgba(124, 58, 237, 0.2)',
                                    fontWeight: 600,
                                    fontSize: '0.75rem',
                                    height: 24
                                }}
                            />
                        </Box>

                        <Typography
                            variant={isMobile ? "h3" : "h1"}
                            sx={{
                                fontWeight: 800,
                                mb: 3,
                                lineHeight: 1.1,
                                letterSpacing: -1.5,
                                background: 'linear-gradient(to right bottom, #ffffff, #cbd5e1)',
                                WebkitBackgroundClip: 'text',
                                WebkitTextFillColor: 'transparent',
                                fontSize: { xs: '2.5rem', md: '4rem' }
                            }}
                        >
                            Resolve civic issues <br />
                            with full transparency.
                        </Typography>

                        <Typography variant="h6" sx={{ color: '#94a3b8', mb: 5, maxWidth: '540px', fontWeight: 400, lineHeight: 1.6, fontSize: '1.125rem' }}>
                            A decentralized, AI-moderated platform for crowd-sourced civic issue tracking.
                            Report hazards, verify fixes, and earn reputation on the chain.
                        </Typography>

                        <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2}>
                            <Button
                                variant="contained"
                                size="large"
                                onClick={handleLogin}
                                sx={{
                                    bgcolor: '#f8fafc',
                                    color: '#0f172a',
                                    px: 3,
                                    py: 1.5,
                                    fontWeight: 600,
                                    fontSize: '0.95rem',
                                    textTransform: 'none',
                                    borderRadius: 2,
                                    boxShadow: '0 0 0 1px rgba(255,255,255,0.1)',
                                    transition: 'all 0.2s',
                                    '&:hover': {
                                        bgcolor: '#e2e8f0',
                                        transform: 'translateY(-1px)',
                                        boxShadow: '0 4px 12px rgba(255,255,255,0.1)'
                                    }
                                }}
                                endIcon={<ArrowIcon />}
                            >
                                Start Reporting
                            </Button>
                            <Button
                                variant="outlined"
                                size="large"
                                onClick={handleGuest}
                                sx={{
                                    borderColor: '#334155',
                                    color: '#cbd5e1',
                                    px: 3,
                                    py: 1.5,
                                    fontWeight: 500,
                                    fontSize: '0.95rem',
                                    textTransform: 'none',
                                    borderRadius: 2,
                                    backdropFilter: 'blur(8px)',
                                    '&:hover': {
                                        borderColor: '#94a3b8',
                                        color: '#f8fafc',
                                        bgcolor: 'rgba(255,255,255,0.03)'
                                    }
                                }}
                            >
                                Explore Map
                            </Button>
                        </Stack>
                    </Grid>

                    <Grid xs={12} md={5} sx={{ display: { xs: 'none', md: 'block' }, position: 'relative' }}>
                        <Box
                            sx={{
                                height: '500px',
                                width: '100%',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                perspective: '1000px'
                            }}
                        >
                            <Paper
                                elevation={24}
                                sx={{
                                    position: 'absolute',
                                    top: 60,
                                    right: 30,
                                    width: 280,
                                    p: 3,
                                    bgcolor: 'rgba(15, 23, 42, 0.6)',
                                    backdropFilter: 'blur(16px)',
                                    border: '1px solid rgba(255,255,255,0.08)',
                                    borderRadius: 3,
                                    transform: 'rotate(3deg) translateZ(20px)',
                                    zIndex: 2,
                                    boxShadow: '0 20px 40px -10px rgba(0,0,0,0.5)'
                                }}
                            >
                                <Stack direction="row" alignItems="center" justifyContent="space-between" mb={2}>
                                    <Chip label="High Severity" size="small" sx={{ bgcolor: 'rgba(239, 68, 68, 0.2)', color: '#f87171', fontSize: '0.7rem', height: 20, border: '1px solid rgba(239, 68, 68, 0.2)' }} />
                                    <Typography variant="caption" sx={{ fontFamily: 'monospace', color: '#64748b' }}>#4092</Typography>
                                </Stack>
                                <Typography variant="subtitle1" fontWeight={600} gutterBottom>Structural Damage</Typography>
                                <Stack direction="row" spacing={1} sx={{ mb: 2 }}>
                                    <Box sx={{ width: 4, borderRadius: 4, bgcolor: '#ef4444' }} />
                                    <Typography variant="body2" color="#94a3b8" sx={{ fontSize: '0.85rem' }}>
                                        Reported on Main St. <br />
                                        AI Verification: 98%
                                    </Typography>
                                </Stack>
                                <Box sx={{ width: '100%', height: 4, bgcolor: 'rgba(255,255,255,0.1)', borderRadius: 2, overflow: 'hidden' }}>
                                    <Box sx={{ width: '75%', height: '100%', bgcolor: '#ef4444' }} />
                                </Box>
                            </Paper>

                            <Paper
                                elevation={4}
                                sx={{
                                    position: 'absolute',
                                    bottom: 60,
                                    left: 30,
                                    width: 260,
                                    p: 3,
                                    bgcolor: 'rgba(15, 23, 42, 0.4)',
                                    backdropFilter: 'blur(12px)',
                                    border: '1px solid rgba(255,255,255,0.05)',
                                    borderRadius: 3,
                                    transform: 'rotate(-4deg)',
                                    zIndex: 1,
                                    boxShadow: '0 20px 40px -10px rgba(0,0,0,0.5)'
                                }}
                            >
                                <Stack direction="row" alignItems="center" spacing={1.5} mb={2}>
                                    <Box sx={{ p: 0.5, bgcolor: 'rgba(16, 185, 129, 0.1)', borderRadius: '50%', color: '#34d399' }}>
                                        <SecurityIcon sx={{ fontSize: 16 }} />
                                    </Box>
                                    <Typography variant="caption" sx={{ color: '#94a3b8', fontWeight: 600, letterSpacing: 0.5 }}>STATUS: SECURE</Typography>
                                </Stack>
                                <Typography variant="h4" fontWeight={700} sx={{ color: '#f8fafc' }}>1,284</Typography>
                                <Typography variant="body2" sx={{ color: '#64748b' }}>Verified resolutions this week</Typography>
                            </Paper>
                        </Box>
                    </Grid>
                </Grid>

                <Grid container spacing={3} sx={{ mt: { xs: 8, md: 16 } }}>
                    <FeatureCard
                        icon={<MapIcon sx={{ fontSize: 24, color: '#38bdf8' }} />}
                        title="Real-time Mapping"
                        desc="Interactive vector maps with live clustering and WebGL rendering for massive datasets."
                    />
                    <FeatureCard
                        icon={<SecurityIcon sx={{ fontSize: 24, color: '#f472b6' }} />}
                        title="AI Moderation"
                        desc="Automated image analysis pipeline using Google Gemini to filter spam and verify reports."
                    />
                    <FeatureCard
                        icon={<TrendingUpIcon sx={{ fontSize: 24, color: '#34d399' }} />}
                        title="Shortest Path"
                        desc="Hazard-aware routing engine that calculates safety scores for every street segment."
                    />
                    <FeatureCard
                        icon={<TrophyIcon sx={{ fontSize: 24, color: '#fbbf24' }} />}
                        title="The Reputation Game"
                        desc="Gamified contribution system. Earn badges and voting power by improving your city."
                    />
                </Grid>

                {/* <Box sx={{ mt: 16, pt: 8, borderTop: '1px solid rgba(255,255,255,0.05)', display: 'flex', justifyContent: 'space-between', flexWrap: 'wrap', gap: 2 }}>
                    <Typography variant="caption" sx={{ color: '#475569' }}>
                         2025 Segfault Inc. Open Source.
                    </Typography>
                    <Stack direction="row" spacing={3}>
                        {['Privacy', 'Terms', 'GitHub', 'Contact'].map((item) => (
                            <Typography key={item} variant="caption" sx={{ color: '#64748b', cursor: 'pointer', '&:hover': { color: '#94a3b8' } }}>
                                {item}
                            </Typography>
                        ))}
                    </Stack>
                </Box> */}

            </Container>
        </Box>
    );
};

const FeatureCard = ({ icon, title, desc }: { icon: React.ReactNode, title: string, desc: string }) => (
    <Grid xs={12} sm={6} md={3}>
        <Paper
            elevation={0}
            sx={{
                p: 3,
                height: '100%',
                bgcolor: 'transparent',
                border: '1px solid rgba(255, 255, 255, 0.05)',
                borderRadius: 2,
                transition: 'all 0.3s ease',
                '&:hover': {
                    bgcolor: 'rgba(255, 255, 255, 0.02)',
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    transform: 'translateY(-2px)'
                }
            }}
        >
            <Box sx={{
                mb: 2,
                width: 48,
                height: 48,
                bgcolor: 'rgba(255,255,255,0.03)',
                borderRadius: 1.5,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                border: '1px solid rgba(255,255,255,0.05)'
            }}>
                {icon}
            </Box>
            <Typography variant="subtitle1" sx={{ fontWeight: 600, mb: 1, color: '#f1f5f9' }}>{title}</Typography>
            <Typography variant="body2" sx={{ color: '#64748b', lineHeight: 1.6 }}>{desc}</Typography>
        </Paper>
    </Grid>
);

export default Landing;
</code>

## segfault-frontend\src\pages\Login\Login.css
<code>

</code>

## segfault-frontend\src\pages\Login\Login.tsx
<code>
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
    Box,
    Button,
    Container,
    Divider,
    IconButton,
    InputAdornment,
    Link,
    TextField,
    Typography,
    Alert,
    CircularProgress,
    Paper,
    Stack,
    Fade
} from '@mui/material';
import {
    Visibility,
    VisibilityOff,
    Google as GoogleIcon,
    PersonOutline as GuestIcon,
    ArrowBack as ArrowBackIcon,
    MarkEmailRead as EmailIcon
} from '@mui/icons-material';
import { authAPI } from '../../api/axios';
import { AxiosError } from 'axios';
import { useAuth } from '../../state/authContext';
import { AZURE_BACKEND_URL } from '../../constants';

const Login = () => {
    const navigate = useNavigate();
    const { login } = useAuth();
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [showPassword, setShowPassword] = useState(false);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    // 2FA State
    const [step, setStep] = useState<'login' | '2fa'>('login');
    const [userId, setUserId] = useState<number | null>(null);
    const [twoFaCode, setTwoFaCode] = useState('');

    const handleEmailLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        setError(null);

        try {
            const result = await authAPI.login(email, password);

            if (result.require2fa) {
                setUserId(result.userId);
                setStep('2fa');
            } else if (result.token) {
                localStorage.setItem('authToken', result.token);
                login(result.token);
                navigate('/dashboard');
            }
        } catch (err) {
            let errorMsg = 'Login failed. Please try again.';
            if (err instanceof AxiosError && err.response?.data && typeof err.response.data === 'object' && 'error' in err.response.data) {
                errorMsg = (err.response.data as { error?: string }).error || errorMsg;
            }
            setError(errorMsg);
        } finally {
            setLoading(false);
        }
    };

    const handleVerify2FA = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!userId || !twoFaCode) return;

        setLoading(true);
        setError(null);

        try {
            const result = await authAPI.verify2FA(userId, twoFaCode);
            if (result.token) {
                localStorage.setItem('authToken', result.token);
                login(result.token);
                navigate('/dashboard');
            }
        } catch (err) {
            let errorMsg = 'Verification failed. Invalid code.';
            if (err instanceof AxiosError && err.response?.data && typeof err.response.data === 'object' && 'error' in err.response.data) {
                errorMsg = (err.response.data as { error?: string }).error || errorMsg;
            }
            setError(errorMsg);
        } finally {
            setLoading(false);
        }
    };

    const handleGoogleLogin = () => {
        const clientId = import.meta.env.VITE_GOOGLE_CLIENT_ID;
        const redirectUri = `${AZURE_BACKEND_URL}/auth/callback`;
        const scope = 'openid email profile';

        const googleAuthUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=${encodeURIComponent(scope)}&access_type=offline&prompt=consent`;

        window.location.href = googleAuthUrl;
    };

    const handleGuestLogin = async () => {
        setLoading(true);
        setError(null);

        try {
            const response = await authAPI.loginAsGuest();
            if (response.ok && response.token) {
                localStorage.setItem('authToken', response.token);
                localStorage.setItem('guestTokenId', response.guestTokenId);
                login(response.token);
                navigate('/dashboard');
            }
        } catch (err) {
            let errorMsg = 'Guest login failed. Please try again.';
            if (err instanceof AxiosError && err.response?.data && typeof err.response.data === 'object' && 'error' in err.response.data) {
                errorMsg = (err.response.data as { error?: string }).error || errorMsg;
            }
            setError(errorMsg);
        } finally {
            setLoading(false);
        }
    };

    // Custom TextField Styles for Dark Mode
    const textFieldSx = {
        mb: 2,
        '& .MuiOutlinedInput-root': {
            bgcolor: 'rgba(255, 255, 255, 0.03)',
            color: '#f8fafc',
            fontFamily: '"Geist Mono", monospace',
            fontSize: '0.9rem',
            '& fieldset': {
                borderColor: 'rgba(255, 255, 255, 0.1)',
            },
            '&:hover fieldset': {
                borderColor: 'rgba(255, 255, 255, 0.2)',
            },
            '&.Mui-focused fieldset': {
                borderColor: '#a78bfa',
            },
        },
        '& .MuiInputLabel-root': {
            color: '#64748b',
            '&.Mui-focused': {
                color: '#a78bfa',
            },
        },
        '& .MuiInputAdornment-root .MuiIconButton-root': {
            color: '#64748b',
        },
    };

    return (
        <Box
            sx={{
                minHeight: '100vh',
                width: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                bgcolor: '#020617',
                color: '#f8fafc',
                position: 'relative',
                overflow: 'hidden',
                fontFamily: '"Geist Mono", "Inter", sans-serif',
            }}
        >
            {/* Background Grid Pattern */}
            <Box sx={{
                position: 'absolute',
                inset: 0,
                backgroundImage: `
          linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px)
        `,
                backgroundSize: '32px 32px',
                maskImage: 'linear-gradient(to bottom, black 40%, transparent 100%)',
                zIndex: 0,
            }} />

            {/* Ambient Glow */}
            <Box sx={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: '100vw',
                height: '100vh',
                background: 'radial-gradient(circle at center, rgba(124, 58, 237, 0.05) 0%, rgba(0,0,0,0) 60%)',
                zIndex: 0,
                pointerEvents: 'none'
            }} />

            <Container maxWidth="xs" sx={{ position: 'relative', zIndex: 1 }}>
                <Fade in={true} timeout={600}>
                    <Box>
                        <Paper
                            elevation={0}
                            sx={{
                                p: 4,
                                bgcolor: 'rgba(15, 23, 42, 0.6)',
                                backdropFilter: 'blur(20px)',
                                border: '1px solid rgba(255,255,255,0.08)',
                                borderRadius: 3,
                                boxShadow: '0 25px 50px -12px rgba(0, 0, 0, 0.5)'
                            }}
                        >
                            {step === 'login' ? (
                                <>
                                    <Box sx={{ textAlign: 'center', mb: 4 }}>
                                        <Box
                                            sx={{
                                                display: 'inline-flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                width: 48,
                                                height: 48,
                                                borderRadius: 2,
                                                bgcolor: 'rgba(124, 58, 237, 0.1)',
                                                color: '#a78bfa',
                                                mb: 2
                                            }}
                                        >
                                            <GuestIcon fontSize="medium" />
                                        </Box>
                                        <Typography variant="h5" component="h1" fontWeight={700} sx={{ color: '#f8fafc', mb: 1 }}>
                                            Welcome back
                                        </Typography>
                                        <Typography variant="body2" sx={{ color: '#94a3b8' }}>
                                            Enter your credentials to access the terminal
                                        </Typography>
                                    </Box>

                                    {error && (
                                        <Alert
                                            severity="error"
                                            sx={{
                                                mb: 3,
                                                bgcolor: 'rgba(239, 68, 68, 0.1)',
                                                color: '#fca5a5',
                                                border: '1px solid rgba(239, 68, 68, 0.2)',
                                                '& .MuiAlert-icon': { color: '#fca5a5' }
                                            }}
                                            onClose={() => setError(null)}
                                        >
                                            {error}
                                        </Alert>
                                    )}

                                    <Box component="form" onSubmit={handleEmailLogin}>
                                        <TextField
                                            label="Email Address"
                                            type="email"
                                            value={email}
                                            onChange={(e) => setEmail(e.target.value)}
                                            required
                                            fullWidth
                                            autoComplete="email"
                                            autoFocus
                                            sx={textFieldSx}
                                        />
                                        <TextField
                                            label="Password"
                                            type={showPassword ? 'text' : 'password'}
                                            value={password}
                                            onChange={(e) => setPassword(e.target.value)}
                                            required
                                            fullWidth
                                            autoComplete="current-password"
                                            sx={{ ...textFieldSx, mb: 3 }}
                                            InputProps={{
                                                endAdornment: (
                                                    <InputAdornment position="end">
                                                        <IconButton
                                                            aria-label="toggle password visibility"
                                                            onClick={() => setShowPassword(!showPassword)}
                                                            edge="end"
                                                            sx={{ color: '#64748b' }}
                                                        >
                                                            {showPassword ? <VisibilityOff /> : <Visibility />}
                                                        </IconButton>
                                                    </InputAdornment>
                                                ),
                                            }}
                                        />
                                        <Button
                                            type="submit"
                                            variant="contained"
                                            fullWidth
                                            size="large"
                                            disabled={loading}
                                            sx={{
                                                mb: 2,
                                                py: 1.5,
                                                bgcolor: '#f8fafc',
                                                color: '#020617',
                                                fontWeight: 600,
                                                textTransform: 'none',
                                                fontSize: '0.95rem',
                                                '&:hover': {
                                                    bgcolor: '#e2e8f0',
                                                }
                                            }}
                                        >
                                            {loading ? <CircularProgress size={24} color="inherit" /> : 'Sign In'}
                                        </Button>
                                    </Box>

                                    <Stack direction="row" justifyContent="center" sx={{ mb: 3 }}>
                                        <Link
                                            href="/forgot-password"
                                            underline="hover"
                                            sx={{ color: '#a78bfa', fontSize: '0.875rem', cursor: 'pointer' }}
                                        >
                                            Forgot Password?
                                        </Link>
                                    </Stack>

                                    <Divider sx={{ my: 3, borderColor: 'rgba(255,255,255,0.1)' }}>
                                        <Typography variant="caption" sx={{ color: '#64748b' }}>
                                            OR CONTINUE WITH
                                        </Typography>
                                    </Divider>

                                    <Stack spacing={2}>
                                        <Button
                                            variant="outlined"
                                            fullWidth
                                            size="large"
                                            onClick={handleGoogleLogin}
                                            disabled={loading}
                                            startIcon={<GoogleIcon />}
                                            sx={{
                                                py: 1.25,
                                                borderColor: 'rgba(255,255,255,0.1)',
                                                color: '#cbd5e1',
                                                textTransform: 'none',
                                                '&:hover': {
                                                    borderColor: '#94a3b8',
                                                    bgcolor: 'rgba(255,255,255,0.03)',
                                                    color: '#f8fafc'
                                                },
                                            }}
                                        >
                                            Google
                                        </Button>

                                        <Button
                                            variant="outlined"
                                            fullWidth
                                            size="large"
                                            onClick={handleGuestLogin}
                                            disabled={loading}
                                            startIcon={<GuestIcon />}
                                            sx={{
                                                py: 1.25,
                                                borderColor: 'rgba(255,255,255,0.1)',
                                                color: '#cbd5e1',
                                                textTransform: 'none',
                                                '&:hover': {
                                                    borderColor: '#94a3b8',
                                                    bgcolor: 'rgba(255,255,255,0.03)',
                                                    color: '#f8fafc'
                                                },
                                            }}
                                        >
                                            Guest Access
                                        </Button>
                                    </Stack>

                                    <Box sx={{ textAlign: 'center', mt: 4 }}>
                                        <Typography variant="body2" sx={{ color: '#64748b' }}>
                                            Don't have an account?{' '}
                                            <Link
                                                href="/register"
                                                underline="hover"
                                                sx={{ color: '#a78bfa', fontWeight: 600, cursor: 'pointer' }}
                                            >
                                                Register
                                            </Link>
                                        </Typography>
                                    </Box>
                                </>
                            ) : (
                                // 2FA Step
                                <>
                                    <Box sx={{ textAlign: 'center', mb: 4 }}>
                                        <Box
                                            sx={{
                                                display: 'inline-flex',
                                                alignItems: 'center',
                                                justifyContent: 'center',
                                                width: 56,
                                                height: 56,
                                                borderRadius: '50%',
                                                bgcolor: 'rgba(16, 185, 129, 0.1)',
                                                color: '#10b981',
                                                mb: 3
                                            }}
                                        >
                                            <EmailIcon fontSize="large" />
                                        </Box>
                                        <Typography variant="h5" component="h1" fontWeight={700} sx={{ color: '#f8fafc', mb: 1 }}>
                                            Verify Email
                                        </Typography>
                                        <Typography variant="body2" sx={{ color: '#94a3b8' }}>
                                            We sent a 6-digit code to <br />
                                            <Box component="span" sx={{ color: '#f1f5f9', fontWeight: 600 }}>{email}</Box>
                                        </Typography>
                                    </Box>

                                    {error && (
                                        <Alert
                                            severity="error"
                                            sx={{
                                                mb: 3,
                                                bgcolor: 'rgba(239, 68, 68, 0.1)',
                                                color: '#fca5a5',
                                                border: '1px solid rgba(239, 68, 68, 0.2)',
                                                '& .MuiAlert-icon': { color: '#fca5a5' }
                                            }}
                                            onClose={() => setError(null)}
                                        >
                                            {error}
                                        </Alert>
                                    )}

                                    <Box component="form" onSubmit={handleVerify2FA}>
                                        <TextField
                                            label="Verification Code"
                                            type="text"
                                            value={twoFaCode}
                                            onChange={(e) => setTwoFaCode(e.target.value.replace(/\D/g, '').slice(0, 6))}
                                            required
                                            fullWidth
                                            autoFocus
                                            placeholder="123456"
                                            sx={{
                                                ...textFieldSx,
                                                '& input': {
                                                    textAlign: 'center',
                                                    letterSpacing: '0.5em',
                                                    fontWeight: 700,
                                                    fontSize: '1.25rem'
                                                }
                                            }}
                                        />

                                        <Button
                                            type="submit"
                                            variant="contained"
                                            fullWidth
                                            size="large"
                                            disabled={loading}
                                            sx={{
                                                mb: 3,
                                                py: 1.5,
                                                mt: 2,
                                                bgcolor: '#10b981',
                                                color: '#020617',
                                                fontWeight: 600,
                                                textTransform: 'none',
                                                fontSize: '0.95rem',
                                                '&:hover': {
                                                    bgcolor: '#059669',
                                                }
                                            }}
                                        >
                                            {loading ? <CircularProgress size={24} color="inherit" /> : 'Verify & Login'}
                                        </Button>
                                    </Box>

                                    <Box sx={{ textAlign: 'center' }}>
                                        <Button
                                            onClick={() => setStep('login')}
                                            sx={{
                                                color: '#64748b',
                                                textTransform: 'none',
                                                '&:hover': { color: '#94a3b8', bgcolor: 'transparent' }
                                            }}
                                        >
                                            Cancel
                                        </Button>
                                    </Box>
                                </>
                            )}
                        </Paper>

                        <Box sx={{ textAlign: 'center', mt: 4 }}>
                            <Button
                                startIcon={<ArrowBackIcon />}
                                onClick={() => navigate('/')}
                                sx={{
                                    color: '#64748b',
                                    textTransform: 'none',
                                    '&:hover': { color: '#94a3b8', bgcolor: 'transparent' }
                                }}
                            >
                                Back to Home
                            </Button>
                        </Box>
                    </Box>
                </Fade>
            </Container>
        </Box>
    );
};

export default Login;


</code>

## segfault-frontend\src\pages\Register\Register.tsx
<code>
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Button,
  Card,
  CardContent,
  Container,
  IconButton,
  InputAdornment,
  Link,
  TextField,
  Typography,
  Alert,
  CircularProgress,
} from '@mui/material';
import {
  Visibility,
  VisibilityOff,
} from '@mui/icons-material';
import { authAPI } from '../../api/axios';
import { AxiosError } from 'axios';
import { useAuth } from '../../state/authContext';

const Register = () => {
  const navigate = useNavigate();
  const { login } = useAuth();
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleRegister = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);

    if (password !== confirmPassword) {
      setError('Passwords do not match');
      setLoading(false);
      return;
    }

    if (password.length < 6) {
      setError('Password must be at least 6 characters');
      setLoading(false);
      return;
    }

    try {
      const result = await authAPI.register(email, password, name || undefined);
      if (result.token) {
        localStorage.setItem('authToken', result.token);
        login(result.token);
      }
      navigate('/dashboard');
    } catch (err) {
      let errorMsg = 'Registration failed. Please try again.';
      if (err instanceof AxiosError && err.response?.data && typeof err.response.data === 'object' && 'error' in err.response.data) {
        errorMsg = (err.response.data as { error?: string }).error || errorMsg;
      }
      setError(errorMsg);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: 'grey.100',
        py: 4,
        px: 2,
      }}
    >
      <Container maxWidth="sm">
        <Card elevation={3} sx={{ borderRadius: 3 }}>
          <CardContent sx={{ p: { xs: 3, sm: 4 } }}>
            
            <Box sx={{ textAlign: 'center', mb: 4 }}>
              <Typography variant="h4" component="h1" fontWeight={700} gutterBottom>
                Create Account
              </Typography>
              <Typography variant="body1" color="text.secondary">
                Join us to report and track civic issues
              </Typography>
            </Box>

            {error && (
              <Alert severity="error" sx={{ mb: 3 }} onClose={() => setError(null)}>
                {error}
              </Alert>
            )}

            <Box component="form" onSubmit={handleRegister}>
              <TextField
                label="Name (optional)"
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                fullWidth
                sx={{ mb: 2 }}
                autoComplete="name"
              />
              <TextField
                label="Email Address"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                fullWidth
                sx={{ mb: 2 }}
                autoComplete="email"
              />
              <TextField
                label="Password"
                type={showPassword ? 'text' : 'password'}
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                fullWidth
                sx={{ mb: 2 }}
                autoComplete="new-password"
                InputProps={{
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        aria-label="toggle password visibility"
                        onClick={() => setShowPassword(!showPassword)}
                        edge="end"
                      >
                        {showPassword ? <VisibilityOff /> : <Visibility />}
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
              <TextField
                label="Confirm Password"
                type={showPassword ? 'text' : 'password'}
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                fullWidth
                sx={{ mb: 3 }}
                autoComplete="new-password"
              />
              <Button
                type="submit"
                variant="contained"
                color="primary"
                fullWidth
                size="large"
                disabled={loading}
                sx={{ mb: 2, py: 1.5 }}
              >
                {loading ? <CircularProgress size={24} color="inherit" /> : 'Create Account'}
              </Button>
            </Box>

            <Box sx={{ textAlign: 'center', mt: 3 }}>
              <Typography variant="body2" color="text.secondary">
                Already have an account?{' '}
                <Link
                  href="/login"
                  underline="hover"
                  color="primary"
                  fontWeight={600}
                  sx={{ cursor: 'pointer' }}
                >
                  Sign In
                </Link>
              </Typography>
            </Box>
          </CardContent>
        </Card>

        <Box sx={{ textAlign: 'center', mt: 3 }}>
          <Link
            component="button"
            variant="body2"
            onClick={() => navigate('/')}
            underline="hover"
            color="text.secondary"
          >
             Back to Home
          </Link>
        </Box>
      </Container>
    </Box>
  );
};

export default Register;

</code>

## segfault-frontend\src\state\authContext.tsx
<code>
import { createContext, useContext, useState, useEffect, type ReactNode } from 'react';

export interface User {
  id: string;
  name: string;
  email: string;
  role: 'USER' | 'GUEST' | 'ADMIN' | 'PIGS';
  picture?: string;
  isGov?: boolean;
}

export interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  login: (token: string) => void;
  logout: () => void;
  isGuest: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

function decodeJWT(token: string): User | null {
  try {
    console.log('[Auth] Decoding JWT token...');
    const base64Url = token.split('.')[1];
    if (!base64Url) {
      console.log('[Auth] No base64Url found in token');
      return null;
    }
    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
    const payload = JSON.parse(atob(base64));
    console.log('[Auth] JWT payload:', payload);
    const user: User = {
      id: payload.sub || payload.id || payload.userId || '',
      name: payload.name || payload.email?.split('@')[0] || 'User',
      email: payload.email || '',
      role: payload.role || 'USER',
      picture: payload.picture || undefined,
      isGov: payload.isGov || payload.role === 'PIGS' || false,
    };
    console.log('[Auth] Decoded user:', user);
    return user;
  } catch (err) {
    console.error('[Auth] Failed to decode JWT:', err);
    return null;
  }
}

interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    console.log('[Auth] AuthProvider initializing...');
    const token = localStorage.getItem('authToken');
    console.log('[Auth] Token from localStorage:', token ? `${token.substring(0, 20)}...` : 'null');
    
    if (token) {
      const decoded = decodeJWT(token);
      console.log('[Auth] Setting user from token:', decoded);
      setUser(decoded);
    }
    
    const guestTokenId = localStorage.getItem('guestTokenId');
    console.log('[Auth] guestTokenId from localStorage:', guestTokenId);
    if (guestTokenId && !token) {
      console.log('[Auth] Setting guest user');
      setUser({
        id: guestTokenId,
        name: 'Guest',
        email: '',
        role: 'GUEST',
      });
    }
    
    setIsLoading(false);
    console.log('[Auth] AuthProvider initialization complete');
  }, []);

  const login = (token: string) => {
    localStorage.setItem('authToken', token);
    const decoded = decodeJWT(token);
    setUser(decoded);
  };

  const logout = () => {
    localStorage.removeItem('authToken');
    localStorage.removeItem('guestTokenId');
    setUser(null);
  };

  const isGuest = user?.role === 'GUEST';

  const value: AuthContextType = {
    user,
    isLoading,
    login,
    logout,
    isGuest,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

export default AuthContext;

</code>

## segfault-moderation\function_app.py
<code>
import azure.functions as func
import logging
import json
import os
import requests
from io import BytesIO
from PIL import Image
from PIL.ExifTags import TAGS, GPSTAGS
from google import genai
from math import radians, cos, sin, asin, sqrt
import psycopg2

app = func.FunctionApp()

DATABASE_URL = os.environ.get("DATABASE_URL")
GEMINI_API_KEY = os.environ.get("GEMINI_API_KEY")
LOCATION_THRESHOLD_METERS = 100


def haversine(lon1: float, lat1: float, lon2: float, lat2: float) -> float:
    lon1, lat1, lon2, lat2 = map(radians, [lon1, lat1, lon2, lat2])
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
    c = 2 * asin(sqrt(a))
    r = 6371000
    return c * r


def get_decimal_coords(gps_info: dict) -> tuple[float, float] | None:
    try:
        lat = gps_info.get("GPSLatitude")
        lat_ref = gps_info.get("GPSLatitudeRef")
        lon = gps_info.get("GPSLongitude")
        lon_ref = gps_info.get("GPSLongitudeRef")

        if not all([lat, lat_ref, lon, lon_ref]):
            return None

        lat_decimal = lat[0] + lat[1] / 60 + lat[2] / 3600
        if lat_ref == "S":
            lat_decimal = -lat_decimal

        lon_decimal = lon[0] + lon[1] / 60 + lon[2] / 3600
        if lon_ref == "W":
            lon_decimal = -lon_decimal

        return (lat_decimal, lon_decimal)
    except Exception:
        return None


def extract_gps_from_image(image_bytes: bytes) -> tuple[float, float] | None:
    try:
        image = Image.open(BytesIO(image_bytes))
        exif_data = image._getexif()

        if not exif_data:
            return None

        gps_info = {}
        for tag_id, value in exif_data.items():
            tag = TAGS.get(tag_id, tag_id)
            if tag == "GPSInfo":
                for gps_tag_id, gps_value in value.items():
                    gps_tag = GPSTAGS.get(gps_tag_id, gps_tag_id)
                    gps_info[gps_tag] = gps_value

        return get_decimal_coords(gps_info)
    except Exception:
        return None


def analyze_with_gemini(image_bytes: bytes, issue_type: str) -> dict | None:
    try:
        client = genai.Client(api_key=GEMINI_API_KEY)

        prompt = f"""Analyze this image for a civic issue report of type: {issue_type}

Evaluate:
1. SAFETY: Is this image NSFW, violent, or abusive?
2. RELEVANCE: Does this appear to match the reported issue type?
3. SEVERITY: Rate urgency 1-5 (1=Minor, 5=Critical)

Respond ONLY with valid JSON:
{{"safe": true/false, "relevant": true/false, "severity": 1-5}}
"""

        response = client.models.generate_content(
            model="gemini-2.5-flash",
            contents=[
                {
                    "role": "user",
                    "parts": [
                        {"text": prompt},
                        {"image": image_bytes}
                    ]
                }
            ]
        )

        text = response.text.strip()
        if text.startswith("```"):
            text = text.split("```")[1]
            if text.startswith("json"):
                text = text[4:]

        return json.loads(text)

    except Exception as e:
        logging.error(f"Gemini analysis failed: {e}")
        return None


def update_issue(issue_id: int, authorized: bool, error: str, severity: int | None):
    conn = psycopg2.connect(DATABASE_URL)
    cursor = conn.cursor()

    authorized_val = "TRUE" if authorized else "FALSE"

    if severity is not None:
        cursor.execute(
            'UPDATE "Issue" SET authorized = %s, error = %s, severity = %s WHERE id = %s',
            (authorized_val, error, severity, issue_id)
        )
    else:
        cursor.execute(
            'UPDATE "Issue" SET authorized = %s, error = %s WHERE id = %s',
            (authorized_val, error, issue_id)
        )

    conn.commit()
    cursor.close()
    conn.close()


@app.queue_trigger(arg_name="msg", queue_name="issue-queue", connection="AzureWebJobsStorage")
def moderate_issue(msg: func.QueueMessage):
    try:
        data = json.loads(msg.get_body().decode("utf-8"))
        issue_id = data["issueId"]
        blob_url = data["blobUrl"]
        reported_lat = data["latitude"]
        reported_lng = data["longitude"]
        issue_type = data["issueType"]

        logging.info(f"Processing issue {issue_id}")

        response = requests.get(blob_url, timeout=30)
        response.raise_for_status()
        image_bytes = response.content

        image_gps = extract_gps_from_image(image_bytes)

        if image_gps:
            distance = haversine(image_gps[1], image_gps[0], reported_lng, reported_lat)
            logging.info(f"GPS distance: {distance:.0f}m")

            if distance > LOCATION_THRESHOLD_METERS:
                logging.warning(f"Issue {issue_id}: Location mismatch ({distance:.0f}m)")
                update_issue(issue_id, False, "INVALID_LOCATION", None)
                return

        result = analyze_with_gemini(image_bytes, issue_type)

        if result is None:
            logging.warning(f"Issue {issue_id}: Gemini failed. Auto approving.")
            update_issue(issue_id, True, "NONE", 3)
            return

        if not result.get("safe", True):
            logging.warning(f"Issue {issue_id}: Content violation")
            update_issue(issue_id, False, "INAPPROPRIATE_CONTENT", None)
            return

        severity = result.get("severity", 3)
        severity = max(1, min(5, severity))

        logging.info(f"Issue {issue_id}: Approved with severity {severity}")
        update_issue(issue_id, True, "NONE", severity)

    except Exception as e:
        logging.error(f"Moderation failed unexpectedly: {e}")
        logging.warning(f"Issue auto approved due to system failure: {issue_id}")
        update_issue(issue_id, True, "NONE", 3)

</code>

## segfault-moderation\host.json
<code>
{
  "version": "2.0",
  "logging": {
    "applicationInsights": {
      "samplingSettings": {
        "isEnabled": true,
        "excludedTypes": "Request"
      }
    }
  },
  "extensionBundle": {
    "id": "Microsoft.Azure.Functions.ExtensionBundle",
    "version": "[4.*, 5.0.0)"
  }
}

</code>

## segfault-moderation\local.settings.json
<code>
{
  "IsEncrypted": false,
  "Values": {
    "AzureWebJobsStorage": "DefaultEndpointsProtocol=https;AccountName=segfaultstorage3103;AccountKey=W8uzLvLydsQtC+S343wFzVW/67oeG4ulJ0aUiAjQA4F2pP+YBABgyV8gZMgdU2T1Vssn6syDzmOY+AStzwOwMQ==;EndpointSuffix=core.windows.net",
    "FUNCTIONS_WORKER_RUNTIME": "python",
    "DATABASE_URL": "postgresql://neondb_owner:npg_5GC3NzTORMYr@ep-restless-pine-a1vn25d9-pooler.ap-southeast-1.aws.neon.tech/neondb?sslmode=require",
    "GEMINI_API_KEY": "AIzaSyCwOPXy_F7budxwVHjTGwliKwXmWR2_xrI"
  }
}

</code>

## segfault-moderation\requirements.txt
<code>
azure-functions
pillow
requests
google-genai
psycopg2-binary

</code>

